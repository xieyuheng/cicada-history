#+property: tangle lib.rs
#+title: cicada
- the soundness of Subst::unify need to be proved
- Wissen::type_check -- by Term::value and Subst::unify
- new DeductionTree
- Proof::step
- how to change two mutual recursive functions
  to one (non-mutual) recursive function ?
  - << the seasoned schemer >>
* [note]

*** semantic

***** Cons & Prop

      - Cons -- data-constructor
      - Prop -- type-constructor

      - Den::Disj is definition of Prop
      - Den::Conj is definition of Prop and Cons

***** Value

      - Term::value will give a Value
        part of the Value is pre-defined which is specified by
        the definition of the Cons -- the definition of its Den::Conj

      - during Term::value
        its pre-defined is unified with its args

      - this is like runtime assertion in prolog

***** type-check

      - type-check is simply to check that
        the equation in `data` has a solution

      - `disj` -- exporting equations
        `heir` -- importing equations

***** recursion

      - define all Den first and then check them

***** logic-var

      - logic-var start with `:`

***** proving

      - Prop is to be proved

      - to prove a Prop defined by Den::Disj
        is to dispatch it

      - to prove a Prop defined by Den::Conj
        we unify args withs fields
        and we also need to prove remaining Prop in Value

      - `heir` is just like `data`

*** implementation

***** update-able

      - Subst must contains two kinds of binding
        one for type, one for value
        to make type binding update-able
        from disj to its member conj

* prolog

*** feature

    #+begin_src rust
    #![feature (uniform_paths)]
    #![feature (bind_by_move_pattern_guards)]
    #![feature (box_patterns)]
    #![feature (box_syntax)]

    #![allow (dead_code)]
    #+end_src

*** use

    #+begin_src rust
    use std::fmt;
    use std::sync::Arc;
    use std::collections::VecDeque;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use uuid::Uuid;
    use dic::Dic;
    use error_report::{
        Span,
        ErrorMsg,
        ErrorInCtx,
    };
    #[cfg (test)]
    use error_report::{
        ErrorCtx,
    };
    use mexp::{
        SyntaxTable,
        Mexp,
        MexpArg,
    };
    #+end_src

* utility

*** vec_to_string

    #+begin_src rust
    fn vec_to_string <T> (vec: &Vec <T>, delimiter: &str) -> String
    where T : ToString {
        let mut s = String::new ();
        for x in vec {
            s += &x.to_string ();
            s += delimiter;
        }
        for _ in 0 .. delimiter.len () {
            s.pop ();
        }
        s
    }
    #+end_src

*** vec_to_lines

    #+begin_src rust
    fn vec_to_lines <T> (vec: &Vec <T>) -> String
    where T : ToString {
        let mut s = vec_to_string (vec, "\n");
        if ! s.is_empty () {
            s += "\n";
        }
        s
    }
    #+end_src

*** dic_to_string

    #+begin_src rust
    fn dic_to_string <T> (dic: &Dic <T>) -> String
    where T : ToString {
        let mut s = String::new ();
        for (k, v) in dic.iter () {
            s += &k.to_string ();
            s += " = ";
            s += &v.to_string ();
            s += ", ";
        }
        for _ in 0 .. ", ".len () {
            s.pop ();
        }
        s
    }
    #+end_src

*** dic_to_lines

    #+begin_src rust
    fn dic_to_lines <T> (dic: &Dic <T>) -> String
    where T : ToString {
        let mut s = String::new ();
        for (k, v) in dic.iter () {
            s += &k.to_string ();
            s += " = ";
            s += &v.to_string ();
            s += "\n";
        }
        s
    }
    #+end_src

*** add_tag

    #+begin_src rust
    fn add_tag (tag: &str, input: String) -> String {
        let start = tag;
        let end = &tag[1 .. tag.len () - 1];
        let end = format! ("</{}>", end);
        if input.is_empty () {
            format! ("{}{}\n", start, end)
        } else {
            format! ("{}\n{}{}\n", start, input, end)
        }
    }
    #+end_src

* Term

*** Term

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Term {
        Var (Span, String),
        Cons (Span, String, Arg),
        Prop (Span, String, Arg),
        FieldRef (Span, String),
        TypeOfType (Span),
    }
    #+end_src

*** Term::to_string

    #+begin_src rust
    impl ToString for Term {
        fn to_string (&self) -> String {
            match self {
                Term::Var (_span, name) => {
                    name.clone ()
                }
                Term::Cons (_span, name, arg) |
                Term::Prop (_span, name, arg) => {
                    if arg.is_empty () {
                        format! ("{}", name)
                    } else {
                        format! ("{} {}", name, arg.to_string ())
                    }
                }
                Term::FieldRef (_span, name) => {
                    format! ("{}", name)
                }
                Term::TypeOfType (_span) => {
                    format! ("type")
                }
            }
        }
    }
    #+end_src

*** Term::span

    #+begin_src rust
    impl Term {
        fn span (&self) -> Span {
            match self {
                Term::Var (span, _name) => {
                    span.clone ()
                }
                Term::Cons (span, _name, _arg) |
                Term::Prop (span, _name, _arg) => {
                    span.clone ()
                }
                Term::FieldRef (span, _name) => {
                    span.clone ()
                }
                Term::TypeOfType (span) => {
                    span.clone ()
                }
            }
        }
    }
    #+end_src

*** [todo] Term::value

    #+begin_src rust
    impl Term {
        pub fn value (
            &self,
            wissen: &Wissen,
            subst: &mut Subst,
            body: &Dic <Value>,
            var_dic: &mut Dic <Value>,
            against: Option <&Value>,
        ) -> Result <Value, ErrorInCtx> {
            match self {
                Term::Var (_span, name) => {
                    if let Some (value) = var_dic.get (name) {
                        Ok (value.clone ())
                    } else {
                        let new_var = Value::Var (Var::new (name));
                        var_dic.ins (name, Some (new_var.clone ()));
                        Ok (new_var)
                    }
                }
                Term::Cons (span, name, arg) => {
                    let (data, s) = wissen.get_new_data (name)?;
                    *subst = subst.append (s);
                    if let Some (old_value) = against {
                        if let Some (
                            s
                        ) = subst.unify (&old_value, &data) {
                            *subst = subst.append (s);
                            value_dic_merge_arg (
                                data.value_dic () .unwrap (), arg,
                                wissen, subst, body, var_dic)?;
                            Ok (data)
                        } else {
                            return ErrorInCtx::new ()
                                .head ("Term::value")
                                .line ("on Term::Cons")
                                .line ("unification fail")
                                .line (&format! (
                                    "old_value = {}",
                                    old_value.to_string ()))
                                .line (&format! (
                                    "data = {}",
                                    data.to_string ()))
                                .span (span.clone ())
                                .wrap_in_err ()
                        }
                    } else {
                        return ErrorInCtx::new ()
                            .head ("Term::value")
                            .line ("on Term::Cons")
                            .line (&format! ("name = {}", name))
                            .line ("no against")
                            .span (span.clone ())
                            .wrap_in_err ()
                    }
                }
                Term::Prop (span, name, arg) => {
                    let (prop, s) = wissen.get_prop (name)?;
                    *subst = subst.append (s);
                    if let Some (old_value) = against {
                        if let Some (
                            s
                        ) = subst.unify (&old_value, &prop) {
                            *subst = subst.append (s);
                        } else {
                            return ErrorInCtx::new ()
                                .head ("Term::value")
                                .line ("on Term::Prop")
                                .line ("unification fail")
                                .line (&format! (
                                    "old_value = {}",
                                    old_value.to_string ()))
                                .line (&format! (
                                    "prop = {}",
                                    prop.to_string ()))
                                .span (span.clone ())
                                .wrap_in_err ()
                        }
                    }
                    value_dic_merge_arg (
                        prop.value_dic () .unwrap (), arg,
                        wissen, subst, body, var_dic)?;
                    Ok (prop)
                }
                Term::FieldRef (_span, name) => {
                    let value = body.get (name) .unwrap ();
                    Ok (value.clone ())
                }
                Term::TypeOfType (_span) => {
                    Ok (Value::TypeOfType)
                }
            }
        }
    }
    #+end_src

*** [todo] value_dic_merge_arg

    #+begin_src rust
    fn value_dic_merge_arg (
        value_dic: &Dic <Value>,
        arg: &Arg,
        wissen: &Wissen,
        subst: &mut Subst,
        body: &Dic <Value>,
        var_dic: &mut Dic <Value>,
    ) -> Result <(), ErrorInCtx> {
        match arg {
            Arg::Vec (term_vec) => {
                for term in term_vec {
                    let old_value = value_dic_next_value (
                        value_dic,
                        subst.clone ());
                    let value = term.value (
                        wissen, subst, body, var_dic,
                        Some (&old_value))?;
                }
                Ok (())
            }
            Arg::Rec (binding_vec) => {
                for binding in binding_vec {
                    match binding {
                        Binding::EqualTo (name, term) => {
                            if let Some (
                                old_value
                            ) = value_dic.get (name) {
                                let value = term.value (
                                    wissen, subst, body, var_dic,
                                    Some (old_value))?;
                            } else {
                                return ErrorInCtx::new ()
                                    .head ("value_dic_merge_arg")
                                    .line ("on Binding::EqualTo")
                                    .line (&format! ("name = {}", name))
                                    .span (term.span ())
                                    .wrap_in_err ()
                            }
                        }
                        Binding::Inhabit (name, term) => {
                            return ErrorInCtx::new ()
                                .head ("value_dic_merge_arg")
                                .line ("on Binding::Inhabit")
                                .line (&format! ("name = {}", name))
                                .span (term.span ())
                                .wrap_in_err ()
                        }
                    }
                }
                Ok (())
            }
        }
    }
    #+end_src

*** [todo] value_dic_next_value

    #+begin_src rust
    fn value_dic_next_value (
        value_dic: &Dic <Value>,
        subst: Subst,
    ) -> Value {
        for value in value_dic.values () {
            let value = subst.walk (value);
            if let Value::TypedVar (_) = value {
                return value;
            }
        }
        panic! ("value_dic_next_value")
    }
    #+end_src

*** Arg

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Arg {
        Vec (Vec <Term>),
        Rec (Vec <Binding>),
    }
    #+end_src

*** Arg::is_empty

    #+begin_src rust
    impl Arg {
        fn is_empty (&self) -> bool {
            match self {
                Arg::Vec (term_vec) => term_vec.is_empty (),
                Arg::Rec (binding_vec) => binding_vec.is_empty (),
            }
        }
    }
    #+end_src

*** Arg::to_string

    #+begin_src rust
    impl ToString for Arg {
        fn to_string (&self) -> String {
            match self {
                Arg::Vec (term_vec) => {
                    format! (
                        "({})",
                        vec_to_string (term_vec, " "))
                }
                Arg::Rec (binding_vec) => {
                    format! (
                        "{{ {} }}",
                        vec_to_string (binding_vec, ", "))
                }
            }
        }
    }
    #+end_src

*** Binding

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Binding {
        EqualTo (String, Term),
        Inhabit (String, Term),
    }
    #+end_src

*** Binding::to_string

    #+begin_src rust
    impl ToString for Binding {
        fn to_string (&self) -> String {
            match self {
                Binding::EqualTo (name, term) => {
                    format! ("{} = {}", name, term.to_string ())
                }
                Binding::Inhabit (name, term) => {
                    format! ("{} : {}", name, term.to_string ())
                }
            }
        }
    }
    #+end_src

*** [todo] Binding::bind

    #+begin_src rust
    impl Binding {
        fn bind (
            &self,
            wissen: &Wissen,
            subst: &mut Subst,
            body: &mut Dic <Value>,
            var_dic: &mut Dic <Value>,
        ) -> Result <(), ErrorInCtx> {
            match self {
                Binding::EqualTo (name, term) => {
                    let old_value = body.get (name) .unwrap ();
                    let _value = term.value (
                        wissen, subst, body, var_dic,
                        Some (old_value))?;
                    Ok (())
                }
                Binding::Inhabit (name, term) => {
                    let value = term.value (
                        wissen, subst, body, var_dic,
                        None)?;
                    let typed_var = new_typed_var (name, &value);
                    if let Some (
                        old_value
                    ) = body.get (name) {
                        if let Some (
                            new_subst
                        ) = subst.unify (&old_value, &typed_var) {
                            *subst = subst.append (new_subst);
                        } else {
                            return ErrorInCtx::new ()
                                .head ("Binding::bind")
                                .line ("on Binding::Inhabit")
                                .span (term.span ())
                                .wrap_in_err ()
                        }
                    } else {
                        var_dic.ins (name, Some (typed_var.clone ()));
                        body.ins (name, Some (typed_var));
                    }
                    Ok (())
                }
            }
        }
    }
    #+end_src

*** [todo] new_typed_var

    #+begin_src rust
    fn new_typed_var (name: &str, value: &Value) -> Value {
        Value::TypedVar (TypedVar {
            id: Id::uuid (),
            name: name.to_string (),
            ty: box value.clone (),
        })
    }
    #+end_src

* Value

*** Value

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Value {
        Var (Var),
        TypedVar (TypedVar),
        Disj (Disj),
        Conj (Conj),
        Data (Data),
        TypeOfType,
    }
    #+end_src

*** Value::to_string

    #+begin_src rust
    impl ToString for Value {
        fn to_string (&self) -> String {
            match self {
                Value::Var (var) => var.to_string (),
                Value::TypedVar (typed_var) => typed_var.to_string (),
                Value::Disj (disj) => disj.to_string (),
                Value::Conj (conj) => conj.to_string (),
                Value::Data (data) => data.to_string (),
                Value::TypeOfType => format! ("type"),
            }
        }
    }
    #+end_src

*** Value::value_dic

    #+begin_src rust
    impl Value {
        fn value_dic (&self) -> Option <&Dic <Value>> {
            match self {
                Value::Disj (disj) => Some (&disj.body),
                Value::Conj (conj) => Some (&conj.body),
                Value::Data (data) => Some (&data.body),
                _ => None,
            }
        }
    }
    #+end_src

*** Id

***** Id

      #+begin_src rust
      #[derive (Clone)]
      #[derive (PartialEq, Eq, Hash)]
      pub enum Id {
          Uuid (uuid::adapter::Hyphenated),
          Local (usize),
      }
      #+end_src

***** Id::uuid

      #+begin_src rust
      impl Id {
          fn uuid () -> Self {
              Id::Uuid (Uuid::new_v4 () .to_hyphenated ())
          }
      }
      #+end_src

***** Id::local

      #+begin_src rust
      impl Id {
          fn local (counter: usize) -> Self {
              Id::Local (counter)
          }
      }
      #+end_src

***** Id::fmt

      #+begin_src rust
      impl fmt::Debug for Id {
          fn fmt (&self, f: &mut fmt::Formatter) -> fmt::Result {
              match self {
                  Id::Uuid (uuid) => write! (f, "{}", uuid),
                  Id::Local (counter) => write! (f, "{}", counter),
              }
          }
      }
      #+end_src

***** Id::to_string

      #+begin_src rust
      impl ToString for Id {
          fn to_string (&self) -> String {
              match self {
                  Id::Uuid (uuid) => {
                      // uuid.to_string ()
                      let s = uuid.to_string ();
                      format! ("{}", &s[0 .. 3])
                  }
                  Id::Local (counter) => {
                      format! ("{}", counter)
                  }
              }
          }
      }
      #+end_src

*** Var

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub struct Var {
        id: Id,
        name: String,
    }
    #+end_src

*** Var::new

    #+begin_src rust
    impl Var {
        fn new (s: &str) -> Self {
            Var {
                id: Id::uuid (),
                name: s.to_string (),
            }
        }
    }
    #+end_src

*** Var::local

    #+begin_src rust
    impl Var {
        fn local (s: &str, counter: usize) -> Self {
            Var {
                id: Id::local (counter),
                name: s.to_string (),
            }
        }
    }
    #+end_src

*** Var::to_string

    #+begin_src rust
    impl ToString for Var {
        fn to_string (&self) -> String {
            format! (
                "{}#{}",
                self.name,
                self.id.to_string ())
        }
    }
    #+end_src

*** TypedVar

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct TypedVar {
        id: Id,
        name: String,
        ty: Box <Value>,
    }
    #+end_src

*** TypedVar::to_string

    #+begin_src rust
    impl ToString for TypedVar {
        fn to_string (&self) -> String {
            format! (
                "{}#{} : {}",
                self.name,
                self.id.to_string (),
                self.ty.to_string ())
        }
    }
    #+end_src

*** Disj

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Disj {
        name: String,
        name_vec: Vec <String>,
        body: Dic <Value>,
    }
    #+end_src

*** Disj::to_string

    #+begin_src rust
    impl ToString for Disj {
        fn to_string (&self) -> String {
            if self.body.is_empty () {
                format! (
                    "{} ({}) {{}}",
                    self.name,
                    vec_to_string (&self.name_vec, ", "))
            } else {
                format! (
                    "{} ({}) {{ {} }}",
                    self.name,
                    vec_to_string (&self.name_vec, ", "),
                    dic_to_string (&self.body))
            }
        }
    }
    #+end_src

*** Conj

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Conj {
        name: String,
        body: Dic <Value>,
    }
    #+end_src

*** Conj::to_string

    #+begin_src rust
    impl ToString for Conj {
        fn to_string (&self) -> String {
            if self.body.is_empty () {
                format! (
                    "{} {{}}",
                    self.name)
            } else {
                format! (
                    "{} {{ {} }}",
                    self.name,
                    dic_to_string (&self.body))
            }
        }
    }
    #+end_src

*** Data

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Data {
        name: String,
        body: Dic <Value>,
    }
    #+end_src

*** Data::to_string

    #+begin_src rust
    impl ToString for Data {
        fn to_string (&self) -> String {
            if self.body.is_empty () {
                format! (
                    "{} {{}}",
                    self.name)
            } else {
                format! (
                    "{} {{ {} }}",
                    self.name,
                    dic_to_string (&self.body))
            }
        }
    }
    #+end_src

* Subst

*** Subst

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Subst {
        Null,
        VarBinding (Var, Value, Arc <Subst>),
        TypedVarBinding (TypedVar, Value, Arc <Subst>),
    }
    #+end_src

*** Subst::new

    #+begin_src rust
    impl Subst {
        fn new () -> Self {
            Subst::Null
        }
    }
    #+end_src

*** Subst::bind_var

    #+begin_src rust
    impl Subst {
        fn bind_var (
            &self,
            var: Var,
            value: Value,
        ) -> Self {
            Subst::VarBinding (
                var,
                value,
                Arc::new (self.clone ()))
        }
    }
    #+end_src

*** Subst::bind_typed_var

    #+begin_src rust
    impl Subst {
        fn bind_typed_var (
            &self,
            typed_var: TypedVar,
            value: Value,
        ) -> Self {
            Subst::TypedVarBinding (
                typed_var,
                value,
                Arc::new (self.clone ()))
        }
    }
    #+end_src

*** Subst::find_var

    #+begin_src rust
    impl Subst {
        pub fn find_var (
            &self,
            var: &Var,
        ) -> Option <&Value> {
            match self {
                Subst::Null => None,
                Subst::VarBinding (
                    var1, value, next,
                ) => {
                    if var1 == var {
                        Some (value)
                    } else {
                        next.find_var (var)
                    }
                }
                Subst::TypedVarBinding (
                    _typed_var, _value, next,
                ) => {
                    next.find_var (var)
                }
            }
        }
    }
    #+end_src

*** Subst::find_typed_var

    #+begin_src rust
    impl Subst {
        pub fn find_typed_var (
            &self,
            typed_var: &TypedVar,
        ) -> Option <&Value> {
            match self {
                Subst::Null => None,
                Subst::VarBinding (
                    _var, _value, next,
                ) => {
                    next.find_typed_var (typed_var)
                }
                Subst::TypedVarBinding (
                    typed_var1, value, next,
                ) => {
                    if typed_var1 == typed_var {
                        Some (value)
                    } else {
                        next.find_typed_var (typed_var)
                    }
                }
            }
        }
    }
    #+end_src

*** Subst::walk

    #+begin_src rust
    impl Subst {
        pub fn walk (&self, value: &Value) -> Value {
            match value {
                Value::Var (var) => {
                    if let Some (
                        new_value
                    ) = self.find_var (var) {
                        self.walk (new_value)
                    } else {
                        value.clone ()
                    }
                }
                Value::TypedVar (typed_var) => {
                    if let Some (
                        new_value
                    ) = self.find_typed_var (typed_var) {
                        self.walk (new_value)
                    } else {
                        value.clone ()
                    }
                }
                _ => value.clone ()
            }
        }
    }
    #+end_src

*** [todo] Subst::unify

    #+begin_src rust
    impl Subst {
        pub fn unify (
            &self,
            u: &Value,
            v: &Value,
        ) -> Option <Subst> {
            let u = self.walk (u);
            let v = self.walk (v);
            match (u, v) {
                (Value::Var (u),
                 Value::Var (v),
                ) if u == v => {
                    Some (self.clone ())
                }
                (Value::TypedVar (u),
                 Value::TypedVar (v),
                ) if u == v => {
                    Some (self.clone ())
                }
                (Value::Var (u), v) => {
                    if self.var_occur_p (&u, &v) {
                        None
                    } else {
                        Some (self.bind_var (u, v))
                    }
                }
                (u, Value::Var (v)) => {
                    if self.var_occur_p (&v, &u) {
                        None
                    } else {
                        Some (self.bind_var (v, u))
                    }
                }
                (Value::TypedVar (u), v) => {
                    if self.typed_var_occur_p (&u, &v) {
                        None
                    } else if let Some (
                        subst
                    ) = self.unify_type_to_value (&u.ty, &v) {
                        Some (subst.bind_typed_var (u, v))
                    } else {
                        None
                    }
                }
                (u, Value::TypedVar (v)) => {
                    if self.typed_var_occur_p (&v, &u) {
                        None
                    } else if let Some (
                        subst
                    ) = self.unify_type_to_value (&v.ty, &u) {
                        Some (subst.bind_typed_var (v, u))
                    } else {
                        None
                    }
                }
                (Value::Data (u),
                 Value::Data (v),
                ) => {
                    if u.name != v.name {
                        return None;
                    }
                    self.unify_dic (&u.body, &v.body)
                }
                // ><><><
                // Value::Disj Value::Disj
                // ><><><
                // Value::Conj Value::Conj
                // ><><><
                // Value::Conj Value::Disj
                // ><><><
                // Value::Disj Value::Conj
                (u, v) => {
                    if u == v {
                        Some (self.clone ())
                    } else {
                        None
                    }
                }
            }
        }
    }
    #+end_src

*** [todo] Subst::unify_type_to_value

    #+begin_src rust
    impl Subst {
        pub fn unify_type_to_value (
            &self,
            t: &Value,
            v: &Value,
        ) -> Option <Subst> {
            let t = self.walk (t);
            let v = self.walk (v);
            match (t, v) {
                (Value::Conj (conj), Value::Data (data)) => {
                    let prop_name = cons_name_to_prop_name (
                        &data.name);
                    if conj.name != prop_name {
                        None
                    } else {
                        self.cover_dic (
                            &data.body,
                            &conj.body)
                    }
                }
                (Value::Disj (disj), Value::Data (data)) => {
                    let prop_name = cons_name_to_prop_name (
                        &data.name);
                    let name_set: HashSet <String> = disj.name_vec
                        .clone ()
                        .into_iter ()
                        .collect ();
                    if name_set.contains (&prop_name) {
                        self.cover_dic (
                            &data.body,
                            &disj.body)
                    } else {
                        None
                    }
                }
                (Value::TypeOfType, Value::Disj (..)) => {
                    Some (self.clone ())
                }
                (Value::TypeOfType, Value::Conj (..)) => {
                    Some (self.clone ())
                }
                (t, Value::TypedVar (v)) => {
                    self.unify (&t, &v.ty)
                }
                _ => {
                    None
                }
            }
        }
    }
    #+end_src

*** Subst::cover_dic

    #+begin_src rust
    impl Subst {
        pub fn cover_dic (
            &self,
            large_dic: &Dic <Value>,
            small_dic: &Dic <Value>,
        ) -> Option <Subst> {
            let mut subst = self.clone ();
            for (name, v) in small_dic.iter () {
                if let Some (v1) = large_dic.get (name) {
                    subst.unify (v1, v)?;
                } else {
                    return None;
                }
            }
            Some (subst)
        }
    }
    #+end_src

*** Subst::unify_dic

    #+begin_src rust
    impl Subst {
        pub fn unify_dic (
            &self,
            u_dic: &Dic <Value>,
            v_dic: &Dic <Value>,
        ) -> Option <Subst> {
            let mut subst = self.clone ();
            let zip = u_dic.entries () .zip (v_dic.entries ());
            for (u_entry, v_entry) in zip {
                if u_entry.name != v_entry.name {
                    return None;
                } else {
                    if let (
                        Some (u_value),
                        Some (v_value),
                    ) = (&u_entry.value, &v_entry.value) {
                        subst = subst.unify (
                            u_value,
                            v_value)?;
                    } else {
                        return None
                    }
                }
            }
            Some (subst)
        }
    }
    #+end_src

*** [todo] Subst::var_occur_p

    #+begin_src rust
    impl Subst {
        pub fn var_occur_p (
            &self,
            var: &Var,
            value: &Value,
        ) -> bool {
            let value = self.walk (value);
            match value {
                Value::Var (var1) => {
                    var == &var1
                }
                Value::Data (data) => {
                    for value in data.body.values () {
                        if self.var_occur_p (var, value) {
                            return true;
                        }
                    }
                    return false;
                }
                _ => {
                    false
                }
            }
        }
    }
    #+end_src

*** [todo] Subst::typed_var_occur_p

    #+begin_src rust
    impl Subst {
        pub fn typed_var_occur_p (
            &self,
            typed_var: &TypedVar,
            value: &Value,
        ) -> bool {
            let value = self.walk (value);
            match value {
                Value::TypedVar (typed_var1) => {
                    typed_var == &typed_var1
                }
                Value::Data (data) => {
                    for value in data.body.values () {
                        if self.typed_var_occur_p (typed_var, value) {
                            return true;
                        }
                    }
                    return false;
                }
                _ => {
                    false
                }
            }
        }
    }
    #+end_src

*** Subst::len

    #+begin_src rust
    impl Subst {
        pub fn len (&self) -> usize {
            let mut len = 0;
            let mut subst = self;
            loop {
                match subst {
                    Subst::Null => break,
                    Subst::VarBinding (
                        _var, _value, next
                    ) => {
                        len += 1;
                        subst = &next;
                    }
                    Subst::TypedVarBinding (
                        _typed_var, _value, next
                    ) => {
                        len += 1;
                        subst = &next;
                    }
                }
            }
            len
        }
    }
    #+end_src

*** Subst::append

    #+begin_src rust
    impl Subst {
        pub fn append (&self, subst: Subst) -> Subst {
            match self {
                Subst::Null => { subst }
                Subst::VarBinding (var, value, next) => {
                    Subst::VarBinding (
                        var.clone (),
                        value.clone (),
                        Arc::new (next.append (subst)))
                }
                Subst::TypedVarBinding (typed_var, value, next) => {
                    Subst::TypedVarBinding (
                        typed_var.clone (),
                        value.clone (),
                        Arc::new (next.append (subst)))
                }
            }
        }
    }
    #+end_src

*** Subst::to_string

    #+begin_src rust
    impl ToString for Subst {
        fn to_string (&self) -> String {
            let mut s = String::new ();
            let mut subst = self;
            loop {
                match subst {
                    Subst::Null => break,
                    Subst::VarBinding (
                        var, value, next
                    ) => {
                        s += &var.to_string ();
                        s += " = ";
                        s += &value.to_string ();
                        s += "\n";
                        subst = &next;
                    }
                    Subst::TypedVarBinding (
                        typed_var, value, next
                    ) => {
                        s += &typed_var.to_string ();
                        s += " = ";
                        s += &value.to_string ();
                        s += "\n";
                        subst = &next;
                    }
                }
            }
            add_tag ("<subst>", s)
        }
    }
    #+end_src

* Den

*** Den

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Den {
        Disj (Vec <String>, Vec <Binding>),
        Conj (Vec <Binding>),
    }
    #+end_src

*** Den::to_string

    #+begin_src rust
    impl ToString for Den {
        fn to_string (&self) -> String {
            match self {
                Den::Disj (name_vec, binding_vec) => {
                    if binding_vec.is_empty () {
                        format! (
                            "disj ({}) {{}}",
                            vec_to_string (name_vec, " "))
                    } else {
                        format! (
                            "disj ({}) {{ {} }}",
                            vec_to_string (name_vec, " "),
                            vec_to_string (binding_vec, ", "))
                    }
                }
                Den::Conj (binding_vec) => {
                    if binding_vec.is_empty () {
                        format! ("conj {{}}")
                    } else {
                        format! (
                            "conj {{ {} }}",
                            vec_to_string (binding_vec, ", "))
                    }
                }
            }
        }
    }
    #+end_src

* Wissen

*** Wissen

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Wissen {
        den_dic: Dic <Den>,
    }
    #+end_src

*** Wissen::new

    #+begin_src rust
    impl Wissen {
        pub fn new () -> Self {
            Wissen {
                den_dic: Dic::new (),
            }
        }
    }
    #+end_src

*** Wissen::den

    #+begin_src rust
    impl Wissen {
        pub fn den (&mut self, name: &str, den: &Den) {
           self.den_dic.ins (name, Some (den.clone ()));
        }
    }
    #+end_src

*** [todo] Wissen::wis

    #+begin_src rust
    impl Wissen {
        pub fn wis <'a> (
            &'a mut self,
            input: &str,
        ) -> Result <Vec <WissenOutput>, ErrorInCtx> {
            let syntax_table = SyntaxTable::default ();
            let mexp_vec = syntax_table.parse (input)?;
            let statement_vec = mexp_vec_to_statement_vec (&mexp_vec)?;
            for statement in &statement_vec {
                if let Statement::Den (
                    name, den
                ) = statement {
                    self.den (name, den);
                }
            }
            let mut output_vec = Vec::new ();
            // ><><><
            Ok (output_vec)
        }
    }
    #+end_src

*** Wissen::to_string

    #+begin_src rust
    impl ToString for Wissen {
        fn to_string (&self) -> String {
            add_tag ("<wissen>", dic_to_lines (&self.den_dic))
        }
    }
    #+end_src

*** Wissen::get_prop

    #+begin_src rust
    impl Wissen {
        fn get_prop (
            &self,
            name: &str,
        ) -> Result <(Value, Subst), ErrorInCtx> {
            let den = self.den_dic.get (name) .unwrap ();
            match den {
                Den::Disj (name_vec, binding_vec) => {
                    let (body, subst) = new_value_dic (
                        self, binding_vec)?;
                    let disj = Value::Disj (Disj {
                        name: name.to_string (),
                        name_vec: name_vec.clone (),
                        body,
                    });
                    Ok ((disj, subst))
                }
                Den::Conj (binding_vec) => {
                    let (body, subst) = new_value_dic (
                        self, binding_vec)?;
                    let conj = Value::Conj (Conj {
                        name: name.to_string (),
                        body,
                    });
                    Ok ((conj, subst))
                }
            }
        }
    }
    #+end_src

*** cons_name_to_prop_name

    #+begin_src rust
    fn cons_name_to_prop_name (cons_name: &str) -> String {
        let base_name = &cons_name[.. cons_name.len () - 2];
        format! ("{}-t", base_name)
    }
    #+end_src

*** Wissen::get_new_data

    #+begin_src rust
    impl Wissen {
        fn get_new_data (
            &self,
            name: &str,
        ) -> Result <(Value, Subst), ErrorInCtx> {
            let prop_name = &cons_name_to_prop_name (name);
            let (prop, subst) = self.get_prop (prop_name)?;
            let value_dic = prop.value_dic () .unwrap ();
            let data = Value::Data (Data {
                name: name.to_string (),
                body: value_dic.clone (),
            });
            Ok ((data, subst))
        }
    }
    #+end_src

*** new_value_dic

    #+begin_src rust
    fn new_value_dic (
        wissen: &Wissen,
        binding_vec: &Vec <Binding>,
    ) -> Result <(Dic <Value>, Subst), ErrorInCtx> {
        let mut subst = Subst::new ();
        let mut body = Dic::new ();
        let mut var_dic = Dic::new ();
        for binding in binding_vec {
            binding.bind (
                wissen,
                &mut subst,
                &mut body,
                &mut var_dic)?;
        }
        Ok ((body, subst))
    }
    #+end_src

*** [todo] WissenOutput

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct WissenOutput;
    #+end_src

* Statement

*** [todo] Statement

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Statement {
        Den (String, Den),
        PlaceHolder,
        // Query (usize, Vec <Prop>),
        // Prove (usize, Vec <Prop>),
    }
    #+end_src

* Proving

*** [todo] Proving

* Proof

*** [todo] Proof

* Qed

*** [todo] Qed

* syntax

*** GRAMMAR

    #+begin_src rust
    const GRAMMAR: &'static str = r#"
    Statement::Den = { prop-name? "=" Den }
    Den::Disj = { "disj" '(' list (prop-name?) ')' Arg::Rec }
    Den::Conj = { "conj" Arg::Rec }
    Term::Var = { var-name? }
    Term::Cons = { cons-name? Arg }
    Term::Prop = { prop-name? Arg }
    Arg::Vec = { '(' list (Term) ')' }
    Arg::Rec = { '{' list (Binding) '}' }
    Binding::Term = { field-name? "=" Term }
    "#;
    #+end_src

*** note_about_grammar

    #+begin_src rust
    fn note_about_grammar () -> ErrorMsg {
        ErrorMsg::new ()
            .head ("grammar :")
            .lines (GRAMMAR)
    }
    #+end_src

*** symbol predicates

***** var_symbol_p

      #+begin_src rust
      fn var_symbol_p (symbol: &str) -> bool {
          symbol.starts_with (":")
      }
      #+end_src

***** cons_name_symbol_p

      #+begin_src rust
      fn cons_name_symbol_p (symbol: &str) -> bool {
          (! var_symbol_p (symbol) &&
           symbol.ends_with ("-c"))
      }
      #+end_src

***** prop_name_symbol_p

      #+begin_src rust
      fn prop_name_symbol_p (symbol: &str) -> bool {
          (! var_symbol_p (symbol) &&
           symbol.ends_with ("-t"))
      }
      #+end_src

***** type_of_type_symbol_p

      #+begin_src rust
      fn type_of_type_symbol_p (symbol: &str) -> bool {
          symbol == "type"
      }
      #+end_src

***** field_name_symbol_p

      #+begin_src rust
      fn field_name_symbol_p (symbol: &str) -> bool {
          (! var_symbol_p (symbol) &&
           ! cons_name_symbol_p (symbol) &&
           ! prop_name_symbol_p (symbol) &&
           ! type_of_type_symbol_p (symbol))
      }
      #+end_src

*** mexp_to_prop_name

    #+begin_src rust
    fn mexp_to_prop_name <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <String, ErrorInCtx> {
        if let Mexp::Sym {
            symbol,
            ..
        } = mexp {
            if prop_name_symbol_p (symbol) {
                Ok (symbol.to_string ())
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name")
                    .line ("which must end with `-t`")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .line ("expecting prop name")
                .line (&format! ("mexp = {}", mexp.to_string ()))
                .span (mexp.span ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_var_term

    #+begin_src rust
    fn mexp_to_var_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        if let Mexp::Sym {
            span,
            symbol,
        } = mexp {
            if var_symbol_p (symbol) {
                Ok (Term::Var (
                    span.clone (),
                    symbol.to_string ()))
            } else {
                ErrorInCtx::new ()
                    .head ("syntex error")
                    .line ("expecting var symbol")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_field_ref_term

    #+begin_src rust
    fn mexp_to_field_ref_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        if let Mexp::Sym {
            span,
            symbol,
        } = mexp {
            if field_name_symbol_p (symbol) {
                Ok (Term::FieldRef (
                    span.clone (),
                    symbol.to_string ()))
            } else {
                ErrorInCtx::new ()
                    .head ("syntex error")
                    .line ("expecting field name symbol")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_arg_to_arg

    #+begin_src rust
    fn mexp_arg_to_arg <'a> (
        mexp_arg: &MexpArg <'a>,
    ) -> Result <Arg, ErrorInCtx> {
        match mexp_arg {
            MexpArg::Tuple { body, .. } => {
                Ok (Arg::Vec (mexp_vec_to_term_vec (body)?))
            }
            MexpArg::Block { body, .. } => {
                Ok (Arg::Rec (mexp_vec_to_binding_vec (body)?))
            }
        }
    }
    #+end_src

*** mexp_to_cons_term

    #+begin_src rust
    fn mexp_to_cons_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Sym {
                symbol,
                ..
            },
            arg,
            ..
        } = mexp {
            if cons_name_symbol_p (symbol) {
                Ok (Term::Cons (
                    mexp.span (),
                    symbol.to_string (),
                    mexp_arg_to_arg (arg)?))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting cons name symbol")
                    .line ("which must end with `-c`")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else if let Mexp::Sym {
            symbol,
            span,
        } = mexp {
            if cons_name_symbol_p (symbol) {
                Ok (Term::Cons (
                    span.clone (),
                    symbol.to_string (),
                    Arg::Rec (Vec::new ())))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting cons name symbol")
                    .line ("which must end with `-c`")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_prop_term

    #+begin_src rust
    fn mexp_to_prop_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Sym {
                symbol,
                ..
            },
            arg,
            ..
        } = mexp {
            if prop_name_symbol_p (symbol) {
                Ok (Term::Prop (
                    mexp.span (),
                    symbol.to_string (),
                    mexp_arg_to_arg (arg)?))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name symbol")
                    .line ("which must end with `-t`")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else if let Mexp::Sym {
            symbol,
            span,
        } = mexp {
            if prop_name_symbol_p (symbol) {
                Ok (Term::Prop (
                    span.clone (),
                    symbol.to_string (),
                    Arg::Rec (Vec::new ())))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name symbol")
                    .line ("which must end with `-t`")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_type_of_type_term

    #+begin_src rust
    fn mexp_to_type_of_type_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        if let Mexp::Sym {
            span,
            symbol,
        } = mexp {
            if type_of_type_symbol_p (symbol) {
                Ok (Term::TypeOfType (span.clone ()))
            } else {
                ErrorInCtx::new ()
                    .head ("syntex error")
                    .line ("expecting type-of-type symbol")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_term

    #+begin_src rust
    fn mexp_to_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        mexp_to_var_term (mexp)
            .or (mexp_to_cons_term (mexp))
            .or (mexp_to_prop_term (mexp))
            .or (mexp_to_field_ref_term (mexp))
            .or (mexp_to_type_of_type_term (mexp))
    }
    #+end_src

*** mexp_vec_to_term_vec

    #+begin_src rust
    fn mexp_vec_to_term_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <Term>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_term (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

*** mexp_to_field_name

    #+begin_src rust
    fn mexp_to_field_name <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <String, ErrorInCtx> {
        if let Mexp::Sym {
            symbol,
            ..
        } = mexp {
            if field_name_symbol_p (symbol) {
                Ok (symbol.to_string ())
            } else {
                ErrorInCtx::new ()
                    .line ("expecting field name symbol")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .line ("expecting prop name")
                .line (&format! ("mexp = {}", mexp.to_string ()))
                .span (mexp.span ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_binding

    #+begin_src rust
    fn mexp_to_binding <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Binding, ErrorInCtx> {
        if let Mexp::Infix {
            op,
            lhs, rhs,
            ..
        } = mexp {
            if op == &"=" {
                Ok (Binding::EqualTo (
                    mexp_to_field_name (lhs)?,
                    mexp_to_term (rhs)?))
            } else if op == &":" {
                Ok (Binding::Inhabit (
                    mexp_to_field_name (lhs)?,
                    mexp_to_term (rhs)?))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting binding infix op")
                    .line ("which might be `=` or `:`")
                    .line (&format! ("op = {}", op))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_vec_to_binding_vec

    #+begin_src rust
    fn mexp_vec_to_binding_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <Binding>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_binding (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

*** mexp_to_disj_den

    #+begin_src rust
    fn mexp_to_disj_den <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Den, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Apply {
                head: box Mexp::Sym {
                    symbol: "disj",
                    ..
                },
                arg: MexpArg::Tuple {
                    body: body1,
                    ..
                },
                ..
            },
            arg: MexpArg::Block {
                body: body2,
                ..
            },
            ..
        } = mexp {
            Ok (Den::Disj (
                mexp_vec_to_prop_name_vec (body1)?,
                mexp_vec_to_binding_vec (body2)?))
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_conj_den

    #+begin_src rust
    fn mexp_to_conj_den <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Den, ErrorInCtx> {
        if let Mexp::Apply {
                head: box Mexp::Sym {
                    symbol: "conj",
                    ..
                },
                arg: MexpArg::Block {
                    body,
                    ..
                },
                ..
            } = mexp {
            Ok (Den::Conj (
                mexp_vec_to_binding_vec (body)?))
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_den

    #+begin_src rust
    fn mexp_to_den <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Den, ErrorInCtx> {
        mexp_to_disj_den (mexp)
            .or (mexp_to_conj_den (mexp))
    }
    #+end_src

*** mexp_to_den_statement

    #+begin_src rust
    fn mexp_to_den_statement <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Statement, ErrorInCtx> {
        if let Mexp::Infix {
            op: "=",
            lhs: box Mexp::Sym {
                symbol,
                ..
            },
            rhs,
            ..
        } = mexp {
            if prop_name_symbol_p (symbol) {
                Ok (Statement::Den (
                    symbol.to_string (),
                    mexp_to_den (rhs)?))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name")
                    .line ("which must end with `-t`")
                    .line (&format! ("symbol = {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** [todo] mexp_to_statement

    #+begin_src rust
    fn mexp_to_statement <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Statement, ErrorInCtx> {
        mexp_to_den_statement (mexp)
            // .or (mexp_to_prop_statement (mexp))
            // .or (mexp_to_prove_statement (mexp))
    }
    #+end_src

*** mexp_vec_to_prop_name_vec

    #+begin_src rust
    fn mexp_vec_to_prop_name_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <String>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_prop_name (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

*** mexp_vec_to_statement_vec

    #+begin_src rust
    fn mexp_vec_to_statement_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <Statement>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_statement (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

* prelude

*** PRELUDE

    #+begin_src rust
    const PRELUDE: &'static str =
        include_str! ("prelude.cic");
    #+end_src

* test

*** test_unify

    #+begin_src rust
    #[test]
    fn test_unify () {
        let u = Value::Var (Var::new ("u"));
        let v = Value::Var (Var::new ("v"));
        let subst = Subst::new () .unify (
            &Value::Data (Data {
                name: "cons-c" .to_string (),
                body: vec! [
                    ("car", u.clone ()),
                    ("cdr", v.clone ()),
                ] .into ()
            }),
            &Value::Data (Data {
                name: "cons-c" .to_string (),
                body: vec! [
                    ("car", v.clone ()),
                    ("cdr", Value::Data (Data {
                        name: "unit-c" .to_string (),
                        body: Dic::new (),
                    })),
                ] .into ()
            }))
            .unwrap ();
        println! ("{}", subst.to_string ());
        assert_eq! (subst.len (), 2);
    }
    #+end_src

*** test_wis

    #+begin_src rust
    #[test]
    fn test_wis () {
        let mut wissen = Wissen::new ();
        let input = PRELUDE;
        let ctx = ErrorCtx::new () .body (input);
        match wissen.wis (input) {
            Ok (mut output_vec) => {
                println! ("{}", wissen.to_string ());
            }
            Err (error) => {
                error.report (ctx.clone ());
            }
        }
        for name in wissen.den_dic.keys () {
            match wissen.get_prop (name) {
                Ok ((prop, subst)) => {
                    println! (
                        "<prop>\n{}\n</prop>",
                        prop.to_string ());
                    println! ("{}", subst.to_string ());
                }
                Err (error) => {
                    println! ("- fail on name = {}", name);
                    error.report (ctx.clone ());
                }
            }
        }
    }
    #+end_src
