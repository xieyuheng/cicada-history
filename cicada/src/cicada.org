#+property: tangle lib.rs
#+title: cicada
- Term::to_value -- with error_report
- Wissen::den
- Wissen::to_string -- to be used in test
- Wissen::check
* [note]

*** Cons & Prop

    - Cons -- data-constructor
    - Prop -- type-constructor

    - Den::Disj is definition of Prop
    - Den::Conj is definition of Prop and Cons

*** Value

    - Cons::to_value will give a Value
      part of the Value is pre-defined which is specified by
      the definition of the Cons -- the definition of its Den::Conj

    - during Cons::to_value
      its pre-defined is unified with its args

    - this is like runtime assertion in prolog

*** type-check

    - type-check is simply to check that
      the equation in `data` has a solution

    - `disj` -- exporting equations
      `heir` -- importing equations

*** recursion

    - define all Den first and then check them

*** logic-var

    - single char words are not allowed in global definition
      and are not allowed as field-name

    - single char words are viewed as logic-var

    - long logic-var start with `:`

*** proving

    - Prop is to be proved

    - to prove a Prop defined by Den::Disj
      is to dispatch it

    - to prove a Prop defined by Den::Conj
      we unify args withs fields
      and we also need to prove remaining Prop in Value

    - `heir` is just like `data`

*** Grammar

    Den::Disj = { "disj" '(' list (prop-name?) ')' Arg::Record }
    Den::Conj = { "conj" Arg::Record }
    Term::Var = { var-name? }
    Term::Cons = { cons-name? Arg }
    Term::Prop = { prop-name? Arg }
    Arg::Tuple = { '(' list (Term) ')' }
    Arg::Record = { '{' list (Binding) '}' }
    Binding::Term = { field-name? "=" Term }

* prolog

*** feature

    #+begin_src rust
    #![feature (uniform_paths)]
    #![feature (bind_by_move_pattern_guards)]
    #![feature (box_patterns)]
    #![feature (box_syntax)]

    #![allow (dead_code)]
    #+end_src

*** use

    #+begin_src rust
    use std::fmt;
    use std::sync::Arc;
    use std::collections::VecDeque;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use uuid::Uuid;
    use dic::Dic;
    use error_report::{
        Span,
        ErrorMsg,
        ErrorInCtx,
    };
    #[cfg (test)]
    use error_report::{
        ErrorCtx,
    };
    use mexp::{
        SyntaxTable,
        Mexp,
        MexpArg,
    };
    #+end_src

* utility

*** vec_to_string

    #+begin_src rust
    fn vec_to_string <T> (vec: &Vec <T>, delimiter: &str) -> String
    where T : ToString {
        let mut s = String::new ();
        for x in vec {
            s += &x.to_string ();
            s += delimiter;
        }
        for _ in 0 .. delimiter.len () {
            s.pop ();
        }
        s
    }
    #+end_src

*** vec_to_lines

    #+begin_src rust
    fn vec_to_lines <T> (vec: &Vec <T>) -> String
    where T : ToString {
        let mut s = vec_to_string (vec, "\n");
        if ! s.is_empty () {
            s += "\n";
        }
        s
    }
    #+end_src

*** dic_to_string

    #+begin_src rust
    fn dic_to_string <T> (dic: &Dic <T>) -> String
    where T : ToString {
        let mut s = String::new ();
        for (k, v) in dic.iter () {
            s += &k.to_string ();
            s += " = ";
            s += &v.to_string ();
            s += ", ";
        }
        for _ in 0 .. ", ".len () {
            s.pop ();
        }
        s
    }
    #+end_src

*** add_tag

    #+begin_src rust
    fn add_tag (tag: &str, input: String) -> String {
        let start = tag;
        let end = &tag[1 .. tag.len () - 1];
        let end = format! ("</{}>", end);
        if input.is_empty () {
            format! ("{}{}", start, end)
        } else {
            format! ("{}\n{}{}\n", start, input, end)
        }
    }
    #+end_src

* Term

*** Term

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Term {
        Var (Span, Var),
        Cons (Span, String, Arg),
        Prop (Span, String, Arg),
        TypeOfType,
    }
    #+end_src

*** Arg

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Arg {
        Vec (Vec <Term>),
        Dic (Dic <Term>),
    }
    #+end_src

* Var

*** Var

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub struct Var {
        name: String,
        id: Option <Id>,
    }
    #+end_src

*** Var::new

    #+begin_src rust
    impl Var {
        fn new (s: &str) -> Self {
            Var {
                name: s.to_string (),
                id: Some (Id::uuid ()),
            }
        }
    }
    #+end_src

*** Var::no_id

    #+begin_src rust
    impl Var {
        fn no_id (s: &str) -> Self {
            Var {
                name: s.to_string (),
                id: None,
            }
        }
    }
    #+end_src

*** Var::var_local

    #+begin_src rust
    impl Var {
        fn local (s: &str, counter: usize) -> Self {
            Var {
                name: s.to_string (),
                id: Some (Id::local (counter)),
            }
        }
    }
    #+end_src

*** Var::to_string

    #+begin_src rust
    impl ToString for Var {
        fn to_string (&self) -> String {
            let mut s = format! ("{}", self.name);
            if let Some (id) = &self.id {
                s += &format! ("#{}", id.to_string ());
            }
            s
        }
    }
    #+end_src

*** Id

    #+begin_src rust
    #[derive (Clone)]
    #[derive (PartialEq, Eq, Hash)]
    pub enum Id {
        Uuid (uuid::adapter::Hyphenated),
        Local (usize),
    }
    #+end_src

*** Id::uuid

    #+begin_src rust
    impl Id {
        fn uuid () -> Self {
            Id::Uuid (Uuid::new_v4 () .to_hyphenated ())
        }
    }
    #+end_src

*** Id::local

    #+begin_src rust
    impl Id {
        fn local (counter: usize) -> Self {
            Id::Local (counter)
        }
    }
    #+end_src

*** Id::fmt

    #+begin_src rust
    impl fmt::Debug for Id {
        fn fmt (&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Id::Uuid (uuid) => write! (f, "{}", uuid),
                Id::Local (counter) => write! (f, "{}", counter),
            }
        }
    }
    #+end_src

*** Id::to_string

    #+begin_src rust
    impl ToString for Id {
        fn to_string (&self) -> String {
            match self {
                Id::Uuid (uuid) => format! ("{}", uuid),
                Id::Local (counter) => format! ("{}", counter),
            }
        }
    }
    #+end_src

* Value

*** Value

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Value {
        Var (Var),
        Data (String, Dic <Value>),
        TypeOfType,
    }
    #+end_src

*** Value::to_string

    #+begin_src rust
    impl ToString for Value {
        fn to_string (&self) -> String {
            match self {
                Value::Var (var) => var.to_string (),
                Value::Data (name, dic) => {
                    if dic.len () == 0 {
                        format! ("{}", name)
                    } else {
                        format! (
                            "{} {{ {} }}",
                            name,
                            &dic_to_string (dic))
                    }
                }
                Value::TypeOfType => "type".to_string (),
            }
        }
    }
    #+end_src

* Subst

*** Subst

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Subst {
        Null,
        Cons (Var, Value, Arc <Subst>),
    }
    #+end_src

*** Subst::new

    #+begin_src rust
    impl Subst {
        fn new () -> Self {
            Subst::Null
        }
    }
    #+end_src

*** Subst::extend

    #+begin_src rust
    impl Subst {
        fn extend (&self, var: Var, value: Value) -> Self {
            Subst::Cons (var, value, Arc::new (self.clone ()))
        }
    }
    #+end_src

*** Subst::find

    #+begin_src rust
    impl Subst {
        pub fn find (&self, var: &Var) -> Option <&Value> {
            match self {
                Subst::Null => None,
                Subst::Cons (
                    var1, value, next,
                ) => {
                    if var1 == var {
                        Some (value)
                    } else {
                        next.find (var)
                    }
                }
            }
        }
    }
    #+end_src

*** Subst::walk

    #+begin_src rust
    impl Subst {
        pub fn walk (&self, value: &Value) -> Value {
            match value {
                Value::Var (var) => {
                    if let Some (new_value) = self.find (var) {
                        self.walk (new_value)
                    } else {
                        value.clone ()
                    }
                }
                _ => value.clone ()
            }
        }
    }
    #+end_src

*** Subst::unify

    #+begin_src rust
    impl Subst {
        pub fn unify (
            &self,
            u: &Value,
            v: &Value,
        ) -> Option <Subst> {
            let u = self.walk (u);
            let v = self.walk (v);
            match (u, v) {
                (Value::Var (u),
                 Value::Var (v),
                ) if u == v => {
                    Some (self.clone ())
                }
                (Value::Var (u), v) => {
                    if self.var_occur_p (&u, &v) {
                        None
                    } else {
                        Some (self.extend (u, v))
                    }
                }
                (u, Value::Var (v)) => {
                    if self.var_occur_p (&v, &u) {
                        None
                    } else {
                        Some (self.extend (v, u))
                    }
                }
                (Value::Data (u_name, u_dic),
                 Value::Data (v_name, v_dic),
                ) => {
                    if u_name != v_name {
                        return None;
                    }
                    if u_dic.len () != v_dic.len () {
                        return None;
                    }
                    let mut subst = self.clone ();
                    let zip = u_dic.entries () .zip (v_dic.entries ());
                    for (u_entry, v_entry) in zip {
                        if u_entry.name != v_entry.name {
                            eprintln! ("- [warning] Subst::unify");
                            eprintln! ("  dic mismatch");
                            eprintln! ("  u_name = {}", u_name);
                            eprintln! ("  v_name = {}", v_name);
                            eprintln! ("  u_entry.name = {}", u_entry.name);
                            eprintln! ("  v_entry.name = {}", v_entry.name);
                            return None;
                        } else {
                            if let (
                                Some (u_value),
                                Some (v_value),
                            ) = (&u_entry.value, &v_entry.value) {
                                subst = subst.unify (
                                    u_value,
                                    v_value)?;
                            } else {
                                return None
                            }
                        }
                    }
                    Some (subst)
                }
                (u, v) => {
                    if u == v {
                        Some (self.clone ())
                    } else {
                        None
                    }
                }
            }
        }
    }
    #+end_src

*** Subst::var_occur_p

    #+begin_src rust
    impl Subst {
        pub fn var_occur_p (
            &self,
            var: &Var,
            value: &Value,
        ) -> bool {
            let value = self.walk (value);
            match value {
                Value::Var (var1) => {
                    var == &var1
                }
                Value::Data (_name, dic) => {
                    for value in dic.values () {
                        if self.var_occur_p (var, value) {
                            return true;
                        }
                    }
                    return false;
                }
                _ => {
                    false
                }
            }
        }
    }
    #+end_src

*** Subst::len

    #+begin_src rust
    impl Subst {
        pub fn len (&self) -> usize {
            let mut len = 0;
            let mut subst = self;
            while let Subst::Cons (
                _var, _value, next
            ) = subst {
                len += 1;
                subst = &next;
            }
            len
        }
    }
    #+end_src

*** Subst::to_string

    #+begin_src rust
    impl ToString for Subst {
        fn to_string (&self) -> String {
            let mut s = String::new ();
            let mut subst = self.clone ();
            while let Subst::Cons (
                var, value, next,
            ) = subst {
                s += &var.to_string ();
                s += " = ";
                s += &value.to_string ();
                s += "\n";
                subst = (*next) .clone ();
            }
            add_tag ("<subst>", s)
        }
    }
    #+end_src

* Den

*** Den

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Den {
        Disj (Vec <String>, Dic <Term>),
        Conj (Dic <Term>),
    }
    #+end_src

* Wissen

* Statement

* Proving

* Proof

* Qed

* syntax

* test

*** test_unify

    #+begin_src rust
    #[test]
    fn test_unify () {
        let u = Value::Var (Var::new ("u"));
        let v = Value::Var (Var::new ("v"));
        let subst = Subst::new () .unify (
            &Value::Data ("cons-c" .to_string (), vec! [
                ("car", u.clone ()),
                ("cdr", v.clone ()),
            ] .into ()),
            &Value::Data ("cons-c" .to_string (), vec! [
                ("car", v.clone ()),
                ("cdr", Value::Data ("unit-c" .to_string (),
                                     Dic::new ())),
            ] .into ())) .unwrap ();
        println! ("{}", subst.to_string ());
        assert_eq! (subst.len (), 2);
    }
    #+end_src
