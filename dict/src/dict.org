#+property: tangle lib.rs
#+title: dict

* prolog

*** feature

    #+begin_src rust
    #![allow (unused_parens)]
    #+end_src

*** use

    #+begin_src rust
    use std::sync::Arc;
    #+end_src

* Dict

  #+begin_src rust
  #[derive (Clone)]
  #[derive (Debug)]
  #[derive (PartialEq)]
  pub enum Dict <T> {
      Null,
      Cons {
          name: String,
          entry: T,
          next: Arc <Dict <T>>,
      }
  }
  #+end_src

* Dict::new

  #+begin_src rust
  impl <T> Dict <T> {
      pub fn new () -> Self {
          Dict::Null
      }
  }
  #+end_src

* Dict::extend

  #+begin_src rust
  impl <T> Dict <T>
  where T : Clone {
      pub fn extend (&self, name: &str, entry: T) -> Self {
          Dict::Cons {
              name: name.to_string (),
              entry,
              next: Arc::new (self.clone ()),
          }
      }
  }
  #+end_src

* Dict::unit

  #+begin_src rust
  impl <T> Dict <T> {
      pub fn unit (name: &str, entry: T) -> Self {
          Dict::Cons {
              name: name.to_string (),
              entry,
              next: Arc::new (Dict::new ()),
          }
      }
  }
  #+end_src

* Dict::find

  #+begin_src rust
  impl <T> Dict <T> {
      pub fn find (&self, name: &str) -> Option <&T> {
          match self {
              Dict::Null => None,
              Dict::Cons {
                  name: head_name,
                  entry: head_entry,
                  next,
              } => {
                  if head_name == name {
                      Some (head_entry)
                  } else {
                      next.find (name)
                  }
              }
          }
      }
  }
  #+end_src

* Dict::insert

  #+begin_src rust
  impl <T> Dict <T>
  where T : Clone {
      pub fn insert (&self, name: &str, entry: T) -> Self {
          match self {
              Dict::Null => {
                  Dict::unit (name, entry)
              }
              Dict::Cons {
                  name: head_name,
                  entry: head_entry,
                  next,
              } => {
                  if head_name == name {
                      next.extend (head_name, entry)
                  } else {
                      let rest = next.insert (name, entry);
                      rest.extend (head_name, head_entry.clone ())
                  }
              }
          }
      }
  }
  #+end_src
