#+title: prelude

* [todo-stack]

*** notes about (:) (%) (<) (>)

*** no implicit :local

*** zip example

*** syntax for inheritance

*** use number theory -- to test type-checker as prover

*** trans idris-category to cicada

*** use cicada to write opless notes

    - we need a syntax for (do)

*** ML like module system -- [in org-mode ?]

*** about first-classness

    - x -
      if we implement category as type-class [or interface]
      to implement product of category
      we need to be able to treat type-class as first-class
      because a product take two categories and return a new category

    - k -
      how about functor ?

    - x -
      while functor is different
      it is not a category constructor
      but a structure preserving map between existing categories

*** functor type-class in haskell

    - in haskell the category under consideration
      is tye category of types
      where types are objects
      functions are morphisms

    - the functor type-class in haskell
      is a endo-functor from this category to itself

      thus a functor instance in haskell
      is a type constructor of type (-> type -- type)

      thus the functor type-class in haskell
      is limited in the sense of functor
      because type constructor in haskell
      is limited in the sense of function of type (-> type -- type)

    - endo functors are containers

*** type name postfix

    - give up detailed type name postfix
      because for structured function type and product type
      type name postfix is not enough

    - type name postfix
      is only used to distinguish level of types

*** stack as a category constructor

    - stack as product built-in the language
      - take swap as an example  (a, b) => (b, a)
      - also the assoc law (a, (b, c)) => ((a,  b), c)

    - maybe we still need to define stack as a category constructor

*** subtype relation as order relation for algebraic data type

    - for example :
      a < a + b
      a < a * 2

*** universe

    - type-tt = 1 universe
      type-tt : 2 universe
      type-tt : 2 universe

    - nat-t : 1 universe
      (* nat-t nat-t) : 1 universe
      (+ nat-t | nat-t) : 1 universe
      (-> nat-t -- nat-t) : 1 universe

    - 1 universe : 2 universe

    - how about the order relation for those universes ?

* [note]

*** (+type)

    - type of data in data-field must be of type type-tt
      thus, function can not be stored in data-field

*** naming convention

    - type

      | -t  | type constructor          |
      |     | union-type constructor    |
      |     | quotient-type constructor |
      | -ct | class-type                |
      | -tt | type of type              |

    - function

      | -p  | predicate        |
      | -c  | data constructor |
      | -cr | create           |

*** level of types

    | 0 | object                          |
    | 1 | type, union-type, quotient-type |
    | 2 | type-class, type-tt             |

*** object as type

    - object are just like type
      just without sumtype
      only product type

*** syntax for unnamed record type

*** subtype relation between classes

    - c1 < c2
      if c1 is more special then c2
      if c1 has more interface functions than c2

*** overload add to different types

    - we can also define something like
      (+class add-ct < (-> type-tt type-tt -- type-tt))
      to add number to array

*** unification

***** what to unify ?

      - in cicada
        <term> := <type-term>, <union-term>, <data-term>
        --- (data <hypo>), (type <hypo>)
        --- <trunk>
        <type-term>  := (<type-constructor> <term> ...)
        <union-term> := (<union-constructor> <term> ...)
        <data-term>  := (<data-constructor> <term> ...)
        <trunk> := function application to be reduced

        data-bind-dict -- <hypo> to data <term>
        type-bind-dict -- <hypo> to type <term>

        <trunk> will be formed,
        when among arguments of a function application
        there is a <hypo> that is not bound to data
        or there is a non-reduce-able <trunk>

      - in logic
        <term> := <predicate-term>, <var>, <constant>
        <predicate-term> := (<predicate-symbol> <term> ...)

***** feature structures

      - <var> with two fields type and data,
        can be viewed as feature structures
        in unification theory

*** vector vs list

    - vector and list have the same data-constructor shape

    - it is *not* true that
      every function can be defined for vector
      can also be defined for list

      - for example zip can be defined for vector of same length

      - when defining zip for vector
        more informations in type
        can help to rule out some not meaningful cases

      list -> list
      vector -> vector
      can *not* be composed to
      list -> vector

    - it is true that
      every function can be defined for list
      can also be defined for vector

      - by dropping the length information

      vector -> vector
      list -> list
      can be composed
      vector -> list

    - vector can be viewed as subtype of list
      we can assert so
      and use this subtype relation to reuse functions

      - in some case [when namings are so different]
        we also need to assert relation between
        fields of type and data-constructors

* bool

*** bool-t

    #+begin_src cicada
    (+union bool-t : type-tt
      (-> -- true-t)
      (-> -- false-t))
    #+end_src

* nat

*** nat-t

    #+begin_src cicada
    (+union nat-t : type-tt
      (-> -- zero-t)
      (-> prev : nat-t -- succ-t))
    #+end_src

*** nat-add

    #+begin_src cicada
    (+fun nat-add : (-> [m n] : nat-t -- nat-t)
      (case n
        (zero-t m)
        (succ-t m n.prev recur succ-c)))
    #+end_src

*** nat-mul

    #+begin_src cicada
    (+fun nat-mul : (-> [m n] : nat-t -- nat-t)
      (case n
        (zero-t n)
        (succ-t m n.prev recur m nat-add)))
    #+end_src

*** nat-factorial

    #+begin_src cicada
    (+fun nat-factorial : (-> n : nat-t -- nat-t)
      (case n
        (zero-t n succ-c)
        (succ-t n.prev recur n nat-mul)))
    #+end_src

* list

*** list-t

    #+begin_src cicada
    (+union list-t : (-> type : type-tt -- type-tt)
      (-> -- type null-t)
      (-> car : type
          cdr : type list-t
       -- type cons-t))
    #+end_src

*** list-length

    #+begin_src cicada
    (+fun list-length
      : (-> list : type list-t
         -- nat-t)
      (case list
        (null-t zero-c)
        (cons-t list.cdr recur succ-c)))
    #+end_src

*** list-append

    #+begin_src cicada
    (+fun list-append
      : (-> list : type list-t
            list2 : type list-t
         -- type list-t)
      (case list2
        (null-t list)
        (cons-t list2.car list list2.cdr recur cons-c)))
    #+end_src

*** list-map

    #+begin_src cicada
    (+fun list-map
      : (-> list : type list-t
            fun : (-> type -- type2)
         -- type2 list-t)
      (case list
        (null-t list)
        (cons-t list.car fun list.cdr {fun} recur cons-c)))
    #+end_src

*** list-ref -- will not pass type check

    #+begin_src cicada
    ;; this function will not pass type check
    ;;   because we can not use car cdr on list-t
    ;;   we can only use them on cons-t
    #note
    (+fun list-ref
      : (-> list : type list-t
            index : nat-t
         -- type)
      (case index
        (zero-t list.car)
        (succ-t list.cdr index.prev recur)))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    (+fun list-remove-first
      : (-> x : type
            list : type list-t
         -- type list-t)
      (case list
        (null-t list)
        (cons-t (case [list.car x eq-p]
                   (true-t  list.cdr)
                   (false-t list.car list.cdr x recur cons-c)))))
    #+end_src

* eqv

*** eqv-t

    #+begin_src cicada
    (+type eqv-t
      : (-> type :: type-tt
            [lhs rhs] : type
         -- type-tt)
      (-> value :: type
       -- value value eqv-t))
    #+end_src

*** eqv-apply

    #+begin_src cicada
    (+proof eqv-apply
      : (-> [type type2] :: type-tt
            [x y] :: type
            x y eqv-t
            fun : (-> type -- type2)
         -- x fun y fun eqv-t)
      eqv-c)
    #+end_src

*** eqv-swap

    #+begin_src cicada
    (+proof eqv-swap
      : (-> type :: type-tt
            [x y] :: type
            x y eqv-t
         -- y x eqv-t)
      eqv-c)
    #+end_src

*** eqv-compose

    #+begin_src cicada
    (+proof eqv-compose
      : (-> type :: type-tt
            [x y z] :: type
            x y eqv-t
            y z eqv-t
         -- x z eqv-t)
      eqv-c)
    #+end_src

* nat

*** nat-is-even-t -- re-imp predicate as judgment

    - nat-is-even-p : (-> nat-t -- bool-t)
    - nat-is-even-t : (-> nat-t -- type-tt)

    #+begin_src cicada
    (+union nat-is-even-t : (-> n : nat-t -- type-tt)
      (-> -- zero-c zero-is-even-t)
      (-> m :: nat-t
          prev : m nat-is-even-t
       -- m succ-c succ-c even-plus-two-is-even-t))

    (+proof two-is-even
      : (-> -- zero-c succ-c succ-c nat-is-even-t)
      zero-is-even-c
      even-plus-two-is-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    (+proof nat-add-associative
      : (-> [x y z] : nat-t
         -- x y nat-add z nat-add
            x y z nat-add nat-add eqv-t)
      (case z
        (zero-t eqv-c)
        (succ-t x y z.prev recur {succ-c} eqv-apply)))
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    (+proof nat-add-commutative
      : (-> [m n] : nat-t
         -- m n nat-add
            n m nat-add eqv-t)
      (case n
        (zero-t m nat-add-zero-commutative)
        (succ-t m n.prev recur {succ-c} eqv-apply
                n.prev m nat-add-succ-commutative eqv-compose)))

    (+proof nat-add-zero-commutative
      : (-> m : nat-t
         -- m zero-c nat-add
            zero-c m nat-add eqv-t)
      (case m
        (zero-t eqv-c)
        (succ-t m.prev recur {succ-c} eqv-apply)))

    (+proof nat-add-succ-commutative
      : (-> [m n] : nat-t
         -- m succ-c n nat-add
            m n nat-add succ-c eqv-t)
      (case n
        (zero-t eqv-c)
        (succ-t m n.prev recur {succ-c} eqv-apply)))
    #+end_src

* list

*** list-length-t -- re-imp function as relation

    #+begin_src cicada
    (note
      list-length
      : (-> type :: type-tt
            list : type list-t
         -- length : nat-t)

      list-length-t
      : (-> type :: type-tt
            list : type list-t
            length : nat-t
         -- type-tt))

    (+union list-length-t
      : (-> type :: type-tt
            list : type list-t
            length : nat-t
         -- type-tt)
      (-> -- null-c zero-c null-length-t)
      (-> cdr : list length list-length-t
       -- element :: type
          element list cons-c
          length succ-c cons-length-t))

    ;; the name of the argument of cons-length-c
    ;;   should not be cdr ?

    ;; how should we use -o ?
    ;;   should it be different from -t ?
    ;;   not that there are also -t, -q, ... ?

    ;; maybe we should use unified -t for all of them !

    ;; what is the logic programming interface of the type system ?
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    (+fun list-map-preserve-list-length
      : (-> type :: type-tt
            fun :: (-> type -- type2)
            list :: type list-t
            n :: nat-t
            list-length-proof : list n list-length-t
         -- list {fun} map n list-length-t)
      (case list-length-proof
        (null-length-t list-length-proof)
        (cons-length-t list-length-proof.cdr recur cons-length-c)))
    #+end_src

*** list-append-t

    #+begin_src cicada
    ;; append([], SUCC, SUCC).
    ;; append([CAR|CDR], SUCC, [CAR|RESULT_CDR]):-
    ;;   append(CDR, SUCC, RESULT_CDR).

    (+union list-append-t
      : (-> type :: type-tt
            ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      (-> -- null-c succ succ zero-append-t)
      (-> car :: type
          cdr :: type list-t
          result-cdr :: type list-t
          prev : cdr succ result-cdr list-append-t
       -- car cdr cons-c, succ, car result-cdr cons-c succ-append-t))

    (+union list-append-t
      : (-> type :: type-tt
            ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      zero-append-t
      succ-append-t)

    (+type zero-append-t
      : (-> type :: type-tt
            ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      (-> -- null-c succ succ zero-append-t))

    (+type succ-append-t
      : (-> type :: type-tt
            ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      (-> car :: type
          cdr :: type list-t
          result-cdr :: type list-t
          prev : cdr succ result-cdr list-append-t
       -- car cdr cons-c, succ, car result-cdr cons-c succ-append-t))
    #+end_src

*** ><

    #+begin_src cicada
    (+type succ-append-t
      : (-> type :: type-tt
            ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      (-> car :: type
          cdr :: type list-t
          result-cdr :: type list-t
          prev : cdr succ result-cdr list-append-t
       -- car cdr cons-c, succ, car result-cdr cons-c succ-append-t))

    (note for [ante succ result succ-append-c]
      0 hypo-id-c data-hypo-c (quote type) local-let
      (quote type) local-get to-type
      type-tt
      unify
      ><><><
      (@data-type-t
        (name "succ-append-t")
        (field-obj-dict
         (@ (type (quote type) local-get)
            (ante (quote ante) local-get)
            (succ (quote succ) local-get)
            (result (quote result) local-get))))
      (let data-type)
      (@data-obj-t
        (data-type data-type)
        (field-obj-dict
         (@ (prev (quote prev) local-get)))))
    #+end_src

* vect

*** vect-t

    #+begin_src cicada
    (+union vect-t
      : (-> length : nat-t
            type : type-tt
         -- type-tt)
      (-> -- zero-c type null-vect-t)
      (-> car : type
          cdr : length type vect-t
       -- length succ-c type cons-vect-t))
    #+end_src

*** vect-append

    #+begin_src cicada
    (+fun vect-append
      : (-> [m n] :: nat-t
            type :: type-tt
            list : m type vect-t
            list2 : n type vect-t
         -- m n nat-add type vect-t)
      (case list2
        (null-vect-t list)
        (cons-vect-t list2.car list list2.cdr recur cons-vect-c)))
    #+end_src

*** vect-map

    #+begin_src cicada
    (+fun vect-map
      : (-> n :: nat-t
            [type type2] :: type-tt
            list : n type vect-t
            fun : (-> type -- type2)
         -- n type2 vect-t)
      (case list
        (null-vect-t list)
        (cons-vect-t list.car fun list.cdr {fun} recur cons-vect-c)))
    #+end_src

* >< type-check details

*** add-zero-commutative

    #+begin_src cicada
    (match m succ-c)
    (= m m.prev succ-c)

    (type-computed

     [m.prev]
     [recur {succ-c} eq-apply]

     [m.prev zero-c add
      zero-c m.prev add eq-t]
     [{succ-c} eq-apply]

     [m.prev zero-c add succ-c
      zero-c m.prev add succ-c eq-t]

     [m.prev add succ-c
      zero-c m.prev add succ-c eq-t])

    (type-asserted

     [m zero-c add
      zero-c m add eq-t]

     [m.prev succ-c zero-c add
      zero-c m.prev succ-c add eq-t]

     [m.prev succ-c add
      zero-c m.prev succ-c add eq-t]

     [m.prev add succ-c
      zero-c m.prev succ-c add eq-t]

     [m.prev add succ-c
      zero-c m.prev add succ-c eq-t])
    #+end_src

*** add-commutative

    #+begin_src cicada
    (match n succ-c)
    (= n n.prev succ-c)

    (type-computed

     [m n.prev]
     [recur {succ-c} eq-apply
      n.prev m add-succ-commutative eq-swap eq-compose]

     [m n.prev add
      n.prev m add eq-t]
     [{succ} eq-apply
      n.prev m add-succ-commutative eq-swap eq-compose]

     [m n.prev add succ-c
      n.prev m add succ-c eq-t]
     [n.prev m add-succ-commutative eq-swap eq-compose]

     [m n.prev add succ-c
      n.prev m add succ-c eq-t
      n.prev succ-c m add
      n.prev m add succ-c eq-t]
     [eq-swap eq-compose]

     [m n.prev add succ-c
      n.prev m add succ-c eq-t
      n.prev m add succ-c
      n.prev succ-c m add eq-t]
     [eq-compose]

     [m n.prev add succ-c
      n.prev succ-c m add eq-t])

    (type-asserted

     [m n add
      n m add eq-t]

     [m n.prev succ-c add
      n.prev succ-c m add eq-t]

     [m n.prev add succ-c
      n.prev succ-c m add eq-t])
    #+end_src

*** map-has-length

    #+begin_src cicada
    (: has-length l n has-length-t)

    (match has-length cons-has-length)
      (= has-length has-length.cdr cons-has-length)
        (: has-length.cdr [l#0 n#0 has-length-t])
      (: has-length [a#0 l#0 cons n#0 succ-c has-length-t])
        (= l a#0 l#0 cons)
        (= n n#0 succ)

    (type-computed

     [has-length.cdr recur cons-has-length]

     [l#0 n#0 has-length-t]
     [recur cons-has-length]

     [l#0 fun#0 map n#0 has-length-t]
     [cons-has-length]

     [a#1 l#0 fun#0 map cons n#0 succ-c has-length-t])

    (type-asserted

     [l fun map n has-length-t]

     [a#0 l#0 cons fun map n#0 succ-c has-length-t]

     [a#0 @fun l#0 fun map cons n#0 succ-c has-length-t])
    #+end_src

*** vect-append

    #+begin_src cicada
    (: :l0 [:m :t vect-t])
    (: :l1 [:n :t vect-t])

    (match :l1 cons)
      (= :l1 :l1.car :l1.cdr cons)
        (: :l1.cdr [:n#0 :t#0 vect-t])
        (: :l1.car :t#0)
      (: :l1 [:n#0 succ :t#0 vect-t])
        (= :n :n#0 succ)
        (= :t :t#0)

    (type-computed:

     [:l1.car :l0 :l1.cdr recur cons]

     [:m :t vect-t :n :t vect-t]
     ><><>< the order of cons
     [recur :l1.car cons]

     [:m :t vect-t :n#0 :t#0 vect-t]
     [recur :l1.car cons]

     [:m :n#0 add :t#0 vect-t]
     [:l1.car cons]

     [:m :n#0 add :t#0 vect-t :t#0]
     [cons]

     [:m :n#0 add succ :t#0 vect-t])

    (type-asserted:

     [:m :n add :t vect-t]

     [:m :n#0 succ add :t#0 vect-t]

     [:m :n#0 add succ :t#0 vect-t])
    #+end_src

*** vect-map

    #+begin_src cicada
    (: :l [:n :t1 vect-t])
    (: :f (-> :t1 :t2))

    (match :l cons)
      (= :l :l.car :l.cdr cons)
        (: :l.cdr [:n#0 :t#0 vect-t])
        (: :l.car :t#0)
      (: :l [:n#0 succ :t#0 vect-t])
        (= :n :n#0 succ)
        (= :t1 :t#0)

    (type-computed:

     ><><>< the order of cons
     [:l.cdr :f recur :l.car :f apply cons]

     [:n#0 :t#0 vect-t (-> :t1 :t2)]
     [recur :l.car :f apply cons]

     [:n#0 :t2 vect-t]
     [:l.car :f apply cons]

     [:n#0 :t2 vect-t :t#0]
     [:f apply cons]

     [:n#0 :t2 vect-t :t2]
     [cons]

     [:n#0 succ :t2 vect-t])

    (type-asserted:

     [:n :t2 vect-t]

     [:n#0 succ :t2 vect-t])
    #+end_src

* category

*** category-ct

    - -ct is always a subtype of record type

    - in (+type)
      we define named record type
      we also need syntax for unnamed record type

    #+begin_src cicada
    (+class category-ct
      < (@ object-t : type-tt
           arrow-t : (-> object-t object-t -- type-tt)
           arrow-eq-t : (-> a b arrow-t a b arrow-t -- type-tt))
      (+sig identity
        : (-> object-t % a
           -- a a arrow-t))
      (+sig compose
        : (-> a b arrow-t
              b c arrow-t
           -- a c arrow-t))
      (+sig identity-left
        : (-> a b arrow-t % f
           -- a identity f compose, f arrow-eq-t))
      (+sig identity-right
        : (-> a b arrow-t % f
           -- f b identity compose, f arrow-eq-t))
      (+sig compose-associative
        : (-> a b arrow-t % f
              b c arrow-t % g
              c d arrow-t % h
           -- f g h compose compose
              f g compose h compose arrow-eq-t)))
    #+end_src

*** category-ct % (* nat-t nat-order-t)

    #+begin_src cicada
    (+imp category-ct
      % (@ object-t = nat-t
           arrow-t = nat-order-t
           arrow-eq-t = ><><><)
      (+fun identity
        : )
      (+fun compose
        : ))
    #+end_src

* functor-ct

  #+begin_src cicada
  (+class functor-ct < (-> type-tt -- type-tt)
    (+sig map
      : (-> functor-t :: functor-ct
            t1 :: type-tt
            t2 :: type-tt
            t1 functor-t, (-> t1 -- t2), -- t2 functor-t)))
  #+end_src

* list-t : functor-ct

  #+begin_src cicada
  (+imp list-t : functor-ct
    (+fun map
      : (-> t1 :: type-tt
            t2 :: type-tt
            l : t1 list-t
            fun : (-> t1 -- t2)
         -- t2 list-t)
      (case l
        (null-t null-c)
        (cons-t l.car fun l.cdr {fun} recur cons-c))))
  #+end_src

* monad-ct

  #+begin_src cicada
  (+class monad-ct < (-> type-tt -- type-tt)
    (+sig return
      : (-> monad-t :: monad-ct
            t :: type-tt
            t -- t monad-t))
    (+sig bind
      : (-> monad-t :: monad-ct
            t1 :: type-tt
            t2 :: type-tt
            t1 monad-t, (-> t1 -- t2 monad-t) -- t2 monad-t)))
  #+end_src

* maybe

*** maybe-t

    #+begin_src cicada
    (+union maybe-t : (-> type : type-tt -- type-tt)
      (-> -- type none-t)
      (-> value : type -- type just-t))
    #+end_src

*** maybe-t : monad-ct

    #+begin_src cicada
    (+imp maybe-t : monad-ct
      (+fun return : (-> value : :t -- :t maybe-t)
        value just-c)
      (+fun bind
        : (-> maybe : :t1 maybe-t
              fun : (-> :t1 -- :t2 maybe-t)
           -- :t2 maybe-t)
        (case maybe
          (none-t none-c)
          (just-t :m.value fun))))
    #+end_src

* state

*** state-t

    #+begin_src cicada
    (+type state-t : (-> type-tt type-tt -- type-tt)
      (-> fun : (-> :s-t -- :s-t :v-t)
       -- :s-t :v-t state-t))
    #+end_src

*** {:v-t state-t} : monad-ct

    #+begin_src cicada
    (+imp {:v-t state-t} : monad-ct
      (+fun return : (-> value : :v-t -- :s-t :v-t state-t)
        {value} state-c)
      (+fun bind
        : (-> state : :s-t :v1-t state-t
              fun : (-> :v1-t -- :s-t :v2-t state-t)
           -- :s-t :v2-t state-t)
        {state.fun fun .fun apply} state-c))
    #+end_src

* tree

*** tree-t

    #+begin_src cicada
    (+union tree-t : (-> type-tt -- type-tt)
      (-> value : :t -- :t leaf-t)
      (-> left : :t.right : :t -- :t node-t))
    #+end_src

*** tree-t : functor-ct

    #+begin_src cicada
    (+imp tree-t : functor-ct
      (+fun map
        : (-> tree : :t1 tree-t
              fun : (-> :t1 -- :t2)
           -- :t2 tree-t)
        (case tree
          (leaf-t tree.value fun leaf-c)
          (node-t
            tree.left {fun} recur
            tree.right {fun} recur node-c))))
    #+end_src

*** tree-zip

    #+begin_src cicada
    (+fun tree-zip
      : ())
    #+end_src

*** tree-numbering

    #+begin_src cicada
    (+fun tree-numbering
      : (-> nat-t tree : :t tree-t
         -- nat-t nat-t tree-t)
      (case tree
        (leaf-t dup inc swap leaf-c)
        (node-t
          tree.left recur (let left)
          tree.right recur (let right)
          left right node-c)))
    #+end_src

*** tree-numbering-curry

    #+begin_src cicada
    (+fun tree-numbering-curry
      : (-> tree : :t tree-t
         -- (-> nat-t
             -- nat-t tree-t))
      (case tree
        (leaf-t {dup inc swap leaf-c})
        (node-t {tree.left recur apply (let left)
                 tree.right recur apply (let right)
                 left right node-c})))
    #+end_src

*** tree-numbering-state

    #+begin_src cicada
    (+fun tree-numbering-state
      : (-> tree : :t tree-t
         -- nat-t tree-t state-t)
      (case tree
        (leaf-t {dup inc swap leaf} state-c)
        (node-t (do
                  left = [tree.left recur]
                  right = [tree.right recur]
                  [left right node-c]))))
    #+end_src

*** [note] macro expansion of (do)

    #+begin_src cicada
    (do
      left = [tree.left recur]
      right = [tree.right recur]
      [left right node])

    ;; =expand-to=>

    (begin
      [tree.left recur]
      {(let left)
       [tree.right recur]
       {(let right)
        [left right node]
        return}
       bind}
      bind)
    #+end_src

* list processing

*** list-t

    #+begin_src cicada
    (+union list-t : (-> type : type-tt -- type-tt)
      (-> -- type null-t)
      (-> car : type
          cdr : type list-t
       -- type cons-t))
    #+end_src

*** append-o

    #+begin_src cicada
    (+relation append-o
      : )
    #+end_src

* number theory

*** int-q

    #+begin_src cicada

    #+end_src

*** mod-t

    #+begin_src cicada
    (+union mod-t
      : (->
         -- )
      (-> ))
    #+end_src

*** gcd-t

    #+begin_src cicada
    (+union gcd-t
      : (-> x : int-q
            y : int-q
            d : int-q
         -- type-tt)
      (-> -- x zero-c x zero-gcd-t)
      (-> gcd : x y d gcd-t
          mod : x y z mod-t
       -- y z d mod-gcd-t))
    #+end_src
