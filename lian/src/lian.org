#+property: tangle lib.rs
#+title: lian
- dup
- test_mexp
- error report in Goal::apply
* prolog

*** feature

    #+begin_src rust
    #![feature (uniform_paths)]
    #![feature (bind_by_move_pattern_guards)]

    #![allow (unused_parens)]
    #![allow (dead_code)]
    #![allow (unused_macros)]
    #![allow (non_camel_case_types)]
    #+end_src

*** use

    #+begin_src rust
    use std::sync::Arc;
    use uuid::Uuid;
    use dic::Dic;
    #+end_src

* Term

*** Term

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub enum Term {
        Var   (VarTerm),
        Tuple (TupleTerm),
    }
    #+end_src

*** VarTerm

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct VarTerm {
        name: String,
        id: Uuid,
    }
    #+end_src

*** TupleTerm

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct TupleTerm {
        head: String,
        body: Vec <Term>,
    }
    #+end_src

*** Term::var

    #+begin_src rust
    impl Term {
        fn var (s: &str) -> Term {
            Term::Var (VarTerm {
                name: s.to_string (),
                id: Uuid::new_v4 (),
            })
        }
    }
    #+end_src

*** Term::tuple

    #+begin_src rust
    impl Term {
        fn tuple (h: &str, vec: Vec <Term>) -> Term {
            Term::Tuple (TupleTerm {
                head: h.to_string (),
                body: vec,
            })
        }
    }
    #+end_src

* Subst

*** Subst

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub enum Subst {
        Null,
        Cons {
           var: VarTerm,
           term: Term,
           next: Arc <Subst>,
        },
    }
    #+end_src

*** Subst::new

    #+begin_src rust
    impl Subst {
        fn new () -> Self {
            Subst::Null
        }
    }
    #+end_src

*** Subst::extend

    #+begin_src rust
    impl Subst {
        fn extend (&self, var: VarTerm, term: Term) -> Self {
            Subst::Cons {
                var, term,
                next: Arc::new (self.clone ()),
            }
        }
    }
    #+end_src

*** Subst::find

    #+begin_src rust
    impl Subst {
        pub fn find (&self, var: &VarTerm) -> Option <&Term> {
            match self {
                Subst::Null => None,
                Subst::Cons {
                    var: first, term, next,
                } => {
                    if first == var {
                        Some (term)
                    } else {
                        next.find (var)
                    }
                }
            }
        }
    }
    #+end_src

*** Subst::walk

    #+begin_src rust
    impl Subst {
        pub fn walk (&self, term: &Term) -> Term {
            match term {
                Term::Var (var) => {
                    if let Some (new_term) = self.find (var) {
                        self.walk (new_term)
                    } else {
                        term.clone ()
                    }
                }
                _ => term.clone ()
            }
        }
    }
    #+end_src

*** Subst::unify

    #+begin_src rust
    impl Subst {
        pub fn unify (
            &self,
            u: &Term,
            v: &Term,
        ) -> Option <Subst> {
            let u = self.walk (u);
            let v = self.walk (v);
            match (u, v) {
                (Term::Var (u),
                 Term::Var (v),
                ) if u == v => {
                    Some (self.clone ())
                }
                (Term::Var (u), v) => {
                    Some (self.extend (u, v))
                }
                (u, Term::Var (v)) => {
                    Some (self.extend (v, u))
                }
                (Term::Tuple (ut),
                 Term::Tuple (vt),
                ) => {
                    if ut.head != vt.head {
                        return None;
                    }
                    if ut.body.len () != vt.body.len () {
                        return None;
                    }
                    let mut subst = self.clone ();
                    let zip = ut.body.iter () .zip (vt.body.iter ());
                    for (u, v) in zip {
                        subst = subst.unify (u, v)?;
                    }
                    Some (subst)
                }
            }
        }
    }
    #+end_src

* Disj

*** Disj

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct Disj {
        conj_dic: Dic <Conj>,
    }
    #+end_src

* Conj

*** Conj

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct Conj {
        head: Vec <Term>,
        body: Vec <Call>,
    }
    #+end_src

* Call

*** Call

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub enum Call {
        Disj {
            disj_name: String,
            args: Vec <Term>,
        },
        Conj {
            disj_name: String,
            conj_name: String,
            args: Vec <Term>,
        },
    }
    #+end_src

* Wissen

*** Wissen

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct Wissen {
        disj_dic: Dic <Disj>,
    }
    #+end_src

*** Wissen::query

    #+begin_src rust
    impl Wissen {
        fn query <'a> (
            &'a self,
            disj_name: &str,
            args: Vec <Term>,
        ) -> Solving <'a> {
            let disj = self.disj_dic.get (disj_name) .unwrap ();
            let frame = Frame {
                disj_name: disj_name.to_string (),
                disj: disj.clone (),
                args: args,
                index: 0,
                backup_subst: Subst::new (),
            };
            Solving {
                wissen: self,
                trace: vec! [frame],
                subst: Subst::new (),
            }
        }
    }
    #+end_src

* Solving

*** Solving

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct Solving <'a> {
        wissen: &'a Wissen,
        trace: Vec <Frame>,
        subst: Subst,
    }
    #+end_src

*** Frame

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct Frame {
        disj_name: String,
        disj: Disj,
        args: Vec <Term>,
        index: usize,
        backup_subst: Subst,
    }
    #+end_src

*** [todo] Solving::next_subst

    #+begin_src rust
    impl <'a> Solving <'a> {
        fn next_subst (&mut self) -> Option <Subst> {
            unimplemented! ()
        }
    }
    #+end_src

* test

*** test_unify

    #+begin_src rust
    #[test]
    fn test_unify () {
        let u = Term::var ("u");
        let v = Term::var ("v");
        let subst = Subst::new () .unify (
            &Term::tuple ("tuple", vec! [
                u.clone (),
                v.clone (),
            ]),
            &Term::tuple ("tuple", vec! [
                v.clone (),
                Term::tuple ("hi", vec! []),
            ]));
        println! ("{:?}", subst.unwrap ());
    }
    #+end_src

*** [todo] test_mexp

    #+begin_src rust
    #[test]
    fn test_mexp () {

    }
    #+end_src
