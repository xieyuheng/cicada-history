#+property: tangle lib.rs
#+title: lian
- use global name space for goal -- to handle recursion
- test_mexp
* prolog

*** feature

    #+begin_src rust
    #![feature (uniform_paths)]
    #![feature (bind_by_move_pattern_guards)]

    #![allow (unused_parens)]
    #![allow (dead_code)]
    #![allow (unused_macros)]
    #![allow (non_camel_case_types)]
    #+end_src

*** use

    #+begin_src rust
    use std::vec;
    use std::sync::Arc;
    use uuid::Uuid;
    #+end_src

* Term

*** Term

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub enum Term {
        Var   (VarTerm),
        Tuple (TupleTerm),
    }
    #+end_src

*** VarTerm

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct VarTerm {
        name: String,
        id: Uuid,
    }
    #+end_src

*** TupleTerm

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct TupleTerm {
        head: String,
        body: Vec <Term>,
    }
    #+end_src

* Env

*** Env

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub struct Env {
        pub relation_dic: RelationDic,
        pub subst: Subst,
    }
    #+end_src

*** Env::new

    #+begin_src rust
    impl Env {
        fn new () -> Self {
            Env {
                relation_dic: RelationDic::Null,
                subst: Subst::new (),
            }
        }
    }
    #+end_src

*** RelationDic

***** RelationDic

      #+begin_src rust
      #[derive (Clone)]
      #[derive (Debug)]
      #[derive (PartialEq)]
      pub enum RelationDic {
          Null,
          Cons {
              relation_name: String,
              relation: Relation,
              next: Arc <RelationDic>,
          },
      }
      #+end_src

***** RelationDic::new

      #+begin_src rust
      impl RelationDic {
          fn new () -> Self {
              RelationDic::Null
          }
      }
      #+end_src

*** [todo] Relation

***** Relation

      #+begin_src rust
      #[derive (Clone)]
      #[derive (Debug)]
      #[derive (PartialEq)]
      pub struct Relation {

      }
      #+end_src

*** Choice

***** Choice

      #+begin_src rust
      #[derive (Clone)]
      #[derive (Debug)]
      #[derive (PartialEq)]
      pub struct Choice {
          body: Vec <Goal>,
      }
      #+end_src

*** Subst

***** Subst

      #+begin_src rust
      #[derive (Clone)]
      #[derive (Debug)]
      #[derive (PartialEq)]
      pub enum Subst {
          Null,
          Cons {
             var: VarTerm,
             term: Term,
             next: Arc <Subst>,
          },
      }
      #+end_src

***** Subst::new

      #+begin_src rust
      impl Subst {
          fn new () -> Self {
              Subst::Null
          }
      }
      #+end_src

***** Subst::cons

      #+begin_src rust
      impl Subst {
          fn cons (&self, var: VarTerm, term: Term) -> Self {
              Subst::Cons {
                  var, term,
                  next: Arc::new (self.clone ()),
              }
          }
      }
      #+end_src

***** Subst::find

      #+begin_src rust
      impl Subst {
          pub fn find (&self, var: &VarTerm) -> Option <&Term> {
              match self {
                  Subst::Null => None,
                  Subst::Cons {
                      var: first, term, next,
                  } => {
                      if first == var {
                          Some (term)
                      } else {
                          next.find (var)
                      }
                  }
              }
          }
      }
      #+end_src

***** Subst::walk

      #+begin_src rust
      impl Subst {
          pub fn walk (&self, term: &Term) -> Term {
              match term {
                  Term::Var (var) => {
                      if let Some (new_term) = self.find (var) {
                          self.walk (new_term)
                      } else {
                          term.clone ()
                      }
                  }
                  _ => term.clone ()
              }
          }
      }
      #+end_src

***** Subst::unify

      #+begin_src rust
      impl Subst {
          pub fn unify (
              &self,
              u: &Term,
              v: &Term,
          ) -> Option <Subst> {
              let u = self.walk (u);
              let v = self.walk (v);
              match (u, v) {
                  (Term::Var (u),
                   Term::Var (v),
                  ) if u == v => {
                      Some (self.clone ())
                  }
                  (Term::Var (u), v) => {
                      Some (self.cons (u, v))
                  }
                  (u, Term::Var (v)) => {
                      Some (self.cons (v, u))
                  }
                  (Term::Tuple (ut),
                   Term::Tuple (vt),
                  ) => {
                      if ut.head != vt.head {
                          return None;
                      }
                      if ut.body.len () != vt.body.len () {
                          return None;
                      }
                      let mut subst = self.clone ();
                      let zip = ut.body.iter () .zip (vt.body.iter ());
                      for (u, v) in zip {
                          subst = subst.unify (u, v)?;
                      }
                      Some (subst)
                  }
              }
          }
      }
      #+end_src

* Goal

*** Goal

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq)]
    pub enum Goal {
        Eqo  {
            u: Term,
            v: Term,
        },
        Disj {
            g1: Arc <Goal>,
            g2: Arc <Goal>,
        },
        Conj {
            g1: Arc <Goal>,
            g2: Arc <Goal>,
        },
    }
    #+end_src

*** Goal::apply

    #+begin_src rust
    impl Goal {
        pub fn apply (&self, env: Env) -> Stream {
            match self {
                Goal::Eqo { u, v } => {
                    if let Some (
                        subst
                    ) = env.subst.unify (&u, &v) {
                        unit (Env {
                            subst,
                            ..env
                        })
                    } else {
                        mzero ()
                    }
                }
                Goal::Disj { g1, g2 } => {
                    mplus (
                        g1.apply (env.clone ()),
                        g2.apply (env))
                }
                Goal::Conj { g1, g2 } => {
                    bind (g1.apply (env), g2)
                }
            }
        }
    }
    #+end_src

* Stream

*** Stream

    #+begin_src rust
    type Stream = Box <Iterator <Item = Env>>;
    #+end_src

*** mzero

    #+begin_src rust
    fn mzero () -> Stream {
        Box::new (Vec::new () .into_iter ())
    }
    #+end_src

*** unit

    #+begin_src rust
    fn unit (env: Env) -> Stream {
        Box::new (vec! [env] .into_iter ())
    }
    #+end_src

*** mplus

    #+begin_src rust
    fn mplus (mut s1: Stream, s2: Stream) -> Stream {
        if let Some (env) = s1.next () {
            Box::new (unit (env) .chain (s2) .chain (s1))
        } else {
            s2
        }
    }
    #+end_src

*** bind

    #+begin_src rust
    fn bind (mut s: Stream, g: &Goal) -> Stream {
        if let Some (env) = s.next () {
            mplus (g.apply (env), bind (s, g))
        } else {
            mzero ()
        }
    }
    #+end_src

* interface

*** var

    #+begin_src rust
    fn var (s: &str) -> Term {
        Term::Var (VarTerm {
            name: s.to_string (),
            id: Uuid::new_v4 (),
        })
    }
    #+end_src

*** tuple

    #+begin_src rust
    fn tuple (h: &str, vec: Vec <Term>) -> Term {
        Term::Tuple (TupleTerm {
            head: h.to_string (),
            body: vec,
        })
    }
    #+end_src

*** eqo

    #+begin_src rust
    fn eqo (u: Term, v: Term) -> Arc <Goal> {
        Arc::new (Goal::Eqo { u, v })
    }
    #+end_src

*** disj

    #+begin_src rust
    fn disj (g1: Arc <Goal>, g2: Arc <Goal>) -> Arc <Goal> {
        Arc::new (Goal::Disj { g1, g2 })
    }
    #+end_src

*** conj

    #+begin_src rust
    fn conj (g1: Arc <Goal>, g2: Arc <Goal>) -> Arc <Goal> {
        Arc::new (Goal::Conj { g1, g2 })
    }
    #+end_src

* test

*** test_unify

    #+begin_src rust
    #[test]
    fn test_unify () {
        let u = var ("u");
        let v = var ("v");
        let env = Env::new () .subst.unify (
            &tuple ("tuple", vec! [u.clone (), v.clone ()]),
            &tuple ("tuple", vec! [v.clone (), tuple ("hi", vec! [])]));
        println! ("{:?}", env.unwrap ());
    }
    #+end_src

*** test_goal

    #+begin_src rust
    #[test]
    fn test_goal () {
        let g = conj (
            eqo (var ("u"), tuple ("love", vec! [])),
            disj (eqo (var ("v"), tuple ("bye", vec! [])),
                  eqo (var ("w"), tuple ("hi", vec! [])))
        );
        for env in g.apply (Env::new ()) {
            println! ("- {:?}", env);
        }
    }
    #+end_src

*** [todo] test_mexp

    #+begin_src rust
    #[test]
    fn test_mexp () {

    }
    #+end_src
