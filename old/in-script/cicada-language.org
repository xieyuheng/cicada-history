#+property: tangle cicada-language.cs
#+title: cicada-language

* [todo-stack]

*** obj-unify & field-unify, by dynamic monad

    - only direct caller of unify
      handles failed unification

    - failed unification
      will not be passed upward

*** should not use [exp-collect-one drop]

*** id-counter in env-t

    - new-hypo-id

*** gc for hypo, on each -c

*** in cicada-script

    - (@) -> (~)
    - fix (cond)
    - (@) as (lit-dict)
    - (@<type-name>) as lit-data

*** printer handle begin-exp-t

*** a syntax to call [null-c] with explicit type argument

*** simple typed language

    - in a simple typed language
      there will be no function application involved
      during type or data construction
      because there are not function call in types

    - we can push scope-stack to use local variables

    - but even if we need function application later
      we can achieve it by pushing frame-stack

    ------

    - x -
      function application might be handled similarly

    - k -
      what do you mean by "similarly" ?

    - x -
      for type and data constructor application
      the new idea we used is to create a pre-obj
      and then use field-unify
      for function application
      we can first create trunk [or trunks]
      against logic variables
      and then use argument-unify

*** no hypo

    - x -
      when creating a value of type [type null-t]
      by [null-c]
      one must provide the type explicitly

    - k -
      we still can use hypo
      this will make calling [null-c] simple

      we just need to be careful

      use one scope for value
      one scope for type

      during cut
      after the unification of ante
      when we about to enter the succ

      we should check that
      for each bind in the scope of type
      it is also bound to a value

      otherwise the type check will be not sound
      for example :
      ><><><

*** cut might effect not only on ante but also on succ.

    - cut might effect not only on ante but also on succ.
      we should examine the following which uses cut :
      1. top level type check
      2. infer of closure

*** re-design the whole imp for multiple-world-semantic

*** sum-type-t back

    - x -
      after simplified the implementation this much
      we can bring sum-type-t back to the imp
      to make the semantic of cut and type-check more clear

    ------

    - x -
      to handle sum-type-t properly
      we need multiple-world-semantic
      we must not only passing env-t
      but passing
      - env-t list-u -- for finite sum-type-t
      - env-t stream-u -- for infinite sum-type-t

*** env-print really use indent

*** (+union) handled inline (+type)

*** fix exp-list-bind-colon

    - for binding not at tail

*** test exe

* [todo-list]

*** eq-p in unification

*** about return value of unification and error report

*** unification digraph

    - what is its property ?
      [note that only var can be bound to]

    - what is its interface ?

* [note]

*** type constructor

    - type constructors can not occur in function body

*** (case)

    - bad points :
      1. (case) can only occur at tail
      2. can not cut case-exp-t
         case-exp-t is handled by checker
      3. can not infer closure with (case)

    - good points :
      1. (case) can return multiple values

*** mutual recursive

    - exe call infer through ante-prepare
    - infer call cut on closure-obj-t
    - cut call infer on non den-u

    ------

    - thus it is hard to incrementally test this implementation

*** hypothetically constructed object

    - in oop,
      when you ask for a new object of a class,
      the init function of the class is used
      to form an object of that class.
      [the init function might takes arguments]

    - in cicada,
      when you ask for a new object of a type,

      1. the type might has many data-constructors,
         we do not know
         which data-constructors should be used,
         thus a hypo will be created.

      2. the type might has only one data-constructor.
         but it takes arguments,
         we do not have the arguments yet,
         thus a hypo will be created.

*** todo to done

    - every time we change a hypo

    - then, every time we see a todo-case-t
      we know we can not change it to a done-case-t yet
      because we already tried

*** ffi

    - to handle ffi,
      primitive function must can be applied to trunks,
      and return new todo obj.

      thus I do not implement this feature for now.

* prolog

*** dummy :

    #+begin_src cicada
    (+fun :)
    #+end_src

*** dummy (+alias)

    #+begin_src cicada
    (+macro +alias note)
    #+end_src

*** (->) to (let)

    #+begin_src cicada
    (+macro -> (let body)
      body {'-- eq-p} list-ante
      {', eq-p not} list-filter
      sexp-remove-colon (let new-body)
      `(let (@ new-body list-spread)))
    #+end_src

*** sexp-remove-colon

    #+begin_src cicada
    (+fun sexp-remove-colon (let ante)
      (case ante
        (null-t null-c)
        (cons-t
          (case ante.cdr
            (null-t null-c)
            (cons-t
              (if [ante.cdr.car ': eq-p]
                [ante.car ante.cdr.cdr.cdr recur cons-c]
                [ante.cdr recur]))))))
    #+end_src

*** (+type) to (+data)

    #+begin_src cicada
    (+macro +type (let body)
       body.car (let name)
       body.cdr (let rest)
      `(+data (@ name) (@ rest sexp-remove-colon list-spread)))
    #+end_src

* env

*** env-t

    #+begin_src cicada
    (+type env-t
      name-dict : [string-t den-u dict-t]
      data-stack : [obj-u list-u]
      frame-stack : [frame-u list-u]
      scope-stack : [scope-t list-u]
      goal-stack : [goal-t list-u]
      data-bind-dict : [hypo-id-t obj-u dict-t]
      type-bind-dict : [hypo-id-t obj-u dict-t])
    #+end_src

*** new-env

    #+begin_src cicada
    (+fun new-env
      : (-> -- env-t)
      (lit-dict)
      (lit-list)
      (lit-list)
      (lit-list)
      (lit-list)
      (lit-dict)
      (lit-dict)
      (. name-dict
         data-stack
         frame-stack
         scope-stack
         goal-stack
         data-bind-dict
         type-bind-dict)
      env-cr)
    #+end_src

*** name-dict

***** name-dict-find

      #+begin_src cicada
      (+fun name-dict-find
        : (-> env-t, name : string-t
           -- env-t (+ den-u true-t | false-t))
        dup .name-dict name dict-find)
      #+end_src

***** name-dict-get

      #+begin_src cicada
      (+fun name-dict-get
        : (-> env-t, name : string-t -- env-t den-u)
        dup .name-dict name dict-get)
      #+end_src

***** name-dict-insert

      #+begin_src cicada
      (+fun name-dict-insert
        : (-> env : env-t, name : string-t, den : den-u -- env-t)
        env.name-dict name den dict-insert
        (. name-dict)
        env clone)
      #+end_src

*** data-stack

***** data-stack-push

      #+begin_src cicada
      (+fun data-stack-push
        : (-> env : env-t, obj : obj-u -- env-t)
        obj env.data-stack cons-c
        (. data-stack)
        env clone)
      #+end_src

***** data-stack-pop

      #+begin_src cicada
      (+fun data-stack-pop
        : (-> env : env-t -- env-t obj-u)
        env.data-stack.cdr
        (. data-stack)
        env clone
        env.data-stack.car)
      #+end_src

***** data-stack-drop

      #+begin_src cicada
      (+fun data-stack-drop
        : (-> env-t -- env-t)
        data-stack-pop drop)
      #+end_src

***** data-stack-tos

      #+begin_src cicada
      (+fun data-stack-tos
        : (-> env-t -- env-t obj-u)
        dup .data-stack.car)
      #+end_src

***** data-stack-n-pop

      #+begin_src cicada
      (+fun data-stack-n-pop
        : (-> env-t, number-t
           -- env-t, obj-u list-u)
        null-c data-stack-n-pop-to-list)

      (+fun data-stack-n-pop-to-list
        : (-> env-t, n : number-t, list : [obj-u list-u]
           -- env-t, obj-u list-u)
        (if [n 0 lteq-p]
          list
          [data-stack-pop list cons-c
           n dec swap recur]))
      #+end_src

***** data-stack-list-push

      #+begin_src cicada
      (+fun data-stack-list-push
        : (-> env-t, list : [obj-u list-u]
           -- env-t)
        (case list
          (null-t)
          (cons-t
            list.car data-stack-push
            list.cdr recur)))
      #+end_src

*** frame-stack

***** frame-stack-push

      #+begin_src cicada
      (+fun frame-stack-push
        : (-> env : env-t, frame : frame-u -- env-t)
        frame env.frame-stack cons-c
        (. frame-stack)
        env clone)
      #+end_src

***** frame-stack-pop

      #+begin_src cicada
      (+fun frame-stack-pop
        : (-> env : env-t -- env-t frame-u)
        env.frame-stack.cdr
        (. frame-stack)
        env clone
        env.frame-stack.car)
      #+end_src

***** frame-stack-drop

      #+begin_src cicada
      (+fun frame-stack-drop
        : (-> env-t -- env-t)
        frame-stack-pop drop)
      #+end_src

***** frame-stack-tos

      #+begin_src cicada
      (+fun frame-stack-tos
        : (-> env-t -- env-t frame-u)
        dup .frame-stack.car)
      #+end_src

*** frame

***** frame-u

      #+begin_src cicada
      (+union frame-u
        scoping-frame-t
        simple-frame-t)
      #+end_src

***** scoping-frame-t

      #+begin_src cicada
      (+type scoping-frame-t
        body-exp-list : [exp-u list-u]
        index : number-t)
      #+end_src

***** new-scoping-frame

      #+begin_src cicada
      (+fun new-scoping-frame
        : (-> body-exp-list : [exp-u list-u] -- scoping-frame-t)
        body-exp-list 0
        (. body-exp-list index)
        scoping-frame-cr)
      #+end_src

***** simple-frame-t

      #+begin_src cicada
      (+type simple-frame-t
        body-exp-list : [exp-u list-u]
        index : number-t)
      #+end_src

***** new-simple-frame

      #+begin_src cicada
      (+fun new-simple-frame
        : (-> body-exp-list : [exp-u list-u] -- simple-frame-t)
        body-exp-list 0
        (. body-exp-list index)
        simple-frame-cr)
      #+end_src

***** top-frame-finished-p

      #+begin_src cicada
      (+fun top-frame-finished-p
        : (-> env-t -- env-t bool-u)
        frame-stack-tos (let frame)
        frame.index frame.body-exp-list list-length eq-p)
      #+end_src

***** top-frame-next-exp

      #+begin_src cicada
      (+fun top-frame-next-exp
        : (-> env-t -- env-t exp-u)
        frame-stack-pop (let frame)
        frame.index inc
        (. index)
        frame clone
        frame-stack-push
        frame.body-exp-list frame.index list-ref)
      #+end_src

*** scope-stack

***** scope-stack-push

      #+begin_src cicada
      (+fun scope-stack-push
        : (-> env : env-t
              scope : scope-t
           -- env-t)
        scope env.scope-stack cons-c
        (. scope-stack)
        env clone)
      #+end_src

***** scope-stack-pop

      #+begin_src cicada
      (+fun scope-stack-pop
        : (-> env : env-t -- env-t scope-t)
        env.scope-stack.cdr
        (. scope-stack)
        env clone
        env.scope-stack.car)
      #+end_src

***** scope-stack-drop

      #+begin_src cicada
      (+fun scope-stack-drop
        : (-> env-t -- env-t)
        scope-stack-pop drop)
      #+end_src

***** scope-stack-tos

      #+begin_src cicada
      (+fun scope-stack-tos
        : (-> env-t -- env-t scope-t)
        dup .scope-stack.car)
      #+end_src

***** scope-stack-empty-p

      #+begin_src cicada
      (+fun scope-stack-empty-p
        : (-> env-t -- env-t bool-u)
        dup .scope-stack null-p)
      #+end_src

*** scope

***** scope-t

      #+begin_src cicada
      (+alias scope-t [string-t obj-u dict-t])
      #+end_src

***** new-scope

      #+begin_src cicada
      (+fun new-scope
        : (-> -- scope-t)
        (lit-dict))
      #+end_src

***** scope-get

      #+begin_src cicada
      (+fun scope-get
        : (-> scope-t
              string-t
           -- obj-u)
        dict-get)
      #+end_src

***** current-scope-get

      #+begin_src cicada
      (+fun current-scope-get
        : (-> env-t
              name : string-t
           -- env-t
              obj-u)
        scope-stack-tos name scope-get)
      #+end_src

***** scope-find

      #+begin_src cicada
      (+fun scope-find
        : (-> scope-t
              string-t
           -- (+ obj-u true-t | false-t))
        dict-find)
      #+end_src

***** current-scope-find

      #+begin_src cicada
      (+fun current-scope-find
        : (-> env-t
              name : string-t
           -- env-t
              (+ obj-u true-t | false-t))
        (if scope-stack-empty-p
          [false-c]
          [scope-stack-tos
           name scope-find]))
      #+end_src

***** scope-insert

      #+begin_src cicada
      (+fun scope-insert
        : (-> scope-t
              name : string-t
              obj : obj-u
           -- scope-t)
        name obj dict-insert)
      #+end_src

***** current-scope-insert

      #+begin_src cicada
      (+fun current-scope-insert
        : (-> env-t
              name : string-t
              obj : obj-u
           -- env-t)
        scope-stack-pop
        name obj scope-insert
        scope-stack-push)
      #+end_src

*** >< goal-stack

*** data-bind-dict

***** data-bind-dict-find

      #+begin_src cicada
      (+fun data-bind-dict-find
        : (-> env-t, hypo-id : hypo-id-t
           -- env-t (+ obj-u true-t | false-t))
        dup .data-bind-dict hypo-id dict-find)
      #+end_src

***** data-bind-dict-insert

      #+begin_src cicada
      (+fun data-bind-dict-insert
        : (-> env : env-t
              hypo-id : hypo-id-t
              obj : obj-u
           -- env-t)
        env.data-bind-dict hypo-id obj dict-insert
        (. data-bind-dict)
        env clone)
      #+end_src

*** type-bind-dict

***** type-bind-dict-find

      #+begin_src cicada
      (+fun type-bind-dict-find
        : (-> env-t, hypo-id : hypo-id-t
           -- env-t (+ obj-u true-t | false-t))
        dup .type-bind-dict hypo-id dict-find)
      #+end_src

***** type-bind-dict-insert

      #+begin_src cicada
      (+fun type-bind-dict-insert
        : (-> env : env-t
              hypo-id : hypo-id-t
              obj : obj-u
           -- env-t)
        env.type-bind-dict hypo-id obj dict-insert
        (. type-bind-dict)
        env clone)
      #+end_src

*** hypo-bind-dict

***** hypo-bind-dict-find

      #+begin_src cicada
      (+fun hypo-bind-dict-find
        : (-> env-t
              hypo : (+ data-hypo-t | type-hypo-t)
           -- env-t
              (+ obj-u true-t | false-t))
        (case hypo
          (data-hypo-t hypo.id data-bind-dict-find)
          (type-hypo-t hypo.id type-bind-dict-find)))
      #+end_src

***** hypo-bind-dict-insert

      #+begin_src cicada
      (+fun hypo-bind-dict-insert
        : (-> env-t
              hypo : (+ data-hypo-t | type-hypo-t)
              obj : obj-u
           -- env-t)
        (case hypo
          (data-hypo-t hypo.id obj data-bind-dict-insert)
          (type-hypo-t hypo.id obj type-bind-dict-insert)))
      #+end_src

* >< multi-env

*** multi-env-t

    #+begin_src cicada
    (+type multi-env-t
       env-list : env-t list-u)
    #+end_src

* exp

*** exp-u

    #+begin_src cicada
    (+union exp-u
      call-exp-t
      let-exp-t
      closure-exp-t
      arrow-exp-t
      apply-exp-t
      case-exp-t
      field-exp-t
      colon-exp-t
      double-colon-exp-t
      begin-exp-t
      comma-exp-t
      type-tt-exp-t)
    #+end_src

*** call-exp-t

    #+begin_src cicada
    (+type call-exp-t
      name : string-t)
    #+end_src

*** let-exp-t

    #+begin_src cicada
    (+type let-exp-t
      name-list : [string-t list-u])
    #+end_src

*** closure-exp-t

    #+begin_src cicada
    (+type closure-exp-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** arrow-exp-t

    #+begin_src cicada
    (+type arrow-exp-t
      ante-exp-list : [exp-u list-u]
      succ-exp-list : [exp-u list-u])
    #+end_src

*** apply-exp-t

    #+begin_src cicada
    (+type apply-exp-t)
    #+end_src

*** case-exp-t

    #+begin_src cicada
    (+type case-exp-t
      arg-exp-list : [exp-u list-u]
      closure-exp-dict : [string-t closure-exp-t dict-t])
    #+end_src

*** field-exp-t

    #+begin_src cicada
    (+type field-exp-t
      field-name : string-t)
    #+end_src

*** colon-exp-t

    #+begin_src cicada
    (+type colon-exp-t
      name : string-t
      type-exp-list : [exp-u list-u])
    #+end_src

*** double-colon-exp-t

    #+begin_src cicada
    (+type double-colon-exp-t
      name : string-t
      type-exp-list : [exp-u list-u])
    #+end_src

*** begin-exp-t

    #+begin_src cicada
    (+type begin-exp-t
      body : [exp-u list-u])
    #+end_src

*** comma-exp-t

    #+begin_src cicada
    (+type comma-exp-t)
    #+end_src

*** type-tt-exp-t

    #+begin_src cicada
    (+type type-tt-exp-t)
    #+end_src

* den

*** den-u

    #+begin_src cicada
    (+union den-u
      fun-den-t
      data-cons-den-t
      type-cons-den-t
      union-cons-den-t)
    #+end_src

*** fun-den-t

    #+begin_src cicada
    (+type fun-den-t
      name : string-t
      type-arrow-exp : arrow-exp-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** data-cons-den-t

    #+begin_src cicada
    (+type data-cons-den-t
      name : string-t
      type-arrow-exp : arrow-exp-t
      cons-arrow-exp : arrow-exp-t)
    #+end_src

*** type-cons-den-t

    #+begin_src cicada
    (+type type-cons-den-t
      name : string-t
      type-arrow-exp : arrow-exp-t
      cons-arrow-exp : arrow-exp-t)
    #+end_src

*** union-cons-den-t

    #+begin_src cicada
    (+type union-cons-den-t
      name : string-t
      type-arrow-exp : arrow-exp-t
      sub-name-list : [string-t list-u])
    #+end_src

* obj

*** obj-u

    #+begin_src cicada
    (+union obj-u
      data-obj-t data-type-t
      union-type-t
      type-type-t
      closure-obj-t arrow-type-t
      data-hypo-t type-hypo-t)
    #+end_src

*** data-obj-t

    #+begin_src cicada
    (+type data-obj-t
      data-type : data-type-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** data-type-t

    #+begin_src cicada
    (+type data-type-t
      name : string-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** union-type-t

    #+begin_src cicada
    (+type union-type-t
      name : string-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** type-type-t

    #+begin_src cicada
    (+type type-type-t
      level : number-t)
    #+end_src

*** closure-obj-t

    #+begin_src cicada
    (+type closure-obj-t
      scope : scope-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** arrow-type-t

    #+begin_src cicada
    (+type arrow-type-t
      ante-type-list : [obj-u list-u]
      succ-type-list : [obj-u list-u])
    #+end_src

*** data-hypo-t

    #+begin_src cicada
    (+type data-hypo-t
      id : hypo-id-t)
    #+end_src

*** type-hypo-t

    #+begin_src cicada
    (+type type-hypo-t
      id : hypo-id-t)
    #+end_src

*** hypo-id-t

    #+begin_src cicada
    (+type hypo-id-t
      string : string-t)
    #+end_src

* exe

*** exe

    #+begin_src cicada
    (+fun exe
      : (-> env-t exp-u -- env-t)
      (case dup
        (call-exp-t call-exp-exe)
        (let-exp-t let-exp-exe)
        (closure-exp-t closure-exp-exe)
        (arrow-exp-t arrow-exp-exe)
        (apply-exp-t apply-exp-exe)
        (case-exp-t case-exp-exe)
        (field-exp-t field-exp-exe)
        (colon-exp-t colon-exp-exe)
        (double-colon-exp-t double-colon-exp-exe)
        (comma-exp-t comma-exp-exe)
        (begin-exp-t begin-exp-exe)
        (type-tt-exp-t type-tt-exp-exe)))
    #+end_src

*** call-exp-exe

    #+begin_src cicada
    (+fun call-exp-exe
      : (-> env-t, exp : call-exp-t -- env-t)
      (if [exp.name current-scope-find]
        (begin (let obj)
          (if (or [obj data-hypo-p]
                  [obj type-hypo-p])
            (if [obj hypo-bind-dict-find]
              [data-stack-push]
              [obj data-stack-push])
            [obj data-stack-push]))
        (if [exp.name name-dict-find]
          [den-exe]
          ["- call-exp-exe fail" p nl
           "  unknown name : " p exp.name p nl
           error])))
    #+end_src

*** den-exe

***** den-exe

      #+begin_src cicada
      (+fun den-exe
        : (-> env-t den-u -- env-t)
        (case dup
          (fun-den-t fun-den-exe)
          (data-cons-den-t data-cons-den-exe)
          (type-cons-den-t type-cons-den-exe)
          (union-cons-den-t union-cons-den-exe)))
      #+end_src

***** fun-den-exe

      #+begin_src cicada
      (+fun fun-den-exe
        : (-> env-t, den : fun-den-t -- env-t)
        new-scope scope-stack-push
        den.type-arrow-exp exp-collect-one drop
        den.type-arrow-exp.ante-exp-list exp-list-bind-colon
        den.body-exp-list new-scoping-frame frame-stack-push)
      #+end_src

***** exp-list-bind-colon

      #+begin_src cicada
      (+fun exp-list-bind-colon
        : (-> env-t
              exp-list : [exp-u list-u]
           -- env-t)
        exp-list
        {colon-exp-p} list-filter
        list-reverse
        {exp-bind-colon} list-for-each)
      #+end_src

***** exp-bind-colon

      #+begin_src cicada
      (+fun exp-bind-colon
        : (-> env-t
              exp : exp-u
           -- env-t)
        exp.name current-scope-get (let data-hypo)
        data-stack-pop data-hypo
        swap hypo-bind-dict-insert)
      #+end_src

***** type-cons-den-exe

      #+begin_src cicada
      (+fun type-cons-den-exe
        : (-> env-t, den : type-cons-den-t -- env-t)
        new-scope scope-stack-push
        den.type-arrow-exp.ante-exp-list
        {bind-exp-in-ante} list-map
        den.type-arrow-exp.ante-exp-list
        ante-exp-list->field-obj-dict
        den.name
        (. field-obj-dict name)
        data-type-cr
        field-unify
        data-stack-push
        scope-stack-drop)
      #+end_src

***** union-cons-den-exe

      #+begin_src cicada
      (+fun union-cons-den-exe
        : (-> env-t, den : union-cons-den-t -- env-t)
        new-scope scope-stack-push
        den.type-arrow-exp.ante-exp-list
        {bind-exp-in-ante} list-map
        den.type-arrow-exp.ante-exp-list
        ante-exp-list->field-obj-dict
        den.name
        (. field-obj-dict name)
        union-type-cr
        field-unify
        data-stack-push
        scope-stack-drop)
      #+end_src

***** data-cons-den-exe

      #+begin_src cicada
      (+fun data-cons-den-exe
        : (-> env-t, den : data-cons-den-t -- env-t)
        new-scope scope-stack-push
        den.type-arrow-exp.ante-exp-list
        {bind-exp-in-ante} list-map
        den.type-arrow-exp.ante-exp-list
        ante-exp-list->field-obj-dict
        den.name cons-name->type-name
        (. field-obj-dict name)
        data-type-cr
        (let data-type)
        den.cons-arrow-exp.ante-exp-list
        {bind-exp-in-ante} list-map
        den.cons-arrow-exp.ante-exp-list
        ante-exp-list->field-obj-dict
        data-type
        (. field-obj-dict data-type)
        data-obj-cr
        field-unify
        data-stack-push
        scope-stack-drop)
      #+end_src

***** cons-name->type-name

      #+begin_src cicada
      (+fun cons-name->type-name
        : (-> string-t -- string-t)
        dup string-length number-dec
        string-take
        "t" string-append)
      #+end_src

***** ante-exp-list->field-obj-dict

      #+begin_src cicada
      (+fun ante-exp-list->field-obj-dict
        : (-> env-t, exp-u list-u
           -- env-t, string-t obj-u dict-t)
        (lit-dict)
        {(let exp dict)
         (case exp
           (colon-exp-t
             exp.name local-get (let obj)
             dict exp.name obj dict-insert)
           (else dict))}
        list-foldr)
      #+end_src

***** bind-exp-in-ante

      #+begin_src cicada
      (+fun bind-exp-in-ante
        : (-> env-t, exp : exp-u -- env-t)
        (case exp
          (colon-exp-t
            exp.type-exp-list exp-list-collect-one
            exp.name bind-obj-to-name)
          (double-colon-exp-t
            exp.type-exp-list exp-list-collect-one
            exp.name bind-obj-to-name)
          (else)))
      #+end_src

***** >< bind-obj-to-name

      #+begin_src cicada
      (+fun bind-obj-to-name
        : (-> env-t
              obj : obj-u
              name : string-t
              -- env-t)
        new-hypo-id data-hypo-c name local-let
        name local-get infer obj
        ><><><
        (unless obj-unify
          "- bind-obj-to-name fail to unify" p nl
          error))
      #+end_src

***** >< obj-unify

      #+begin_src cicada
      (+fun obj-unify
        : (-> env-t
              x : obj-u
              y : obj-u
           -- env-t maybe-u)
        (case x
          (data-obj-t
            (case y
              (data-obj-t
                (do (maybe-bind
                     maybe-return)
                  (bind x.data-type
                        y.data-type
                        recur)
                  (bind x.field-obj-dict
                        y.field-obj-dict
                        field-obj-dict-unify)))
              (else )))
          (data-type-t
            (case y
              (data-type-t)
              (else )))
          (union-type-t
            (case y
              (union-type-t)
              (else )))
          (type-type-t
            (case y
              (type-type-t)
              (else )))
          (closure-obj-t
            (case y
              (closure-obj-t)
              (else )))
          (arrow-type-t
            (case y
              (arrow-type-t)
              (else )))
          (data-hypo-t
            (case y
              (data-hypo-t)
              (else )))
          (type-hypo-t
            (case y
              (data-hypo-t)
              (else )))))
      #+end_src

***** >< new-hypo-id

      #+begin_src cicada
      (+fun new-hypo-id
        : (-> env-t -- env-t, hypo-id-t)
        )
      #+end_src

***** >< infer

      #+begin_src cicada
      (+fun infer
        : (-> env-t -- env-t)
        )
      #+end_src

***** local-let

      #+begin_src cicada
      (+fun local-let
        : (-> env-t, obj-u, string-t -- env-t)
        swap current-scope-insert)
      #+end_src

***** local-get

      #+begin_src cicada
      (+fun local-get
        : (-> env-t, string-t -- env-t, obj-u)
        current-scope-get)
      #+end_src

***** >< field-unify

      #+begin_src cicada
      (+fun field-unify
        : (-> env-t, obj-u
           -- env-t, obj-u, bool-u)
        )
      #+end_src

***** [note] [zero-c null-c cons-c] by hand

      #+begin_src cicada
      (note
        zero-c null-c cons-c

        (note for [zero-c]
          (with-local-scope
            (@data-type-t
              (name "zero-t")
              (field-obj-dict (@)))
            (let data-type)
            (@data-obj-t
              (data-type data-type)
              (field-obj-dict (@)))
            (let zero)))

        (note for [null-c]
          (with-local-scope
            0 hypo-id-c data-hypo-c (quote type) local-let
            (quote type) local-get infer
            type-tt
            obj-unify
            (@data-type-t
              (name "null-t")
              (field-obj-dict (@ (type (quote type) local-get))))
            (let data-type)
            (@data-obj-t
              (data-type data-type)
              (field-obj-dict (@)))
            (let null)))

        (note for [zero null cons-c]
          (with-local-scope
            1 hypo-id-c data-hypo-c (quote type) local-let
            (quote type) local-get infer
            type-tt
            obj-unify
            (@data-type-t
              (name "cons-t")
              (field-obj-dict (@ (type (quote type) local-get))))
            (let data-type)
            2 hypo-id-c data-hypo-c (quote car) local-let
            (quote car) local-get infer
            (quote type) local-get
            obj-unify
            3 hypo-id-c data-hypo-c (quote cdr) local-let
            (quote cdr) local-get infer
            (with-local-scope
              4 hypo-id-c data-type-c (quote type) local-let
              (quote type) local-get infer
              obj-unify
              (@union-type-t
                (name "list-u")
                (field-obj-dict (@ (type (quote type) local-get)))))
            field-unify
            obj-unify
            (@data-obj-t
              (data-type data-type)
              (field-obj-dict
               (@ (car (quote car) local-get)
                  (cdr (quote cdr) local-get))))
            (let cons)))

        (note gc on hypo should be started at the end of every -c))
      #+end_src

*** let-exp-exe

    #+begin_src cicada
    (+fun let-exp-exe
      : (-> env-t, exp : let-exp-t -- env-t)
      exp.name-list list-reverse
      let-exp-exe-loop)

    (+fun let-exp-exe-loop
      : (-> env-t, name-list : [string-t list-u] -- env-t)
      (case name-list
        (null-t)
        (cons-t
          data-stack-pop (let obj)
          scope-stack-pop
          name-list.car obj scope-insert
          scope-stack-push
          name-list.cdr recur)))
    #+end_src

*** closure-exp-exe

    #+begin_src cicada
    (+fun closure-exp-exe
      : (-> env-t, exp : closure-exp-t -- env-t)
      scope-stack-tos
      exp.body-exp-list
      (. scope body-exp-list)
      closure-obj-cr
      data-stack-push)
    #+end_src

*** arrow-exp-exe

    #+begin_src cicada
    (+fun arrow-exp-exe
      : (-> env-t, exp : arrow-exp-t -- env-t)
      ;; calling collect-many
      ;;   might effect current scope
      exp.ante-exp-list exp-list-collect-many (let ante-type-list)
      exp.succ-exp-list exp-list-collect-many (let succ-type-list)
      ante-type-list succ-type-list
      arrow-type-c
      data-stack-push)
    #+end_src

*** apply-exp-exe

    #+begin_src cicada
    (+fun apply-exp-exe
      : (-> env-t, exp : apply-exp-t -- env-t)
      apply-exp-ins)
    #+end_src

*** apply-exp-ins

    #+begin_src cicada
    (+fun apply-exp-ins
      : (-> env-t -- env-t)
      data-stack-pop (let obj)
      (case obj
        (closure-obj-t
          obj.scope scope-stack-push
          obj.body-exp-list new-scoping-frame frame-stack-push)))
    #+end_src

*** case-exp-exe

    #+begin_src cicada
    (+fun case-exp-exe
      : (-> env-t, exp : case-exp-t -- env-t)
      ;; calling collect-one
      ;;   might effect current scope
      exp.arg-exp-list exp-list-collect-one (let obj)
      ;; "- case-exp-exe" p nl
      ;; "  obj : " p obj p nl
      (case obj
        (data-obj-t
          exp.closure-exp-dict
          obj.data-type.name dict-get
          closure-exp-exe
          apply-exp-ins)))
    #+end_src

*** field-exp-exe

    #+begin_src cicada
    (+fun field-exp-exe
      : (-> env-t, exp : field-exp-t -- env-t)
      data-stack-pop (let obj)
      (case obj
        (data-obj-t
          obj.field-obj-dict
          exp.field-name dict-get
          data-stack-push)))
    #+end_src

*** colon-exp-exe

    #+begin_src cicada
    (+fun colon-exp-exe
      : (-> env-t, exp : colon-exp-t -- env-t)
      exp.type-exp-list exp-list-collect-one (let type)
      exp.name generate-hypo-id (let hypo-id)
      hypo-id type type-bind-dict-insert
      exp.name hypo-id data-hypo-c current-scope-insert
      type data-stack-push)
    #+end_src

*** double-colon-exp-exe

    #+begin_src cicada
    (+fun double-colon-exp-exe
      : (-> env-t double-colon-exp-t -- env-t)
      colon-exp-exe
      data-stack-drop)
    #+end_src

*** counter-t

    #+begin_src cicada
    (+type counter-t
      number : number-t)
    #+end_src

*** new-counter

    #+begin_src cicada
    (+fun new-counter
      : (-> -- counter-t)
      0 counter-c)
    #+end_src

*** counter-inc

    #+begin_src cicada
    (+fun counter-inc
      : (-> counter-t --)
      dup .number inc
      swap .number!)
    #+end_src

*** counter-number

    #+begin_src cicada
    (+fun counter-number
      : (-> counter-t -- number-t)
      .number)
    #+end_src

*** generate-hypo-id

    #+begin_src cicada
    (+var hypo-id-counter new-counter)

    (+fun generate-hypo-id
      : (-> env-t, base-name : string-t
         -- env-t, hypo-id-t)
      hypo-id-counter counter-number repr (let postfix)
      hypo-id-counter counter-inc
      base-name postfix string-append hypo-id-c)
    #+end_src

*** begin-exp-exe

    #+begin_src cicada
    (+fun begin-exp-exe
      : (-> env-t, exp : begin-exp-t -- env-t)
      exp.body begin-exp-exe-loop)

    (+fun begin-exp-exe-loop
      : (-> env-t, exp-list : [exp-u list-u] -- env-t)
      (case exp-list
        (null-t)
        (cons-t
          exp-list.car exp
          exp-list.cdr recur)))
    #+end_src

*** comma-exp-exe

    #+begin_src cicada
    (+fun comma-exp-exe
      : (-> env-t comma-exp-t -- env-t)
      drop)
    #+end_src

*** type-tt-exp-exe

    #+begin_src cicada
    (+fun type-tt-exp-exe
      : (-> env-t type-tt-exp-t -- env-t)
      drop
      2 type-type-c
      data-stack-push)
    #+end_src

* >< mutli-exe

*** ><

    #+begin_src cicada

    #+end_src

* run

*** run-one-step

    #+begin_src cicada
    (+fun run-one-step
      : (-> env-t -- env-t)
      (if top-frame-finished-p
        (case frame-stack-pop
          (scoping-frame-t scope-stack-drop)
          (simple-frame-t))
        [top-frame-next-exp exe]))
    #+end_src

*** run-with-base

    #+begin_src cicada
    (+fun run-with-base
      : (-> env-t, base : number-t -- env-t)
      (unless [dup .frame-stack list-length base eq-p]
        run-one-step base recur))
    #+end_src

*** exp-list-run

    #+begin_src cicada
    (+fun exp-list-run
      : (-> env-t, exp-list : [exp-u list-u] -- env-t)
      dup .frame-stack list-length (let base)
      exp-list new-simple-frame frame-stack-push
      base run-with-base)
    #+end_src

*** exp-run

    #+begin_src cicada
    (+fun exp-run
      : (-> env-t, exp-u -- env-t)
      null-c cons-c exp-list-run)
    #+end_src

* collect

*** exp-list-collect-many

    #+begin_src cicada
    (+fun exp-list-collect-many
      : (-> env-t, exp-list : [exp-u list-u]
         -- env-t, obj-u list-u)
      dup .data-stack list-length (let old)
      exp-list exp-list-run
      dup .data-stack list-length (let new)
      new old sub data-stack-n-pop)
    #+end_src

*** exp-list-collect-one

    #+begin_src cicada
    (+fun exp-list-collect-one
      : (-> env-t, exp-list : [exp-u list-u]
         -- env-t, obj-u)
      exp-list exp-list-run
      data-stack-pop)
    #+end_src

*** exp-collect-one

    #+begin_src cicada
    (+fun exp-collect-one
      : (-> env-t, exp : exp-u
         -- env-t, obj-u)
      exp null-c cons-c exp-list-run
      data-stack-pop)
    #+end_src

* cut

*** cut

    #+begin_src cicada
    (+fun cut
      : (-> env-t exp-u -- env-t)
      (case dup
        (call-exp-t call-exp-cut)
        (let-exp-t let-exp-cut)
        (closure-exp-t closure-exp-cut)
        (arrow-exp-t arrow-exp-cut)
        (apply-exp-t apply-exp-cut)
        (case-exp-t case-exp-cut)
        (field-exp-t field-exp-cut)
        (colon-exp-t colon-exp-cut)
        (double-colon-exp-t double-colon-exp-cut)))
    #+end_src

*** call-exp-cut

    #+begin_src cicada
    (+fun call-exp-cut
      : (-> env-t, exp : call-exp-t -- env-t)
      exp.name name-dict-get den-cut)
    #+end_src

*** den-cut

***** den-cut

      #+begin_src cicada
      (+fun den-cut
        : (-> env-t den-u -- env-t)
        (case dup
          (fun-den-t fun-den-cut)
          (type-cons-den-t type-cons-den-cut)
          (union-cons-den-t union-cons-den-cut)))
      #+end_src

***** fun-den-cut

      #+begin_src cicada
      (+fun fun-den-cut
        : (-> env-t, den : fun-den-t -- env-t)
        den.type-arrow-exp arrow-exp-cut-apply)
      #+end_src

***** arrow-exp-cut-apply

      #+begin_src cicada
      (+fun arrow-exp-cut-apply
        : (-> env-t, arrow-exp : arrow-exp-t -- env-t)
        ;; must create a new scope
        ;;   before creating an arrow-type
        ;; because creating an arrow-type
        ;;   might effect current scope
        new-scope scope-stack-push
        arrow-exp exp-collect-one (let arrow-type)
        arrow-type.ante-type-list ante-type-list-unify
        arrow-type.succ-type-list data-stack-list-push
        scope-stack-drop)
      #+end_src

***** >< ante-type-list-unify

      #+begin_src cicada
      (+fun ante-type-list-unify
        : (-> env-t, ante-type-list : [obj-u list-u] -- env-t)
        )
      #+end_src

***** ><><>< type-cons-den-cut

      #+begin_src cicada
      (+fun type-cons-den-cut
        : (-> env-t, den : type-cons-den-t -- env-t)
        )
      #+end_src

***** ><><>< union-cons-den-cut

      #+begin_src cicada
      (+fun union-cons-den-cut
        : (-> env-t, den : union-cons-den-t -- env-t)
        )
      #+end_src

*** let-exp-cut

*** closure-exp-cut

*** arrow-exp-cut

*** apply-exp-cut

*** case-exp-cut

*** construct-exp-cut

*** field-exp-cut

*** colon-exp-cut

*** double-colon-exp-cut

* >< mutli-cut

*** ><

    #+begin_src cicada

    #+end_src

* infer

*** infer

    #+begin_src cicada
    (+fun infer
      : (-> env-t obj-u -- obj-u env-t)
      (case dup
        (data-obj-t data-obj-infer)
        (closure-obj-t closure-obj-infer)
        ;; ><><><
        (obj-u type-infer)))
    #+end_src

*** data-obj-infer

*** closure-obj-infer

*** type-infer

* unfiy

* cover

* check

* sexp

*** sexp-u

    #+begin_src cicada
    (+alias sexp-u (+ string-t | sexp-u list-u))
    #+end_src

* pass

*** sexp-list-pass

    #+begin_src cicada
    (+fun sexp-list-pass
      : (-> sexp-u list-u -- sexp-u list-u)
      ;; the order matters
      {sexp-pass-for-recur} list-map
      sexp-list-remove-infix-notation
      sexp-list-expand-multi-bind
      {sexp-pass-for-arrow} list-map
      sexp-list-pass-to-break-dot-string)
    #+end_src

*** sexp-pass-for-recur

    #+begin_src cicada
    (+fun sexp-pass-for-recur
      : (-> sexp : sexp-u -- sexp-u)
      (if (and [sexp cons-p]
               [sexp.car '+fun eq-p])
        [sexp.cdr.car (let name)
         sexp.cdr.cdr (let body)
         (lit-list sexp.car name)
         body name sexp-substitute-recur
         list-append]
        sexp))

    (+fun sexp-substitute-recur
      : (-> sexp : sexp-u, name : string-t -- sexp-u)
      (cond
        (and [sexp string-p] [sexp "recur" eq-p]) name
        [sexp cons-p] [sexp.car name recur
                       sexp.cdr name recur cons-c]
        else sexp))
    #+end_src

*** sexp-list-remove-infix-notation

    - <sexp> : <sexp> => (: <sexp> <sexp>)

    #+begin_src cicada
    (+fun sexp-list-remove-infix-notation
      : (-> sexp-list : [sexp-u list-u] -- sexp-u list-u)
      (cond [sexp-list list-length 3 lt-p]
            [sexp-list {sexp-remove-infix-notation} list-map]

            (or [sexp-list.cdr.car ': eq-p]
                [sexp-list.cdr.car ':: eq-p])
            [sexp-list.cdr.cdr.cdr recur
             (lit-list
              sexp-list.cdr.car
              sexp-list.car sexp-remove-infix-notation
              sexp-list.cdr.cdr.car sexp-remove-infix-notation)
             swap cons-c]

            else
            [sexp-list.cdr recur
             sexp-list.car sexp-remove-infix-notation
             swap cons-c]))

    (+fun sexp-remove-infix-notation
      : (-> sexp-u -- sexp-u)
      dup cons-p (bool-when sexp-list-remove-infix-notation))
    #+end_src

*** sexp-list-expand-multi-bind

    - (: [m n] nat-u) => (: n nat-u) (: n nat-u)

    #+begin_src cicada
    (+fun sexp-list-expand-multi-bind
      : (-> sexp-list : [sexp-u list-u] -- sexp-u list-u)
      (case sexp-list
        (null-t null-c)
        (cons-t
          (cond
            [sexp-list.car multi-bind-colon-sexp-p]
            [sexp-list.car colon-sexp-head (let head)
             sexp-list.car colon-sexp-type (let type)
             sexp-list.car colon-sexp-multi-bind-list
             {(let name) `((@ head name type))} list-map
             sexp-list.cdr recur
             list-append]
            else
            [sexp-list.cdr recur
             sexp-list.car sexp-expand-multi-bind
             swap cons-c]))))

    (+fun sexp-expand-multi-bind
      : (-> sexp-u -- sexp-u)
      dup cons-p (bool-when sexp-list-expand-multi-bind))

    (+fun colon-sexp-p
      : (-> sexp : sexp-u -- bool-u)
      (and [sexp cons-p]
           (or [sexp.car ': eq-p]
               [sexp.car ':: eq-p])))

    (+fun multi-bind-colon-sexp-p
      : (-> sexp : sexp-u -- bool-u)
      (and [sexp colon-sexp-p]
           [sexp.cdr.car cons-p]
           [sexp.cdr.car.car 'begin eq-p]))

    (+fun colon-sexp-multi-bind-list
      : (-> sexp : sexp-u -- string-t list-u)
      sexp.cdr.car
      .cdr)

    (+fun colon-sexp-head
      : (-> sexp : sexp-u -- sexp-u)
      sexp.car)

    (+fun colon-sexp-type
      : (-> sexp : sexp-u -- sexp-u)
      sexp.cdr.cdr.car)
    #+end_src

*** sexp-pass-for-arrow

    - (-> ... -- ...) => (arrow (...) (...))

    #+begin_src cicada
    (+fun sexp-pass-for-arrow
      : (-> sexp : sexp-u -- sexp-u)
      (case sexp
        (cons-t
          (if [sexp.car '-> eq-p]
            [sexp.cdr {'-- eq-p} list-split-to-two (let ante succ)
             `(arrow (@ ante {recur} list-map)
                     (@ succ.cdr {recur} list-map))]
            [sexp {recur} list-map]))
        (else sexp)))
    #+end_src

*** sexp-list-pass-to-break-dot-string

    #+begin_src cicada
    (+fun sexp-list-pass-to-break-dot-string
      : (-> sexp-list : [sexp-u list-u] -- sexp-u list-u)
      (case sexp-list
        (null-t null-c)
        (cons-t
          (cond
            (and [sexp-list.car string-p]
                 [sexp-list.car dot-string-p])
            [sexp-list.car '. string-split-by-char (let name-list)
             name-list.cdr {'. swap string-append} list-map
             name-list.car swap cons-c
             sexp-list.cdr recur
             list-append]
            else
            [sexp-list.cdr recur
             sexp-list.car sexp-pass-to-break-dot-string
             swap cons-c]))))

    (+fun sexp-pass-to-break-dot-string
      : (-> sexp-u -- sexp-u)
      dup cons-p (bool-when sexp-list-pass-to-break-dot-string))

    (+fun dot-string-p
      : (-> string : string-u -- bool-u)
      (and [string string-head '. eq-p not]
           [string string-last '. eq-p not]
           [string '. string-member-p]))
    #+end_src

* parse

*** parse-den

***** parse-den

      #+begin_src cicada
      (+fun parse-den
        : (-> sexp : sexp-u -- den-u)
        sexp.car (let head)
        sexp.cdr (let body)
        (cond
          [head '+fun eq-p] [body parse-fun-den]
          [head '+type eq-p] [body parse-type-cons-den]
          [head '+union eq-p] [body parse-union-cons-den]
          else error))
      #+end_src

***** parse-fun-den

      #+begin_src cicada
      (+fun parse-fun-den
        : (-> body : [sexp-u list-u] -- den-u)
        body.car parse-exp (let colon-exp)
        body.cdr {parse-exp} list-map (let body-exp-list)
        colon-exp.name (let name)
        colon-exp.type-exp-list.car (let type-exp)
        (case type-exp
          (arrow-exp-t type-exp)
          (else (lit-list) (lit-list type-exp) arrow-exp-c))
        (let type-arrow-exp)
        name type-arrow-exp body-exp-list fun-den-c)
      #+end_src

***** parse-type-cons-den

      #+begin_src cicada
      (+fun parse-type-cons-den
        : (-> body : [sexp-u list-u] -- den-u)
        body.car parse-exp (let colon-exp)
        body.cdr {parse-exp} list-map .car (let cons-arrow-exp)
        colon-exp.name (let name)
        colon-exp.type-exp-list.car (let type-exp)
        (case type-exp
          (arrow-exp-t type-exp)
          (else (lit-list) (lit-list type-exp) arrow-exp-c))
        (let type-arrow-exp)
        name type-arrow-exp cons-arrow-exp type-cons-den-c)
      #+end_src

***** parse-union-cons-den

      #+begin_src cicada
      (+fun parse-union-cons-den
        : (-> body : [sexp-u list-u] -- den-u)
        body.car parse-exp (let colon-exp)
        body.cdr (let sub-name-list)
        colon-exp.name (let name)
        colon-exp.type-exp-list.car (let type-exp)
        (case type-exp
          (arrow-exp-t type-exp)
          (else (lit-list) (lit-list type-exp) arrow-exp-c))
        (let type-arrow-exp)
        name type-arrow-exp sub-name-list union-cons-den-c)
      #+end_src

*** parse-exp

    #+begin_src cicada
    (+fun parse-exp
      : (-> sexp : sexp-u -- exp-u)
      (if [sexp string-p]
        [sexp string-parse-exp]
        [sexp.car (let head)
         sexp.cdr (let body)
         (cond
           [head 'let eq-p]
           [body {recur} list-map let-exp-c]

           [head 'closure eq-p]
           [body {recur} list-map closure-exp-c]

           [head 'arrow eq-p]
           [body list-spread
            {recur} list-map swap
            {recur} list-map swap
            arrow-exp-c]

           [head 'case eq-p]
           [new-dict
            body.cdr
            {(let clause)
             clause.cdr {recur} list-map closure-exp-c
             clause.car swap dict-insert}
            list-for-each
            (lit-list body.car recur)
            swap case-exp-c]

           [head 'begin eq-p]
           [body {recur} list-map
            begin-exp-c]

           [head ': eq-p]
           [body.car
            body.cdr {recur} list-map
            colon-exp-c]

           [head ':: eq-p]
           [body.car
            body.cdr {recur} list-map
            double-colon-exp-c]

           else error)]))
    #+end_src

*** string-parse-exp

    #+begin_src cicada
    (+fun string-parse-exp
      : (-> string : string-u -- exp-u)
      (cond
        [string 'apply eq-p]
        [apply-exp-c]

        [string 'type-tt eq-p]
        [type-tt-exp-c]

        [string ', eq-p]
        [comma-exp-c]

        [string field-string-p]
        [string field-string->field-name field-exp-c]

        [string name-string-p]
        [string call-exp-c]

        else
        [error]))


    (+fun field-string-p
      : (-> string-u -- bool-u)
      string-head '. eq-p)

    (+fun field-string->field-name
      : (-> string-u -- string-u)
      string-tail)

    (+fun name-string-p
      : (-> string : string-u -- bool-u)
      string '. string-member-p not)
    #+end_src

* eval

*** top-sexp-list-eval

    #+begin_src cicada
    (+fun top-sexp-list-eval
      : (-> env-t, sexp-list : [sexp-u list-u] -- env-t)
      (case sexp-list
        (null-t)
        (cons-t
          sexp-list.car top-sexp-eval
          sexp-list.cdr recur)))
    #+end_src

*** top-sexp-eval

    #+begin_src cicada
    (+fun top-sexp-eval
      : (-> env-t, sexp : sexp-u -- env-t)
      (cond
        [sexp sexp-den-p]
        [sexp parse-den den-define]
        else [sexp parse-exp exp-run]))
    #+end_src

*** den-define

    #+begin_src cicada
    (+fun den-define
      : (-> env-t, den : den-u -- env-t)
      (case den
        (fun-den-t den.name den name-dict-insert)
        (type-cons-den-t den.name den name-dict-insert
          den.name
          dup string-length dec dec
          0 swap string-slice
          "-c" string-append
          den.type-arrow-exp
          den.cons-arrow-exp
          data-cons-den-c
          dup .name swap name-dict-insert)
        (union-cons-den-t den.name den name-dict-insert)))
    #+end_src

*** sexp-den-p

    #+begin_src cicada
    (+fun sexp-den-p
      : (-> sexp : sexp-u -- bool-u)
      (and [sexp cons-p]
           (or [sexp.car '+fun eq-p]
               [sexp.car '+type eq-p]
               [sexp.car '+union eq-p])))
    #+end_src

* interface

*** (cicada-language)

    #+begin_src cicada
    (+macro cicada-language
      (-> body : [sexp-u list-u] -- sexp-u)
      `(begin
         new-env (quote (@ body))
         sexp-list-pass
         top-sexp-list-eval))
    #+end_src

*** env-print

***** env-print

      #+begin_src cicada
      (+fun env-print
        : (-> env-t -- env-t)
        name-dict-print
        goal-stack-print
        ;; data-bind-dict-print
        ;; type-bind-dict-print
        scope-stack-print
        frame-stack-print
        data-stack-print)
      #+end_src

***** name-dict-print

      #+begin_src cicada
      (+fun name-dict-print
        : (-> env-t -- env-t)
        "- name-dict : " p nl
        dup .name-dict
        {(let key den)
         "  " p den den-print nl}
        dict-for-each
        nl)
      #+end_src

***** data-stack-print

      #+begin_src cicada
      (+fun data-stack-print
        : (-> env-t -- env-t)
        "- data-stack : " p nl
        dup .data-stack list-reverse
        {"  " p obj-print nl}
        list-for-each
        nl)
      #+end_src

***** frame-stack-print

      #+begin_src cicada
      (+fun frame-stack-print
        : (-> env-t -- env-t)
        "- frame-stack : " p nl
        dup .frame-stack
        {"  " p p nl}
        list-for-each
        nl)
      #+end_src

***** scope-stack-print

      #+begin_src cicada
      (+fun scope-stack-print
        : (-> env-t -- env-t)
        "- scope-stack : " p nl
        dup .scope-stack
        {"  " p p nl}
        list-for-each
        nl)
      #+end_src

***** >< goal-stack-print

      #+begin_src cicada
      (+fun goal-stack-print
        : (-> env-t -- env-t)
        ;; "- goal-stack : " p nl
        )
      #+end_src

***** data-bind-dict-print

      #+begin_src cicada
      (+fun data-bind-dict-print
        : (-> env-t -- env-t)
        "- data-bind-dict : " p nl
        dup .data-bind-dict
        {(let hypo-id obj)
         "  " p hypo-id.string p
         " = " p obj obj-print nl}
        dict-for-each
        nl)
      #+end_src

***** type-bind-dict-print

      #+begin_src cicada
      (+fun type-bind-dict-print
        : (-> env-t -- env-t)
        "- type-bind-dict : " p nl
        dup .type-bind-dict
        {(let hypo-id obj)
         "  " p hypo-id.string p
         " = " p obj obj-print nl}
        dict-for-each
        nl)
      #+end_src

*** obj-print

***** obj-print

      #+begin_src cicada
      (+fun obj-print
        : (-> env-t, obj : obj-u -- env-t)
        (case obj
          (data-obj-t
            obj.field-obj-dict obj.data-type.name
            dup string-length 2 sub string-take
            "-c" string-append
            cons-print)
          (data-type-t
            obj.field-obj-dict obj.name cons-print)
          (union-type-t
            obj.field-obj-dict obj.name cons-print)
          (type-type-t
            (cond [obj.level 2 eq-p] ["type-tt" p]
                  [obj.level 3 eq-p] ["type-ttt" p]
                  [else] ["type-<" p obj.level p ">" p]))
          (closure-obj-t obj p)
          (arrow-type-t obj p)
          (data-hypo-t obj p)
          (type-hypo-t obj p)))
      #+end_src

***** cons-print

      #+begin_src cicada
      (+fun cons-print
        : (-> env-t
              dict : [string-t obj-u dict-t]
              name : string-t
           -- env-t)
        (unless [dict dict-empty-p]
          name name-dict-get cons-den->field-name-list
          {dict swap dict-get obj-print " " p}
          list-for-each)
        name p)
      #+end_src

***** cons-den->field-name-list

      #+begin_src cicada
      (+fun cons-den->field-name-list
        : (-> cons-den : den-u -- string-t list-u)
        (case cons-den
          (data-cons-den-t
            cons-den.cons-arrow-exp.ante-exp-list
            exp-list->field-name-list)
          (type-cons-den-t
            cons-den.type-arrow-exp.ante-exp-list
            exp-list->field-name-list)
          (union-cons-den-t
            cons-den.type-arrow-exp.ante-exp-list
            exp-list->field-name-list)))
      #+end_src

***** exp-list->field-name-list

      #+begin_src cicada
      (+fun exp-list->field-name-list
        : (-> exp-list : [exp-u list-u] -- string-t list-u)
        (case exp-list
          (null-t null-c)
          (cons-t
            (case exp-list.car
              (colon-exp-t
                exp-list.car.name
                exp-list.cdr recur
                cons-c)
              (else
                exp-list.cdr recur)))))
      #+end_src

*** den-print

***** den-print

      #+begin_src cicada
      (+fun den-print
        : (-> env-t, den : den-u -- env-t)
        (case den
          (fun-den-t
            "+fun " p den.name p nl
            den.type-arrow-exp type-arrow-exp-print-for-den
            "   " p den.body-exp-list
            exp-list-print nl)
          (data-cons-den-t
            "+data-cons " p den.name p nl
            den.cons-arrow-exp type-arrow-exp-print-for-den)
          (type-cons-den-t
            "+type-cons " p den.name p nl
            den.type-arrow-exp type-arrow-exp-print-for-den)
          (union-cons-den-t
            "+union-cons " p den.name p nl
            den.type-arrow-exp type-arrow-exp-print-for-den)))
      #+end_src

***** type-arrow-exp-print-for-den

      #+begin_src cicada
      (+fun type-arrow-exp-print-for-den
        : (-> type-arrow-exp : arrow-exp-t --)
        "   : -> " p
        type-arrow-exp.ante-exp-list
        exp-list-print
        nl
        "     -- " p
        type-arrow-exp.succ-exp-list
        exp-list-print
        nl)
      #+end_src

*** exp-print

    #+begin_src cicada
    (+fun exp-print
      : (-> exp : exp-u --)
      (case exp
        (call-exp-t
          exp.name p)
        (let-exp-t
          exp.name-list p)
        (closure-exp-t
          ;; ><><><
          exp p)
        (arrow-exp-t
          ;; ><><><
          exp p)
        (apply-exp-t
          "apply" p)
        (case-exp-t
          "case " p exp.arg-exp-list exp-list-print nl
          exp.closure-exp-dict
          {(let name closure-exp)
           "    " p name p " " p
           closure-exp.body-exp-list exp-list-print nl}
          dict-for-each)
        (field-exp-t
          "." p exp.field-name p)
        (colon-exp-t
          "(: " p exp.name p " " p
          exp.type-exp-list exp-list-print ")" p)
        (double-colon-exp-t
          "(:: " p exp.name p " " p
          exp.type-exp-list exp-list-print ")" p)
        (comma-exp-t)
        (type-tt-exp-t
          "type-tt" p)
        (else exp p)))
    #+end_src

*** exp-list-print

    #+begin_src cicada
    (+fun exp-list-print
      : (-> exp-list : [exp-u list-u] --)
      (case exp-list
        (null-t)
        (cons-t
          (case exp-list.cdr
            (null-t
              exp-list.car exp-print)
            (cons-t
              exp-list.car exp-print " " p
              exp-list.cdr recur)))))
    #+end_src

* test

*** (->)

    #+begin_src cicada
    (assert
      1 2
      : (-> num0 : number-t, num1 : number-t -- number-t)
      num0 num1 add
      3 eq-p)
    #+end_src

*** name-dict

    #+begin_src cicada
    (begin
      new-env
      "1" 1 name-dict-insert
      "2" 2 name-dict-insert
      "1" name-dict-get 1 eq-p bool-assert
      "1" name-dict-get 1 eq-p bool-assert
      "2" name-dict-get 2 eq-p bool-assert
      "2" name-dict-get 2 eq-p bool-assert
      drop)
    #+end_src

*** data-stack

    #+begin_src cicada
    (begin
      new-env
      0 data-stack-push
      1 data-stack-push
      2 data-stack-push
      3 data-stack-push
      data-stack-pop 3 eq-p bool-assert
      data-stack-pop 2 eq-p bool-assert
      data-stack-tos 1 eq-p bool-assert
      data-stack-tos 1 eq-p bool-assert
      data-stack-tos 1 eq-p bool-assert
      data-stack-drop
      data-stack-pop 0 eq-p bool-assert
      drop)

    (begin
      new-env
      0 data-stack-push
      1 data-stack-push
      2 data-stack-push
      3 data-stack-push
      3 data-stack-n-pop
      (lit-list 1 2 3) eq-p bool-assert
      data-stack-pop 0 eq-p bool-assert
      drop)

    (begin
      new-env
      (lit-list 1 2 3) data-stack-list-push
      data-stack-pop 3 eq-p bool-assert
      data-stack-pop 2 eq-p bool-assert
      data-stack-pop 1 eq-p bool-assert
      drop)
    #+end_src

*** >< frame-stack

*** >< frame

*** scope-stack

    #+begin_src cicada
    (begin
      new-env
      0 scope-stack-push
      1 scope-stack-push
      2 scope-stack-push
      3 scope-stack-push
      scope-stack-pop 3 eq-p bool-assert
      scope-stack-pop 2 eq-p bool-assert
      scope-stack-tos 1 eq-p bool-assert
      scope-stack-tos 1 eq-p bool-assert
      scope-stack-tos 1 eq-p bool-assert
      scope-stack-drop
      scope-stack-pop 0 eq-p bool-assert
      drop)
    #+end_src

*** >< scope

*** data-bind-dict & type-bind-dict

    #+begin_src cicada
    (begin
      new-env
      (lit-dict '1 '0) 1 data-bind-dict-insert
      (lit-dict '2 '0) 2 data-bind-dict-insert
      (lit-dict '1 '0) data-bind-dict-find bool-assert 1 eq-p bool-assert
      (lit-dict '1 '0) data-bind-dict-find bool-assert 1 eq-p bool-assert
      (lit-dict '2 '0) data-bind-dict-find bool-assert 2 eq-p bool-assert
      (lit-dict '2 '0) data-bind-dict-find bool-assert 2 eq-p bool-assert
      drop)

    (begin
      new-env
      "1" 1 type-bind-dict-insert
      "2" 2 type-bind-dict-insert
      "1" type-bind-dict-find bool-assert 1 eq-p bool-assert
      "1" type-bind-dict-find bool-assert 1 eq-p bool-assert
      "2" type-bind-dict-find bool-assert 2 eq-p bool-assert
      "2" type-bind-dict-find bool-assert 2 eq-p bool-assert
      drop)
    #+end_src

*** sexp-list-pass

    #+begin_src cicada
    (assert
      '((+union nat-u : type-tt
          (-> -- zero-t)
          (-> prev : nat-u -- succ-t)))
      sexp-list-pass
      '((+union (: nat-u type-tt)
          (arrow () (zero-t))
          (arrow ((: prev nat-u)) (succ-t))))
      eq-p)

    (assert
      '((+fun nat-add : (-> [m n] : nat-u -- nat-u)
          (case n
            (zero-t m)
            (succ-t m n.prev recur succ-c)))

        (+fun nat-mul : (-> [m n] : nat-u -- nat-u)
          (case n
            (zero-t n)
            (succ-t m n.prev recur m nat-add))))
      sexp-list-pass
      '((+fun (: nat-add
                 (arrow ((: m nat-u) (: n nat-u))
                        (nat-u)))
          (case n
            (zero-t m)
            (succ-t m n .prev nat-add succ-c)))

        (+fun (: nat-mul
                 (arrow ((: m nat-u) (: n nat-u))
                        (nat-u)))
          (case n
            (zero-t n)
            (succ-t m n .prev nat-mul m nat-add))))
      eq-p)
    #+end_src

*** parse-exp

    #+begin_src cicada
    (assert
      '((case n
          (zero-t n)
          (succ-t m n.prev nat-mul m nat-add)))
      sexp-list-pass
      {parse-exp} list-map
      (lit-list
       (lit-list "n" call-exp-c)
       (lit-dict
        "succ-t"
        (lit-list
         "m" call-exp-c
         "n" call-exp-c
         "prev" field-exp-c
         "nat-mul" call-exp-c
         "m" call-exp-c
         "nat-add" call-exp-c)
        closure-exp-c,
        "zero-t"
        (lit-list
         "n" call-exp-c)
        closure-exp-c)
       case-exp-c)
      eq-p)
    #+end_src

*** parse-den

    #+begin_src cicada
    #note
    (begin
      '((+fun nat-add : (-> [m n] : nat-u -- nat-u)
          (case n
            (zero-t m)
            (succ-t m n.prev recur succ-c)))

        (+fun nat-mul : (-> [m n] : nat-u -- nat-u)
          (case n
            (zero-t n)
            (succ-t m n.prev recur m nat-add)))

        (+fun nat-factorial : (-> n : nat-u -- nat-u)
          (case n
            (zero-t n succ-c)
            (succ-t n.prev recur n nat-mul))))
      sexp-list-pass
      {parse-den} list-map)
    #+end_src

* epilog

*** play

    #+begin_src cicada
    (begin

      (cicada-language

       (+union bool-u : type-tt
         true-t
         false-t)

       (+type true-t : type-tt
         (-> -- true-t))

       (+type false-t : type-tt
         (-> -- false-t))

       ;; true-c
       ;; false-c
       ;; true-t
       ;; bool-u
       ;; type-tt

       (+union nat-u : type-tt
         zero-t
         succ-t)

       (+type zero-t : type-tt
         (-> -- zero-t))

       (+type succ-t : type-tt
         (-> prev : nat-u -- succ-t))

       (+fun nat-add : (-> [m n] : nat-u -- nat-u)
         (case n
           (zero-t m)
           (succ-t m n.prev recur succ-c)))

       (+fun nat-mul : (-> [m n] : nat-u -- nat-u)
         (case n
           (zero-t n)
           (succ-t m n.prev recur m nat-add)))

       (+fun nat-factorial : (-> n : nat-u -- nat-u)
         (case n
           (zero-t n succ-c)
           (succ-t n.prev recur n nat-mul)))

       zero-c succ-c succ-c succ-c
       zero-c succ-c succ-c succ-c nat-add
       zero-c succ-c succ-c succ-c
       zero-c succ-c succ-c nat-mul
       zero-c succ-c succ-c succ-c nat-factorial

       (+union list-u : (-> type : type-tt -- type-tt)
         null-t
         cons-t)

       (+type null-t : (-> type : type-tt -- type-tt)
         (-> -- type null-t))

       (+type cons-t : (-> type : type-tt -- type-tt)
         (-> car : type
             cdr : [type list-u]
          -- type cons-t))

        nat-u null-t
        nat-u cons-t
        nat-u list-u

        ;; null-c
        )

      env-print
      drop nl
      print-the-stack)
    #+end_src

*** main

    #+begin_src cicada

    #+end_src
