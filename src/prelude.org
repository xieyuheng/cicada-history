#+html_head: <link rel="stylesheet" href="css/org-page.css"/>
#+title: prelude

* [todo-stack]

*** category-category

***** there is no class-category

      - x -
        there is no class-category only category-category

        a class generates a category
        which is an object of category-category

        a class itself is not an object of class-category
        because
        I can not think of how to define morphism between classes

        morphism can only be defined between categories
        generated by classes

        suppose I have defind
        [space-t : class-tt] and [homology-t : class-tt]
        a meaningful morphism between them
        would be something of type (-- space-t -> homology-t)
        but it also need to

      - use natural-transformation to implement arrow-eqv-s of category

      - we do not generate category from class.
        to specify a class-category,
        we need to gave a class and a category.

***** natural-transformation

      - natural-transformation is a level up map.

        the definition of natural-transformation
        maps object to arrow,
        and arrow to square.

***** natural-isomorphism

      - natural-transformation whose ><><>< are isomorphism
        instead of merely morphism

      - natural-isomorphism is eqv-relation between functors

      - eqv-relation between functors
        is specially important
        because homology and homotopy are functors!

*** arrow-eqv-s -- amend `arrow-eqv-relation` for all category

    - arrow-eqv-s must be an eqv-relation-t
      for all hom-set [a b arrow-s]

*** bifunctor

    - checking functorial laws of pair of categories,
      [where pair is Cartesian product]
      is equivalent to
      checking functorial laws for each component of the pair.

      - this is the whole point of Cartesian product

*** can function not be stored in data-field ?

*** set-category

    - surjective

    - injective

    - bijective

*** prove iso for universal-construction

    - a universal-construction is unique up to unique isomorphism

    - we need to use unique to prove eqv

*** representable-functor

*** nat-total-order

*** monad as category

*** dependent-category -- use pullback and pushout

    - maybe we still need to get out of category at the end

    - to open a new mode of explanation

*** topos-theory

*** logic programming

    - what is the logic programming interface of the type system ?

*** new (do) notation

*** use number theory -- to test type-checker as prover

*** sub-set relation in set-t

    - maybe use (<) as syntax

*** algebraic structure

    - (*) and (sum) in set-t
      provide two commutative monoidal structures -- semi-ring-t
      for we canâ€™t define subtraction of types.
      -- a.k.a rig-t, ring without negative.

      - note that, to be monoidal-category,
        the binary operator must also be a bifunctor.

        i.e. the monoidal product must be
        compatible with the structure of the category,
        which is defined by morphisms.

    - order relation for algebraic data type

      for example :
      a < a + b
      a < a * 2

      this can be viewed as a functor from set-t to rational-s

    ------

    - x -
      can we extend the algebraic structure to dependent type ?

    - k -
      we will need to extend the algebraic structure to object

    - x -
      object are just like type.
      just without sum-type, only product-type.

*** should (:) (%) form types too ? -- like eqv-c

* [note]

*** (:) (%)

    - (%) is reversed (:)

*** (*)

    - literal tuple-type -- (* <type> ...)

    - inhabit by literal tuple -- (* <data> ...)

*** (@)

    - product-type with named fields

    - literal record-type -- (@ <field> : <type> ...)

    - inhabited by literal record-data (@ <field> = <data> ...)

*** (union)

    - union of set theory

    - literal union-type -- (union <type> ...)

    - we do not have literal union-data,
      the union-type is inhabited by [<data> : <type>] and so on

*** (data)

    - data-type of type set-t

    - named record-type

    - to inhabit a data-type constructed by type-constructor,
      we call its data-constructor.

      - (<name>-c <data> ...) -- call with order

      - (<name>-c <field> = <data> ...) -- call with field

*** (class)

    - class-type of type class-tt

    - named record-type just like data-type

*** data-type vs class-type

    - they are almost the same,
      only low-level vs high-level.

    - data-type's fields' types are often other data-types.

    - class-type's fields' types are often set-t or arrow-type,
      i.e. of higher levels.

*** (sum)

    - sum-type

    - named data-type list

    - if declares same fields,
      and names a type-constructor for the sum-type.

    - type-constructor of each data-type
      must have the same declared fields and types

    - it can be viewed as disjoin-union,
      because data-types in the list are disjoin.

*** (<:)

    - a class-type or data-type
      can inherit other class-types or data-types,
      bringing in the sub-class relation between them.

    - [c1 <: c2] means c1 inherit c2 's fields,
      thus c1 is more special then c2,
      because c1 has more interface functions than c2.

    - whatever data inhabits c1 also inhabits c2.

*** currying of type-constructor as partial-class-type

    - some of the fields of the a partial-class-type
      are already inhabited by data

    - to inhabited such partial-class-type

    - we only need to inhabit remaining fields

*** level of universe

***** >< accumulative or not ?

***** >< level rule

***** >< searchable-set vs non-searchable-set

***** level table

      | - | data, object                           |
      |---+----------------------------------------|
      | 0 | <data>-s                               |
      |   | data-type, sum-type                    |
      |   | union-type, record-type, tuple-type    |
      |---+----------------------------------------|
      | 1 | set-t, class-t, preorder-t, category-t |
      |---+----------------------------------------|
      | 2 | set-tt, class-tt, category-tt          |

***** level examples

      | 0                     | 1                   | 2               |
      |-----------------------+---------------------+-----------------|
      | nat-s                 | set-t               | set-tt          |
      | (* nat-s nat-s)       | set-t               | set-tt          |
      | [nat-s nat-s]         | [set-t set-s]       | [set-tt set-tt] |
      | (union nat-t, bool-s) | set-t               | set-tt          |
      | (-- nat-s -> nat-s)   | set-t               | set-tt          |
      | list-s                | (-- set-t -> set-s) | set-tt          |

*** implicit-ness

***** builtin level polymorphism

      - we can not really afford to
        split category-t* to category-t and category-tt,
        because we have to redefined so many classes along category-t.

      - instead we assume that when a class is define in one level,
        it is defined for all levels.

        and all the postfix changes
        are handled by the language implicitly.

        - for example, when
          [category-t : class-tt] is defined,
          [category-tt : class-ttt] is also defined.

      - a convention is that
        we only write down the level or levels
        in which the class is most used.

        - for example,
          we define  [category-morphism-tt : class-ttt]
          instead of [category-morphism-t : class-tt]
          and we define [category-category : category-ttt]
          instead of    [category-category : category-tt]

***** >< implicit generic-ness of haskell type-class

      - by maintain a map from type-constructor to class.

      - something like the template of c++.

* void

*** void-s

    #+begin_src cicada
    void-s : set-t
    void-s = sum []
    #+end_src

*** absurd

    #+begin_src cicada
    absurd : -- void-s -> t
    #+end_src

* unit

*** unit-s

    #+begin_src cicada
    unit-s : set-t
    unit-s = data
    #+end_src

*** unit

    #+begin_src cicada
    unit : -- a -> unit-s
    unit a = unit-c
    #+end_src

* bool

*** bool-s

    #+begin_src cicada
    bool-s : set-t
    bool-s = sum [true-s false-s]

    true-s : set-t
    true-s = data

    false-s : set-t
    false-s = data
    #+end_src

* eqv

*** eqv-s

    #+begin_src cicada
    eqv-s : set-t
    eqv-s = data
      [lhs rhs] : t
      lhs = rhs
    #+end_src

*** eqv-apply

    #+begin_src cicada
    eqv-apply :
      -- fun : (-- a -> b)
         (eqv-s x y)
      -> (eqv-s (fun x) (fun y))
    eqv-apply _ _ = eqv-c
    #+end_src

*** eqv-swap

    #+begin_src cicada
    eqv-swap : -- (eqv-s x y) -> (eqv-s y x)
    eqv-swap _ = eqv-c
    #+end_src

*** eqv-compose

    #+begin_src cicada
    eqv-compose : -- (eqv-s x y) (eqv-s y z) -> (eqv-s x z)
    eqv-compose _ _ = eqv-c
    #+end_src

* nat

*** nat-s

    #+begin_src cicada
    nat-s : set-t
    nat-s = sum [zero-s succ-s]

    zero-s : set-t
    zero-s = data

    succ-s : set-t
    succ-s = data
      prev : nat-s
    #+end_src

*** nat-add

    #+begin_src cicada
    nat-add : -- nat-s nat-s -> nat-s
    nat-add x y =
      case x
        zero-s y
        succ-s (succ-c (recur x.prev y))
    #+end_src

*** nat-mul

    #+begin_src cicada
    nat-mul : -- nat-s nat-s -> nat-s
    nat-mul x y =
      case x
        zero-s zero-c
        succ-s (nat-add y (recur x.prev y))
    #+end_src

*** nat-factorial

    #+begin_src cicada
    nat-factorial : -- nat-s -> nat-s
    nat-factorial n =
      case n
        zero-s (succ-c zero-c)
        succ-s (nat-mul n (recur n.prev))
    #+end_src

*** nat-even-p

    #+begin_src cicada
    nat-even-p : -- nat-s -> bool-s
    nat-even-p x =
      case x
        zero-s true-c
        succ-s case x.prev
          zero-s false-c
          succ-s (recur x.prev.prev)
    #+end_src

*** nat-even-s

    #+begin_src cicada
    nat-even-s : set-t
    nat-even-s = sum [zero-even-s even-plus-two-even-s]
      nat : nat-s

    zero-even-s : set-t
    zero-even-s = data
      nat : nat-s
      nat = zero-c

    even-plus-two-even-s : set-t
    even-plus-two-even-s = data
      nat : nat-s
      prev : (nat-even-s m)
      nat = (succ-c (succ-c m))
    #+end_src

*** two-even

    #+begin_src cicada
    two-even : (nat-even-s (succ-c (succ-c zero-c)))
    two-even = (even-plus-two-even-c zero-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    nat-add-associative :
      -- [x y z] : nat-s
      -> (eqv-s
           (nat-add (nat-add x y) z)
           (nat-add x (nat-add y z)))
    nat-add-associative x y z =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev y z))
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    nat-add-commutative :
      -- [x y] : nat-s
      -> (eqv-s
           (nat-add x y)
           (nat-add y x))
    nat-add-commutative x y =
      case x
        zero-s (nat-add-zero-commutative y)
        succ-s
          (eqv-compose
            (eqv-apply succ-c (recur x.prev y))
            (nat-add-succ-commutative y x.prev))
    #+end_src

*** nat-add-zero-commutative

    #+begin_src cicada
    nat-add-zero-commutative :
      -- x : nat-s
      -> (eqv-s
           (nat-add zero-c x)
           (nat-add x zero-c))
    nat-add-zero-commutative x =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev))
    #+end_src

*** nat-add-succ-commutative-1

    #+begin_src cicada
    nat-add-succ-commutative-1 :
      -- [x y] : nat-s
      -> (eqv-s
           (nat-add (succ-c x) y)
           (succ-c (nat-add x y)))
    nat-add-succ-commutative-1 x y =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev y))
    #+end_src

*** nat-add-succ-commutative-2

    #+begin_src cicada
    nat-add-succ-commutative-2 :
      -- [x y] : nat-s
      -> (eqv-s
           (nat-add y (succ-c x))
           (succ-c (nat-add x y)))
    nat-add-succ-commutative-2 x y =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev y))
    #+end_src

* list

*** list-s

    #+begin_src cicada
    list-s : class-t
    list-s = sum [null-s cons-s]
      t : set-t

    null-s : class-t
    null-s = class
      t : set-t

    cons-s : class-t
    cons-s = class
      t : set-t
      car : t
      cdr : (list-s t)
    #+end_src

*** list-length

    #+begin_src cicada
    list-length : -- (list-s t) -> nat-s
    list-length list =
      case list
        null-s zero-c
        cons-s (succ-c (recur list.cdr))
    #+end_src

*** list-append

    #+begin_src cicada
    list-append :
      -- (list-s t)
         (list-s t)
      -> (list-s t)
    list-append ante succ =
      case ante
        null-s succ
        cons-s (cons-c ante.car (recur ante.cdr succ))
    #+end_src

*** list-map

    #+begin_src cicada
    list-map : -- (-- a -> b) (list-s a) -> (list-s b)
    list-map fun list =
      case list
        null-s list
        cons-s (cons-c (fun list.car) (recur fun list.cdr))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    list-remove-first : -- t (list-s t) -> (list-s t)
    list-remove-first x list =
      case list
        null-s list
        cons-s
          if (eq-p list.car x)
          then list.cdr
          else (cons-c list.car (recur list.cdr x))
    #+end_src

*** list-length-s -- re-imp function as relation

    #+begin_src cicada
    list-length-s : set-t
    list-length-s = sum [zero-length-s succ-length-s]
      list : (list-s t)
      length : nat-s


    zero-length-s : set-t
    zero-length-s = data
      list : (list-s t)
      length : nat-s
      list = null-c
      length = zero-c

    succ-length-s : set-t
    succ-length-s = data
      list : (list-s t)
      length : nat-s
      prev : (list-length-s list length)
      list = (cons-c x list)
      length = (succ-c length)
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    list-map-preserve-list-length :
      -- (list-length-s list n)
      -> (list-length-s (list-map fun list) n)
    list-map-preserve-list-length h =
      case h
        zero-length-s h
        succ-length-s (succ-length-c (recur h.prev))
    #+end_src

*** list-append-s -- in prolog

    #+begin_src cicada
    note in prolog, we will have :
      append([], Succ, Succ).
      append([Car | Cdr], Succ, [Car | ResultCdr]):-
        append(Cdr, Succ, ResultCdr).
    #+end_src

*** list-append-s

    #+begin_src cicada
    list-append-s : set-t
    list-append-s = sum [zero-append-s succ-append-s]
      [ante succ result] : (list-s t)

    zero-append-s : set-t
    zero-append-s = data
      [ante succ result] : (list-s t)
      ante = null-c
      result = succ

    succ-append-s : set-t
    succ-append-s = data
      [ante succ result] : (list-s t)
      prev : (list-append-s cdr succ result-cdr)
      ante = (cons-c car cdr)
      result = (cons-c car result-cdr)
    #+end_src

* vect

*** vect-s

    #+begin_src cicada
    vect-s : set-t
    vect-s = sum [null-vect-s cons-vect-t]
      t : set-t
      length : nat-s

    null-vect-s : set-t
    null-vect-s = data
      t : set-t
      length : nat-s
      length = zero-c

    cons-vect-s : set-t
    cons-vect-s = data
      t : set-t
      length : nat-s
      car : t
      cdr : (vect-s t length)
      length = (succ-c length)
    #+end_src

*** vect-append

    #+begin_src cicada
    vect-append :
      -- (vect-s t m)
         (vect-s t n)
      -> (vect-s t (nat-add m n))
    vect-append ante succ =
      case ante
        null-vect-s succ
        cons-vect-s (cons-vect-c ante.car (recur ante.cdr succ))
    #+end_src

*** vect-map

    #+begin_src cicada
    vect-map : -- (-- a -> b) (vect-s a n) -> (vect-s a n)
    vect-map fun list =
      case list
        null-vect-s list
        cons-vect-s (cons-vect-c (fun list.car) (recur fun list.cdr))
    #+end_src

* order

*** preorder

***** preorder-t

      #+begin_src cicada
      note
        preorder is a thin category
        with at most one morphism from an object to another.

      preorder-t : class-tt
      preorder-t = class
        element-s : set-t

        pre-s :
          -- element-s element-s
          -> set-t

        pre-reflexive :
          -- element-s % a
          -> (pre-s a a)

        pre-transitive :
          -- (pre-s a b)
             (pre-s b c)
          -> (pre-s a c)
      #+end_src

*** partial-order

***** partial-order-t

      #+begin_src cicada
      partial-order-t <: preorder-t
      partial-order-t = class
        element-eqv-s :
          -- element-s
             element-s
          -> set-t
        pre-anti-symmetric :
          -- (pre-s a b)
             (pre-s b a)
          -> (element-eqv-s a b)
      #+end_src

*** eqv-relation

***** eqv-relation-t

      #+begin_src cicada
      eqv-relation-t <: preorder-t
      eqv-relation-t = class
        pre-symmetric :
          -- (pre-s a b)
          -> (pre-s b a)
      #+end_src

*** total-order

***** total-order-t

      #+begin_src cicada
      total-order-t <: partial-order-t
      total-order-t = class
        pre-connex :
          -- [a b] : element-s
          -> (union (pre-s a b) (pre-s b a))
      #+end_src

* unique

*** (unique ... under ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s = macro
      (-- y : $t -> ($eqv-s $x y))
    #+end_src

*** (unique ... under ... such-that ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s such-that $theorem  = macro
      * $x $theorem
        -- y : $t
           y $theorem
        -> ($eqv-s $x y)
    #+end_src

* category

*** category-t

    #+begin_src cicada
    category-t : class-tt
    category-t = class
      object-s : set-t
      arrow-s : -- object-s object-s -> set-t
      arrow-eqv-s : -- (arrow-s a b) (arrow-s a b) -> set-t

      identity : -- object-s % a -> (arrow-s a a)

      compose : -- (arrow-s a b) (arrow-s b c) -> (arrow-s a c)

      identity-neutral-left :
        -- (arrow-s a b) % f
        -> (arrow-eqv-s f (compose (identity a) f))

      identity-neutral-right :
        -- (arrow-s a b) % f
        -> (arrow-eqv-s f (compose f (identity b)))

      compose-associative :
        -- (arrow-s a b) % f
           (arrow-s b c) % g
           (arrow-s c d) % h
        -> (arrow-eqv-s
             (compose f (compose g h))
             (compose (compose f g) h))

      arrow-eqv-relation :
        -- [a b] :: object-s
        -> (eqv-relation-t
             element-s = (arrow-s a b)
             pre-s = arrow-eqv-s)
    #+end_src

*** basic relation

***** category.arrow-inverse-s

      #+begin_src cicada
      category.arrow-inverse-s :
        -- (arrow-s a b)
           (arrow-s b a)
        -> set-t
      category.arrow-inverse-s f g =
        * (arrow-eqv-s (compose f g) (identity a))
          (arrow-eqv-s (compose g f) (identity b))
      #+end_src

***** category.isomorphic-object-s

      #+begin_src cicada
      category.isomorphic-object-s : -- object-s object-s -> set-t
      category.isomorphic-object-s a b =
        * (arrow-s a b) % f
          (arrow-s b a) % g
          (arrow-eqv-s (compose f g) (identity a))
          (arrow-eqv-s (compose g f) (identity b))
      #+end_src

*** universal construction

***** category.product-object-s

      #+begin_src cicada
      category.product-object-s :
        -- object-s % a
           object-s % b
           object-s % p
           (arrow-s p a) % pa
           (arrow-s p b) % pb
        -> set-t
      category.product-object-s a b p pa pb =
        -- object-s % q
           (arrow-s q a) % qa
           (arrow-s q b) % qb
        -> unique (arrow-s q p) % qp
           under arrow-eqv-s such-that
             * (arrow-eqv-s qa (compose qp pa))
               (arrow-eqv-s qb (compose qp pb))
      #+end_src

***** category.coproduct-object-s

      #+begin_src cicada
      category.coproduct-object-s :
        -- object-s % a
           object-s % b
           object-s % p
           (arrow-s a p) % ap
           (arrow-s b p) % bp
        -> set-t
      category.product-object-s a b p ap bp =
        -- object-s % q
           (arrow-s a q) % aq
           (arrow-s a q) % bq
        -> unique (arrow-s p q) % pq
           under arrow-eqv-s such-that
             * (arrow-eqv-s aq (compose ap pq))
               (arrow-eqv-s bq (compose bp pq))
      #+end_src

***** category.initial-object-s

      #+begin_src cicada
      category.initial-object-s : -- object-s -> set-t
      category.initial-object-s a =
        -- object-s % b
        -> unique (arrow-s a b) % f under arrow-eqv-s
      #+end_src

***** category.terminal-object-s

      #+begin_src cicada
      category.terminal-object-s : -- object-s -- set-t
      category.terminal-object-s a =
        -- object-s % b
        -> unique (arrow-s b a) % f under arrow-eqv-s
      #+end_src

*** other structure as category

***** preorder.as-category

      #+begin_src cicada
      note
        to view a preorder as a category
        we simple view all arrow of the same type as eqv

      preorder.as-category : category-t
      preorder.as-category = category-c
        object-s = element-s

        arrow-s = pre-s

        arrow-eqv-s _ _ = unit-s

        identity = pre-reflexive

        compose = pre-transitive

        identity-neutral-left _ = unit-c

        identity-neutral-right _ = unit-c

        compose-associative _ _ _ = unit-c
      #+end_src

*** build new category from old category

***** category.opposite

      #+begin_src cicada
      category.opposite : category-t
      category.opposite = category-c
        object-s = this.object-s

        arrow-s :
          -- object-s object-s
          -> set-t
        arrow-s a b = this.arrow-s b a

        arrow-eqv-s :
          -- (this.arrow-s b a) (this.arrow-s b a)
          -> set-t
        arrow-eqv-s = this.arrow-eqv-s

        identity :
          -- object-s % a
          -> (arrow-s a a)
        identity = this.identity

        compose :
          -- (this.arrow-s b a)
             (this.arrow-s c b)
          -> (this.arrow-s c a)
        compose f g = this.compose g f

        identity-neutral-left :
          -- (this.arrow-s b a) % f
          -> (arrow-eqv-s f (this.compose f (identity a)))
        identity-neutral-left = this.identity-neutral-right

        identity-neutral-right :
          -- (this.arrow-s b a) % f
          -> (arrow-eqv-s f (this.compose (identity b) f))
        identity-neutral-right = this.identity-neutral-left

        compose-associative :
          -- (this.arrow-s b a) % f
             (this.arrow-s c b) % g
             (this.arrow-s d c) % h
          -> (arrow-eqv-s
               (this.compose (this.compose h g) f)
               (this.compose h (this.compose g f)))
        compose-associative f g h =
          (this.arrow-eqv-relation.pre-symmetric
            (this.compose-associative h g f))
      #+end_src

***** category-product

      #+begin_src cicada
      category-product : -- category-t category-t -> category-t
      category-product #1 #2 = category-c
        object-s = * #1.object-s #2.object-s

        arrow-s a b =
          * (#1.arrow-s a.1 b.1)
            (#2.arrow-s a.2 b.2)

        arrow-eqv-s lhs rhs =
          * (#1.arrow-eqv-s lhs.1 rhs.1)
            (#2.arrow-eqv-s lhs.2 rhs.2)

        identity a =
          * (#1.identity a.1)
            (#2.identity a.2)

        compose f g =
          * (#1.compose f.1 g.1)
            (#2.compose f.2 g.2)

        identity-neutral-left f =
          * (#1.identity-neutral-left f.1)
            (#2.identity-neutral-left f.2)

        identity-neutral-right f =
          * (#1.identity-neutral-right f.1)
            (#2.identity-neutral-right f.2)

        compose-associative f g h =
          * (#1.compose-associative f.1 g.1 h.1)
            (#2.compose-associative f.2 g.2 h.2)
      #+end_src

* product-closed-category-t

  #+begin_src cicada
  product-closed-category-t <: category-t
  product-closed-category-t = class
    product :
      -- object-s % [a b]
      -> (* object-s % p
            (arrow-s p a) % pa
            (arrow-s p b) % pb
            (product-object-s a b p pa pb))
  #+end_src

* void-category

*** void-arrow-s

    #+begin_src cicada
    void-arrow-s : set-t
    void-arrow-s = data
      [ante succ] : void-s
    #+end_src

*** void-arrow-eqv-s

    #+begin_src cicada
    void-arrow-eqv-s : set-t
    void-arrow-eqv-s = data
      [lhs rhs] : (void-arrow-s a b)
    #+end_src

*** void-category

    #+begin_src cicada
    void-category : category-t
    void-category = category-c
      object-s = void-s
      arrow-s = void-arrow-s
      arrow-eqv-s = void-arrow-eqv-s

      identity :
        -- void-s % a
        -> (void-arrow-s a a)
      identity _ = void-arrow-c

      compose _ _ = void-arrow-c

      identity-neutral-left :
        -- (void-arrow-s a b) % f
        -> (void-arrow-eqv-s f void-arrow-c)
      identity-neutral-left _ = void-arrow-eqv-c

      identity-neutral-right :
        -- (void-arrow-s a b) % f
        -> (void-arrow-eqv-s f void-arrow-c)
      identity-neutral-right _ = void-arrow-eqv-c

      compose-associative :
        -- (void-arrow-s a b) % f
           (void-arrow-s b c) % g
           (void-arrow-s c d) % h
        -> (void-arrow-eqv-s void-arrow-eqv-c void-arrow-eqv-c)
      compose-associative _ _ _ = void-arrow-eqv-c
    #+end_src

* graph-t

*** graph-t

    #+begin_src cicada
    note
      different between graph and category is that,
      composing [linking] two edges does not give you edge but path.

    graph-t : class-tt
    graph-t = class
      node-s : set-t
      edge-s : -- node-s node-s -> set-t
    #+end_src

*** graph.path-s

    #+begin_src cicada
    graph.path-s : set-t
    graph.path-s = sum [graph.node-path-s
                        graph.edge-path-s
                        graph.link-path-s]
      [start end] : node-s

    graph.node-path-s : set-t
    graph.node-path-s = data
      [start end] : node-s
      node : node-s
      start = node
      end = node

    graph.edge-path-s : set-t
    graph.edge-path-s = data
      [start end] : node-s
      edge : (edge-s start end)

    graph.link-path-s : set-t
    graph.link-path-s = data
      [start end] : node-s
      first : (path-s start middle)
      next : (path-s middle end)
    #+end_src

*** graph.path-eqv-s

    #+begin_src cicada
    graph.path-eqv-s : set-t
    graph.path-eqv-s = sum [graph.refl-path-eqv-s
                            graph.node-left-path-eqv-s
                            graph.node-right-path-eqv-s
                            graph.associative-path-eqv-s]
      [lhs rhs] : (path-s a b)

    graph.refl-path-eqv-s : set-t
    graph.refl-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      lhs = p
      lhs = p

    graph.node-left-path-eqv-s : set-t
    graph.node-left-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      lhs = p
      rhs = (link-path-c (node-path-c a) p)

    graph.node-right-path-eqv-s : set-t
    graph.node-right-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      lhs = p
      rhs = (link-path-c p (node-path-c b))

    graph.associative-path-eqv-s : set-t
    graph.associative-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      q : (path-s b c)
      r : (path-s c d)
      lhs = (link-path-c p (link-path-c q r))
      rhs = (link-path-c (link-path-c p q) r)
    #+end_src

*** graph.as-free-category

    #+begin_src cicada
    graph.as-free-category : category-t
    graph.as-free-category = category-c
      object-s = node-s
      arrow-s = path-s
      arrow-eqv-s = path-eqv-s

      identity :
        -- node-s % a
        -> (path-s a a)
      identity = node-path-c

      compose = link-path-c

      identity-neutral-left :
        -- (path-s a b) % f
        -> (path-eqv-s f (link-path-c (node-path-c a) f))
      identity-neutral-left = node-left-path-eqv-c

      identity-neutral-right :
        -- (path-s a b) % f
        -> (path-eqv-s f (link-path-c f (node-path-c b)))
      identity-neutral-right = node-right-path-eqv-c

      compose-associative :
        -- (path-s a b) % f
           (path-s b c) % g
           (path-s c d) % h
        -> (path-eqv-s
             (link-path-c f (link-path-c g h))
             (link-path-c (link-path-c f g) h))
      compose-associative = associative-path-eqv-c
    #+end_src

* nat-order-category

*** nat-lteq-s

    #+begin_src cicada
    nat-lteq-s : set-t
    nat-lteq-s = sum [zero-lteq-s succ-lteq-s]
      [l r] : nat-s

    zero-lteq-s : set-t
    zero-lteq-s = data
      [l r] : nat-s
      l = zero-c

    succ-lteq-s : set-t
    succ-lteq-s = data
      [l r] : nat-s
      prev : (nat-lteq-s x y)
      l = (succ-c x)
      r = (succ-c y)
    #+end_src

*** nat-non-negative

    #+begin_src cicada
    nat-non-negative : -- n : nat-s -> (nat-lteq-s zero-c n)
    nat-non-negative = zero-lteq-c
    #+end_src

*** nat-lteq-reflexive

    #+begin_src cicada
    nat-lteq-reflexive : -- n : nat-s -> (nat-lteq-s n n)
    nat-lteq-reflexive n =
      case n
        zero-s zero-lteq-c
        succ-s (succ-lteq-c (recur n.prev))
    #+end_src

*** nat-lteq-transitive

    #+begin_src cicada
    nat-lteq-transitive :
      -- (nat-lteq-s a b)
         (nat-lteq-s b c)
      -> (nat-lteq-s a c)
    nat-lteq-transitive x y =
      case x
        zero-lteq-s zero-lteq-c
        succ-lteq-s (succ-lteq-c (recur x.prev y.prev))
    #+end_src

*** nat-lt-s

    #+begin_src cicada
    nat-lt-s : -- nat-s nat-s -> set-t
    nat-lt-s l r = (nat-lteq-s (succ-c l) r)
    #+end_src

*** nat-archimedean-property

    #+begin_src cicada
    nat-archimedean-property :
      -- x : nat-s
      -> (* y : nat-s
            (nat-lt-s x y))
    nat-archimedean-property x =
      (* (succ-c x) (nat-lteq-reflexive (succ-c x)))
    #+end_src

*** nat-order-category

    #+begin_src cicada
    nat-order-category : category-t
    nat-order-category = category-c
      object-s = nat-s
      arrow-s = nat-lteq-s
      arrow-eqv-s = eqv-s

      identity = nat-lteq-reflexive

      compose = nat-lteq-transitive

      identity-neutral-left x =
        case x
          zero-lteq-s eqv-c
          succ-lteq-s (eqv-apply succ-lteq-c (recur x.prev))

      identity-neutral-righ x =
        case x
          zero-lteq-s eqv-c
          succ-lteq-s (eqv-apply succ-lteq-c (recur x.prev))

      compose-associative f g h =
        case [f g h]
          [zero-lteq-s _ _] eqv-c
          [succ-lteq-s succ-lteq-s succ-lteq-s]
            (eqv-apply succ-lteq-c (recur f.prev g.prev h.prev))
    #+end_src

* groupoid

*** groupoid-t

    #+begin_src cicada
    groupoid-t <: category-t
    groupoid-t = class
      inverse :
        -- (arrow-s a b) % f
        -> (* (arrow-s b a) % g
              (arrow-inverse-s f g))
    #+end_src

* >< nat-total-order

* monoid

*** monoid-t

    #+begin_src cicada
    monoid-t : class-tt
    monoid-t = class
      element-s : set-t

      element-eqv-s :
        -- element-s element-s
        -> set-t

      unit : element-s

      product :
        -- element-s element-s
        -> element-s

      unit-neutral-left :
        -- a : element-s
        -> (element-eqv-s (product a unit) a)

      unit-neutral-right :
        -- a : element-s
        -> (element-eqv-s (product unit a) a)

      product-associative :
        -- a : element-s
           b : element-s
           c : element-s
        -> (element-eqv-s
             (product a (product b c))
             (product (product a b) c))
    #+end_src

*** monoid.as-category

    #+begin_src cicada
    monoid.as-category : category-t
    monoid.as-category = category-c
      object-s = unit-s
      arrow-s _ _ = element-s
      arrow-eqv-s = element-eqv-s
      identity _ = unit
      compose = product
      identity-neutral-left = unit-neutral-left
      identity-neutral-right = unit-neutral-right
      compose-associative = product-associative
    #+end_src

* >< group

* >< abelian-group

* >< ring

* >< field

* >< vector-space

* >< limit

* functor

*** functor-t

    #+begin_src cicada
    note
      endofunctor of set-category

    functor-t : class-tt
    functor-t = class
      fun-s : -- set-t -> set-t
      map : -- (-- a -> b) (fun-t a) -> (fun-s b)
    #+end_src

*** list-functor

    #+begin_src cicada
    list-functor : functor-t
    list-functor = functor-c
      fun-s = list-s
      map fun list =
        case list
          null-s null-c
          cons-s
            (cons-c (fun list.car) (recur fun list.cdr))
    #+end_src

* const

*** const-s

    #+begin_src cicada
    const-s : set-t
    const-s = data
      [c a] : set-t
      value : c
    #+end_src

*** const-functor

    #+begin_src cicada
    const-functor : -- set-t -> functor-t
    const-functor c = functor-c
      fun-s = (const-s c)

      map : -- (-- a -> b) (const-s c a) -> (const-s c b)
      map _ x = x
    #+end_src

* monad

*** monad-t

    #+begin_src cicada
    monad-t <: functor-t
    monad-t = class
      pure : -- t -> (fun-s t)
      bind : -- (fun-s a) (-- a -> (fun-s b)) -> (fun-s b)
    #+end_src

*** monad.compose

    #+begin_src cicada
    monad.compose :
      -- (-- a -> (fun-s b))
         (-- b -> (fun-s c))
      -> (-- a -> (fun-s c))
    monad.compose f g = (lambda [a] (bind (f a) g))
    #+end_src

*** monad.flatten

    #+begin_src cicada
    monad.flatten :
      -- (fun-s (fun-s a))
      -> (fun-s a)
    monad.flatten m = (bind m (lambda []))
    #+end_src

*** list-monad

    #+begin_src cicada
    list-monad : monad-t
    list-monad = monad-c
      pure x = (cons-c x null-c)
      bind list fun =
        case list
          null-s null-c
          cons-s (list-append (fun list.car) (recur list.cdr fun))
    #+end_src

* maybe

*** maybe-s

    #+begin_src cicada
    maybe-s : set-t
    maybe-s = sum [none-s just-s]
      t : set-t

    none-s : set-t
    none-s = data
      t : set-t

    just-s : set-t
    just-s = data
      t : set-t
      value : t
    #+end_src

*** maybe-functor

    #+begin_src cicada
    maybe-functor : functor-t
    maybe-functor = functor-c
      fun-s = maybe-s
      map fun maybe =
        case maybe
          none-s none-c
          just-s (just-c (fun maybe.value))
    #+end_src

*** maybe-monad

    #+begin_src cicada
    maybe-monad : monad-t
    maybe-monad = monad-c
      pure = just-c
      bind maybe fun =
        case maybe
          none-s none-c
          just-s (fun maybe.value)
    #+end_src

* state

*** state-s

    #+begin_src cicada
    state-s : -- set-t set-t -> set-t
    state-s s a = -- s -> (* s a)
    #+end_src

*** state-monad

    #+begin_src cicada
    state-monad : -- set-t -> monad-t
    state-monad s = monad-c
      fun-s = (state-s s)

      map : -- (-- a -> b)
               (state-s s a)
            -> (state-s s b)
      map : -- (-- a -> b)
               (-- s -> (* s a))
            -> (-- s -> (* s b))
      map f m = lambda [s]
        * (1st (m s))
          (f (2nd (m s)))

      pure : -- t -> (state-s s t)
      pure : -- t -> (-- s -> (* s t))
      pure v = lambda [s] (* s v)

      bind : -- (fun-s a) (-- a -> (fun-s b)) -> (fun-s b)
      bind : -- (state-s s a) (-- a -> (state-s s b)) -> (state-s s b)
      bind : -- (-- s -> (* s a))
                (-- a -> (-- s -> (* s b)))
             -> (-- s -> (* s b))
      bind m f = lambda [s] ((f (2st (m s))) (1st (m s)))
    #+end_src

* tree

*** tree-s

    #+begin_src cicada
    tree-s : set-t
    tree-s = sum [leaf-s branch-s]
      t : set-t

    leaf-s : set-t
    leaf-s = data
      t : set-t
      value : t

    branch-s : set-t
    branch-s = data
      t : set-t
      [left right] : (tree-s t)
    #+end_src

*** tree-functor

    #+begin_src cicada
    tree-functor : functor-t
    tree-functor = functor-c
      fun-s = tree-s
      map fun tree =
        case tree
          leaf-s (leaf-c (fun tree.value))
          branch-s
            (branch-c
              (recur fun tree.left)
              (recur fun tree.right))
    #+end_src

*** tree-zip

    #+begin_src cicada
    tree-zip :
      -- (tree-s a)
         (tree-s b)
      -> (maybe-s (tree-s (* a b)))
    tree-zip x y =
      case [x y]
        [leaf-s leaf-s]
          (pure (leaf-c (* x.value y.value)))
        [branch-s branch-s]
          do left <- (recur x.left y.left)
             right <- (recur x.right y.right)
             (pure (branch-c left right))
        else none-c
    #+end_src

*** tree-numbering

    #+begin_src cicada
    tree-numbering :
      -- (tree-s t)
      -> (state-s nat-s (tree-s nat-s))
    tree-numbering tree =
      case tree
        leaf-s lambda [n]
          (* (nat-inc n) (leaf-c n))
        branch-s
          do left <- (recur tree.left)
             right <- (recur tree.right)
             (pure (branch-c left right))
    #+end_src

* int

*** >< int-s

*** >< mod-s

*** gcd-s

    #+begin_src cicada
    gcd-s : set-t
    gcd-s = sum [zero-gcd-s mod-gcd-s]
      [x y d] : int-s

    zero-gcd-s : set-t
    zero-gcd-s = data
      [x y d] : int-s
      y = zero-c
      x = d

    mod-gcd-s : set-t
    mod-gcd-s = data
      [x y d] : int-s
      gcd : (gcd-s z x d)
      mod : (mod-s z x y)
    #+end_src

* set-category

*** set-morphism-t

    #+begin_src cicada
    set-morphism-t : class-tt
    set-morphism-t = class
      ante : set-t
      succ : set-t

      morphism : -- ante -> succ
    #+end_src

*** set-morphism-eqv-t

    #+begin_src cicada
    set-morphism-eqv-t : class-tt
    set-morphism-eqv-t = class
      lhs : (set-morphism-t a b)
      rhs : (set-morphism-t a b)

      morphism-eqv :
        -- x : a
        -> (eqv-s (lhs.morphism x) (rhs.morphism x))
    #+end_src

*** set-category

    #+begin_src cicada
    set-category : category-tt
    set-category = category-c
      object-t : class-tt
      object-t = set-t

      arrow-t : -- set-t set-t -> class-tt
      arrow-t a b = (set-morphism-t a b)

      arrow-eqv-t :
        -- (set-morphism-t a b)
           (set-morphism-t a b)
        -> class-tt
      arrow-eqv-t lhs rhs = (set-morphism-eqv-t lhs rhs)

      identity :
        -- set-t % a
        -> (set-morphism-t a a)
      identity _ = set-morphism-c
        morphism = nop

      compose :
        -- (set-morphism-t a b)
           (set-morphism-t b c)
        -> (set-morphism-t a c)
      compose f g = set-morphism-c
        morphism = (| f.morphism g.morphism)

      identity-neutral-left :
        -- f : (set-morphism-t a b)
        -> (set-morphism-eqv-t f (compose f (identity b)))
      identity-neutral-left f = set-morphism-eqv-c
        lhs : (set-morphism-t a b)
        lhs = f
        rhs : (set-morphism-t a b)
        rhs = (compose f (identity b))
        morphism-eqv :
          -- x : a
          -> (eqv-s (f.morphism x) (f.morphism x))
        morphism-eqv x = eqv-c

      identity-neutral-right :
        -- f : (set-morphism-t a b)
        -> (set-morphism-eqv-t f (compose (identity a) f))
      identity-neutral-right f = set-morphism-eqv-c
        morphism-eqv _ = eqv-c

      compose-associative :
        -- f : (set-morphism-t a b)
           g : (set-morphism-t b c)
           h : (set-morphism-t c d)
        -> (set-morphism-eqv-t
             lhs = (compose f (compose g h))
             rhs = (compose (compose f g) h))
      compose-associative f g h = set-morphism-eqv-c
        morphism-eqv _ = eqv-c
    #+end_src

*** set-category -- without type

    #+begin_src cicada
    set-category : category-tt
    set-category = category-c
      object-t = set-t

      arrow-t a b = (set-morphism-t a b)

      arrow-eqv-t lhs rhs = (set-morphism-eqv-t lhs rhs)

      identity _ = set-morphism-c
        morphism = nop

      compose f g = set-morphism-c
        morphism = (| f.morphism g.morphism)

      identity-neutral-left _ = set-morphism-eqv-c
        morphism-eqv _ = eqv-c

      identity-neutral-right _ = set-morphism-eqv-c
        morphism-eqv _ = eqv-c

      compose-associative _ _ _ = set-morphism-eqv-c
        morphism-eqv _ = eqv-c
    #+end_src

* preorder-category

*** preorder-morphism-t

    #+begin_src cicada
    preorder-morphism-t : class-tt
    preorder-morphism-t = class
      ante : preorder-t
      succ : preorder-t

      morphism : -- ante.element-s -> succ.element-s

      morphism-respect-pre-relation :
        -- (ante.pre-s x y)
        -> (succ.pre-s (morphism x) (morphism y))
    #+end_src

*** preorder-morphism-eqv-t

    #+begin_src cicada
    preorder-morphism-eqv-t : class-tt
    preorder-morphism-eqv-t = class
      lhs : (preorder-morphism-t a b)
      rhs : (preorder-morphism-t a b)

      morphism-eqv :
        -- x : a.element-s
        -> (eqv-s (lhs.morphism x) (rhs.morphism x))
    #+end_src

*** preorder-category

    #+begin_src cicada
    preorder-category : category-tt
    preorder-category = category-c
      object-t : class-tt
      object-t = preorder-t

      arrow-t : -- preorder-t preorder-t -> class-tt
      arrow-t a b = (preorder-morphism-t a b)

      arrow-eqv-t :
        -- (preorder-morphism-t a b)
           (preorder-morphism-t a b)
        -> class-tt
      arrow-eqv-t lhs rhs = (preorder-morphism-eqv-t lhs rhs)

      identity :
        -- preorder-t % a
        -> (preorder-morphism-t a a)
      identity _ = preorder-morphism-c
        morphism = nop
        morphism-respect-pre-relation = nop

      compose :
        -- (preorder-morphism-t a b)
           (preorder-morphism-t b c)
        -> (preorder-morphism-t a c)
      compose f g = preorder-morphism-c
        morphism = (| f.morphism g.morphism)
        morphism-respect-pre-relation =
          (| f.morphism-respect-pre-relation
             g.morphism-respect-pre-relation)

      identity-neutral-left f = preorder-morphism-eqv-c
        morphism-eqv x = eqv-c

      identity-neutral-right f = preorder-morphism-eqv-c
        morphism-eqv _ = eqv-c

      compose-associative f g h = preorder-morphism-eqv-c
        morphism-eqv _ = eqv-c
    #+end_src

* category-category

*** category-morphism-tt

    - a category-morphism-tt is a functor between two categories.

    - a functor between two categories is a natural-construction
      of the structure of [ante : category-tt]
      in the structure of [succ : category-tt]

    #+begin_src cicada
    category-morphism-tt : class-ttt
    category-morphism-tt = class
      ante : category-tt
      succ : category-tt

      object-map :
        -- ante.object-t
        -> succ.object-t

      arrow-map :
        -- (ante.arrow-t a b)
        -> (succ.arrow-t (object-map a) (object-map b))

      arrow-map-respect-compose :
        -- (ante.arrow-t a b) % f
           (ante.arrow-t b c) % g
        -> (succ.arrow-eqv-t
             (arrow-map (ante.compose f g))
             (succ.compose (arrow-map f) (arrow-map g)))

      arrow-map-respect-identity :
        -- a : ante.object-t
        -> (succ.arrow-eqv-t
             (arrow-map (ante.identity a))
             (succ.identity (object-map a)))
    #+end_src

*** category-morphism-eqv-tt

    #+begin_src cicada
    category-morphism-eqv-tt : class-ttt
    category-morphism-eqv-tt = class
      lhs : (category-morphism-tt a b)
      rhs : (category-morphism-tt a b)

      morphism-eqv :
        ><><><
    #+end_src

*** category-category

    #+begin_src cicada
    category-category : category-ttt
    category-category = category-c
      object-tt : category-ttt
      object-tt = category-tt

      arrow-tt :
        -- category-tt category-tt
        -> class-ttt
      arrow-tt a b = (category-morphism-tt a b)

      arrow-eqv-tt :
        -- (category-morphism-tt a b)
           (category-morphism-tt a b)
        -> class-ttt
      arrow-eqv-tt lhs rhs = (category-morphism-eqv-tt lhs rhs)

      ><><><
    #+end_src
