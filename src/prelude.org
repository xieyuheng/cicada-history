#+html_head: <link rel="stylesheet" href="css/org-page.css"/>
#+title: prelude

* [todo-stack]

*** specify the use of (::)

*** category-category

*** handle (unique) and (give) as type-t

*** product-arrow

***** we need to use the `factor` in `unique-factor`

*** representable-functor and set

*** fix set-morphism-t -- with set-t

    - maybe no top level eqv-s

    ------

    - x -
      maybe we can not afford to do this.
      for syntax reason.

*** arrow-eqv-t -- amend `arrow-eqv-relation` for all category

    - arrow-eqv-t must be an eqv-relation-t
      for all hom-set [a b arrow-t]

*** bifunctor

    - checking functorial laws of pair of categories,
      [where pair is Cartesian product]
      is equivalent to
      checking functorial laws for each component of the pair.

      - this is the whole point of Cartesian product

*** set-category

    - surjective

    - injective

    - bijective

*** prove iso for universal-construction

    - a universal-construction is unique up to unique isomorphism

    - we need to use unique to prove eqv

*** nat-total-order

*** monad as category

*** dependent-category -- use pullback, pushout and equalizer

    - maybe we still need to get out of category at the end

    - to open a new mode of explanation

*** topos-theory

*** logic programming interface of the type system

*** use number theory to test type-checker as prover

*** algebraic structure

    - (*) and (+) in type-t
      provide two commutative monoidal structures -- semi-ring-t
      for we canâ€™t define subtraction of types.
      -- a.k.a rig-t, ring without negative.

      - note that, to be monoidal-category,
        the binary operator must also be a bifunctor.

        i.e. the monoidal product must be
        compatible with the structure of the category,
        which is defined by morphisms.

    - order relation for algebraic data type

      for example :
      a < a + b
      a < a * 2

      this can be viewed as a functor from type-t to rational-s

    ------

    - x -
      can we extend the algebraic structure to dependent type ?

    - k -
      we will need to extend the algebraic structure to object

    - x -
      object are just like type.
      just without sum-type, only product-type.

*** should (:) (<:) form types too ? -- like eqv-c

*** other topics to be formalized

***** Ordinal number

      - https://en.wikipedia.org/wiki/Ordinal_number

      - well-order

      - Order type

      - Every well-ordered set is order-equivalent
        to exactly one ordinal number.

***** Cardinal number

      - https://en.wikipedia.org/wiki/Cardinal_number

      - In category theory,
        the cardinal numbers form a skeleton of the category of sets.

***** Skeleton (category theory)

      - https://en.wikipedia.org/wiki/Skeleton_(category_theory)

***** Cantor's diagonal argument

      - https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument

* [note]

*** (*)

    - literal tuple-type -- (* <type> ...)

    - inhabit by literal tuple -- (* <data> ...)

*** (+)

    - union of set theory

    - literal union-type -- (+ <type> ...)

    - we do not have literal union-data,
      the union-type is inhabited by [<data> : <type>] and so on

*** (data)

    - named record-type

    - to inhabit a data-type constructed by type-constructor,
      we call its data-constructor.

      - (<name>-c <data> ...) -- call with order

      - (<name>-c <field> = <data> ...) -- call with field

*** (data :> [<sub-type> ...])

    - summing sub-types.

    - if declares same fields,
      and names a type-constructor for the sum-type.

    - type-constructor of each data-type
      must have the same declared fields and types

    - it can be viewed as disjoin-union,
      because data-types in the list are disjoin.

*** (data <: [<super-type> ...])

    - inhabiting super-types.

    - [c1 <: c2] means c1 inherit c2 's fields,
      thus c1 is more special then c2,
      because c1 has more interface functions than c2.

    - whatever data inhabits c1 also inhabits c2.

*** currying of type-constructor

    - some of the fields of the type are already inhabited by data,
      to inhabited such partial-type,
      we only need to inhabit remaining fields.

*** level of universe

***** >< accumulative or not ?

***** >< level rule

***** >< searchable-set vs non-searchable-set

***** level table

      | - | data, object           |
      |---+------------------------|
      | 0 | <name>-s, data-type    |
      |   | union-type, tuple-type |
      |---+------------------------|
      | 1 | type-t, category-t     |
      |---+------------------------|
      | 2 | type-tt, category-tt   |

***** level examples

      | 0                   | 1      | 2       |
      |---------------------+--------+---------|
      | nat-s               | type-t | type-tt |
      | (* nat-s nat-s)     | type-t | type-tt |
      | (+ bool-s nat-s)    | type-t | type-tt |
      | (-- nat-s -> nat-s) | type-t | type-tt |
      | list-s              | type-t | type-tt |

*** implicit-ness

***** builtin level polymorphism

      - we can not really afford to
        split category-t* to category-t and category-tt,
        because we have to redefined so many types along category-t.

      - instead we assume that when a type is define in one level,
        it is defined for all levels.

        and all the postfix changes
        are handled by the language implicitly.

        - for example, when
          [category-t : type-tt] is defined,
          [category-tt : type-ttt] is also defined.

      - a convention is that
        we only write down the level or levels
        in which the type is most used.

        - for example :
          [category-morphism-tt : type-ttt]
          [category-category : category-ttt]

***** >< implicit generic-ness of haskell type-class

      - by maintain a map from type-constructor to class-like types.

      - something like the template of c++.

* void

*** void-s

    #+begin_src cicada
    void-s : type-t
    void-s = data :> []
    #+end_src

*** absurd

    #+begin_src cicada
    absurd : -- void-s -> t
    #+end_src

* unit

*** unit-s

    #+begin_src cicada
    unit-s : type-t
    unit-s = data
    #+end_src

*** unit

    #+begin_src cicada
    unit : -- a -> unit-s
    unit a = unit-c
    #+end_src

* bool

*** bool-s

    #+begin_src cicada
    bool-s : type-t
    bool-s = data :> [true-s false-s]

    true-s : type-t
    true-s = data

    false-s : type-t
    false-s = data
    #+end_src

* eqv

*** eqv-s

    #+begin_src cicada
    eqv-s : type-t
    eqv-s = data
      [lhs rhs] : t
      lhs = rhs
    #+end_src

*** eqv-apply

    #+begin_src cicada
    eqv-apply :
      -- fun : (-- a -> b)
         (eqv-s x y)
      -> (eqv-s (fun x) (fun y))
    eqv-apply _ _ = eqv-c
    #+end_src

*** eqv-swap

    #+begin_src cicada
    eqv-swap : -- (eqv-s x y) -> (eqv-s y x)
    eqv-swap _ = eqv-c
    #+end_src

*** eqv-compose

    #+begin_src cicada
    eqv-compose : -- (eqv-s x y) (eqv-s y z) -> (eqv-s x z)
    eqv-compose _ _ = eqv-c
    #+end_src

* nat

*** nat-s

    #+begin_src cicada
    nat-s : type-t
    nat-s = data :> [zero-s succ-s]

    zero-s : type-t
    zero-s = data

    succ-s : type-t
    succ-s = data
      prev : nat-s
    #+end_src

*** nat-add

    #+begin_src cicada
    nat-add : -- nat-s nat-s -> nat-s
    nat-add x y =
      case x
        zero-s y
        succ-s (succ-c (recur x.prev y))
    #+end_src

*** nat-mul

    #+begin_src cicada
    nat-mul : -- nat-s nat-s -> nat-s
    nat-mul x y =
      case x
        zero-s zero-c
        succ-s (nat-add y (recur x.prev y))
    #+end_src

*** nat-factorial

    #+begin_src cicada
    nat-factorial : -- nat-s -> nat-s
    nat-factorial n =
      case n
        zero-s (succ-c zero-c)
        succ-s (nat-mul n (recur n.prev))
    #+end_src

*** nat-even-p

    #+begin_src cicada
    nat-even-p : -- nat-s -> bool-s
    nat-even-p x =
      case x
        zero-s true-c
        succ-s case x.prev
          zero-s false-c
          succ-s (recur x.prev.prev)
    #+end_src

*** nat-even-s

    #+begin_src cicada
    nat-even-s : type-t
    nat-even-s = data :> [zero-even-s even-plus-two-even-s]
      nat : nat-s

    zero-even-s : type-t
    zero-even-s = data
      nat : nat-s
      nat = zero-c

    even-plus-two-even-s : type-t
    even-plus-two-even-s = data
      nat : nat-s
      prev : (nat-even-s m)
      nat = (succ-c (succ-c m))
    #+end_src

*** two-even

    #+begin_src cicada
    two-even : (nat-even-s (succ-c (succ-c zero-c)))
    two-even = (even-plus-two-even-c zero-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    nat-add-associative :
      -- [x y z] : nat-s
      -> (eqv-s
           (nat-add (nat-add x y) z)
           (nat-add x (nat-add y z)))
    nat-add-associative x y z =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev y z))
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    nat-add-commutative :
      -- [x y] : nat-s
      -> (eqv-s
           (nat-add x y)
           (nat-add y x))
    nat-add-commutative x y =
      case x
        zero-s (nat-add-zero-commutative y)
        succ-s
          (eqv-compose
            (eqv-apply succ-c (recur x.prev y))
            (nat-add-succ-commutative y x.prev))
    #+end_src

*** nat-add-zero-commutative

    #+begin_src cicada
    nat-add-zero-commutative :
      -- x : nat-s
      -> (eqv-s
           (nat-add zero-c x)
           (nat-add x zero-c))
    nat-add-zero-commutative x =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev))
    #+end_src

*** nat-add-succ-commutative-1

    #+begin_src cicada
    nat-add-succ-commutative-1 :
      -- [x y] : nat-s
      -> (eqv-s
           (nat-add (succ-c x) y)
           (succ-c (nat-add x y)))
    nat-add-succ-commutative-1 x y =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev y))
    #+end_src

*** nat-add-succ-commutative-2

    #+begin_src cicada
    nat-add-succ-commutative-2 :
      -- [x y] : nat-s
      -> (eqv-s
           (nat-add y (succ-c x))
           (succ-c (nat-add x y)))
    nat-add-succ-commutative-2 x y =
      case x
        zero-s eqv-c
        succ-s (eqv-apply succ-c (recur x.prev y))
    #+end_src

* list

*** list-s

    #+begin_src cicada
    list-s : type-t
    list-s = data :> [null-s cons-s]
      t : type-t

    null-s : type-t
    null-s = data
      t : type-t

    cons-s : type-t
    cons-s = data
      t : type-t
      car : t
      cdr : (list-s t)
    #+end_src

*** list-length

    #+begin_src cicada
    list-length : -- (list-s t) -> nat-s
    list-length list =
      case list
        null-s zero-c
        cons-s (succ-c (recur list.cdr))
    #+end_src

*** list-append

    #+begin_src cicada
    list-append :
      -- (list-s t)
         (list-s t)
      -> (list-s t)
    list-append ante succ =
      case ante
        null-s succ
        cons-s (cons-c ante.car (recur ante.cdr succ))
    #+end_src

*** list-map

    #+begin_src cicada
    list-map : -- (-- a -> b) (list-s a) -> (list-s b)
    list-map fun list =
      case list
        null-s list
        cons-s (cons-c (fun list.car) (recur fun list.cdr))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    list-remove-first : -- t (list-s t) -> (list-s t)
    list-remove-first x list =
      case list
        null-s list
        cons-s
          if (eq-p list.car x)
          then list.cdr
          else (cons-c list.car (recur list.cdr x))
    #+end_src

*** list-length-s -- re-imp function as relation

    #+begin_src cicada
    list-length-s : type-t
    list-length-s = data :> [zero-length-s succ-length-s]
      list : (list-s t)
      length : nat-s


    zero-length-s : type-t
    zero-length-s = data
      list : (list-s t)
      length : nat-s
      list = null-c
      length = zero-c

    succ-length-s : type-t
    succ-length-s = data
      list : (list-s t)
      length : nat-s
      prev : (list-length-s list length)
      list = (cons-c x list)
      length = (succ-c length)
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    list-map-preserve-list-length :
      -- (list-length-s list n)
      -> (list-length-s (list-map fun list) n)
    list-map-preserve-list-length h =
      case h
        zero-length-s h
        succ-length-s (succ-length-c (recur h.prev))
    #+end_src

*** list-append-s -- in prolog

    #+begin_src cicada
    note in prolog, we will have :
      append([], Succ, Succ).
      append([Car | Cdr], Succ, [Car | ResultCdr]):-
        append(Cdr, Succ, ResultCdr).
    #+end_src

*** list-append-s

    #+begin_src cicada
    list-append-s : type-t
    list-append-s = data :> [zero-append-s succ-append-s]
      [ante succ result] : (list-s t)

    zero-append-s : type-t
    zero-append-s = data
      [ante succ result] : (list-s t)
      ante = null-c
      result = succ

    succ-append-s : type-t
    succ-append-s = data
      [ante succ result] : (list-s t)
      prev : (list-append-s cdr succ result-cdr)
      ante = (cons-c car cdr)
      result = (cons-c car result-cdr)
    #+end_src

* vect

*** vect-s

    #+begin_src cicada
    vect-s : type-t
    vect-s = data :> [null-vect-s cons-vect-t]
      t : type-t
      length : nat-s

    null-vect-s : type-t
    null-vect-s = data
      t : type-t
      length : nat-s
      length = zero-c

    cons-vect-s : type-t
    cons-vect-s = data
      t : type-t
      length : nat-s
      car : t
      cdr : (vect-s t length)
      length = (succ-c length)
    #+end_src

*** vect-append

    #+begin_src cicada
    vect-append :
      -- (vect-s t m)
         (vect-s t n)
      -> (vect-s t (nat-add m n))
    vect-append ante succ =
      case ante
        null-vect-s succ
        cons-vect-s (cons-vect-c ante.car (recur ante.cdr succ))
    #+end_src

*** vect-map

    #+begin_src cicada
    vect-map : -- (-- a -> b) (vect-s a n) -> (vect-s a n)
    vect-map fun list =
      case list
        null-vect-s list
        cons-vect-s (cons-vect-c (fun list.car) (recur fun list.cdr))
    #+end_src

* order

*** preorder

***** preorder-t

      #+begin_src cicada
      note
        preorder is a thin category
        with at most one morphism from an object to another.

      preorder-t : type-tt
      preorder-t = data
        element-s : type-t

        pre-s :
          -- element-s element-s
          -> type-t

        pre-reflexive :
          -- a :: element-s
          -> (pre-s a a)

        pre-transitive :
          -- (pre-s a b)
             (pre-s b c)
          -> (pre-s a c)
      #+end_src

*** partial-order

***** partial-order-t

      #+begin_src cicada
      partial-order-t : type-tt
      partial-order-t = data <: [preorder-t]
        element-eqv-s :
          -- element-s
             element-s
          -> type-t
        pre-anti-symmetric :
          -- (pre-s a b)
             (pre-s b a)
          -> (element-eqv-s a b)
      #+end_src

*** eqv-relation

***** eqv-relation-t

      #+begin_src cicada
      eqv-relation-t : type-tt
      eqv-relation-t = data <: [preorder-t]
        pre-symmetric :
          -- (pre-s a b)
          -> (pre-s b a)
      #+end_src

*** total-order

***** total-order-t

      #+begin_src cicada
      total-order-t : type-tt
      total-order-t = data <: [partial-order-t]
        pre-connex :
          -- [a b] : element-s
          -> (+ (pre-s a b) (pre-s b a))
      #+end_src

* unique

*** unique-t

    #+begin_src cicada
    unique-t : type-tt
    unique-t = data
      t : type-t
      x : t
      t-eqv-s : (-- t t -> type-t)
      condition-s : (-- t -> type-t)

      unique-proof :
        * (condition-s x)
          -- y : t
             (condition-s y)
          -> (t-eqv-s x y)
    #+end_src

*** (unique ... under ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s = macro
      (-- y : $t -> ($eqv-s $x y))
    #+end_src

*** (unique ... under ... such-that ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s such-that $condition = macro
      * ($condition $x)
        -- y : $t
           ($condition y)
        -> ($eqv-s $x y)
    #+end_src

* category

*** category-tt

    #+begin_src cicada
    category-tt : type-ttt
    category-tt = data
      object-t : type-tt
      arrow-t : -- object-t object-t -> type-tt
      arrow-eqv-t : -- (arrow-t a b) (arrow-t a b) -> type-tt

      identity : -- a :: object-t -> (arrow-t a a)

      compose : -- (arrow-t a b) (arrow-t b c) -> (arrow-t a c)

      identity-neutral-left :
        -- f : (arrow-t a b)
        -> (arrow-eqv-t f (compose identity f))

      identity-neutral-right :
        -- f : (arrow-t a b)
        -> (arrow-eqv-t f (compose f identity))

      compose-associative :
        -- f : (arrow-t a b)
           g : (arrow-t b c)
           h : (arrow-t c d)
        -> (arrow-eqv-t
             (compose f (compose g h))
             (compose (compose f g) h))

      arrow-eqv-relation :
        -- [a b] :: object-t
        -> (eqv-relation-t
             element-t = (arrow-t a b)
             pre-t = arrow-eqv-t)
    #+end_src

*** basic relation

***** category.arrow-inverse-t

      #+begin_src cicada
      category.arrow-inverse-t :
        -- (arrow-t a b)
           (arrow-t b a)
        -> type-t
      category.arrow-inverse-t f g =
        * (arrow-eqv-t (compose f g) identity)
          (arrow-eqv-t (compose g f) identity)
      #+end_src

***** category.isomorphic-object-t

      #+begin_src cicada
      category.isomorphic-object-t : -- object-t object-t -> type-t
      category.isomorphic-object-t a b =
        * f : (arrow-t a b)
          g : (arrow-t b a)
          (arrow-eqv-t (compose f g) identity)
          (arrow-eqv-t (compose g f) identity)
      #+end_src

*** universal construction

***** category.initial-t

      #+begin_src cicada
      category.initial-candidate-t : type-tt
      category.initial-candidate-t = data
        initial : object-t

      category.initial-t : type-tt
      category.initial-t = data <: [initial-candidate-t]
        unique-factor :
          -- cand : initial-candidate-t
          -> unique factor : (arrow-t initial cand.initial)
             under arrow-eqv-t
      #+end_src

***** category.terminal-t

      #+begin_src cicada
      category.terminal-candidate-t : type-tt
      category.terminal-candidate-t = data
        terminal : object-t

      category.terminal-t : type-tt
      category.terminal-t = data <: [terminal-candidate-t]
        unique-factor :
          -- cand : terminal-candidate-t
          -> unique factor : (arrow-t cand.terminal terminal)
             under arrow-eqv-t
      #+end_src

***** category.product-t

      #+begin_src cicada
      category.product-candidate-t : type-tt
      category.product-candidate-t = data
        fst : object-t
        snd : object-t
        product : object-t
        fst-projection : (arrow-t product fst)
        snd-projection : (arrow-t product snd)

      category.product-t : type-tt
      category.product-t = data <: [product-candidate-t]
        unique-factor :
          -- cand : (product-candidate-t fst snd)
          -> unique factor : (arrow-t cand.product product)
             under arrow-eqv-t such-that
               (arrow-eqv-t
                 cand.fst-projection
                 (compose factor fst-projection))
               (arrow-eqv-t
                 cand.snd-projection
                 (compose factor snd-projection))
      #+end_src

***** category.sum-t

      #+begin_src cicada
      category.sum-candidate-t : type-tt
      category.sum-candidate-t = data
        fst : object-t
        snd : object-t
        sum : object-t
        fst-injection : (arrow-t fst sum)
        snd-injection : (arrow-t snd sum)

      category.sum-t : type-tt
      category.sum-t = data <: [sum-candidate-t]
        unique-factor :
          -- cand : (sum-candidate-t fst snd)
          -> unique factor : (arrow-t sum cand.sum)
             under arrow-eqv-t such-that
               (arrow-eqv-t
                 cand.fst-injection
                 (compose fst-injection factor))
               (arrow-eqv-t
                 cand.snd-injection
                 (compose snd-injection factor))
      #+end_src

*** other structure as category

***** preorder.as-category

      #+begin_src cicada
      note
        to view a preorder as a category
        we simple view all arrow of the same type as eqv

      preorder.as-category : category-t
      preorder.as-category = category-c
        object-s = element-s

        arrow-s = pre-s

        arrow-eqv-s _ _ = unit-s

        identity = pre-reflexive

        compose = pre-transitive

        identity-neutral-left _ = unit-c

        identity-neutral-right _ = unit-c

        compose-associative _ _ _ = unit-c
      #+end_src

*** build new category from old category

***** category.opposite

      #+begin_src cicada
      category.opposite : category-tt
      category.opposite = category-cc
        object-t = this.object-t

        arrow-t :
          -- object-t object-t
          -> type-t
        arrow-t a b = this.arrow-t b a

        arrow-eqv-t :
          -- (this.arrow-t b a) (this.arrow-t b a)
          -> type-t
        arrow-eqv-t = this.arrow-eqv-t

        identity :
          -- a :: object-t
          -> (arrow-t a a)
        identity = this.identity

        compose :
          -- (this.arrow-t b a)
             (this.arrow-t c b)
          -> (this.arrow-t c a)
        compose f g = this.compose g f

        identity-neutral-left :
          -- f : (this.arrow-t b a)
          -> (arrow-eqv-t f (this.compose f identity))
        identity-neutral-left = this.identity-neutral-right

        identity-neutral-right :
          -- f : (this.arrow-t b a)
          -> (arrow-eqv-t f (this.compose identity f))
        identity-neutral-right = this.identity-neutral-left

        compose-associative :
          -- f : (this.arrow-t b a)
             g : (this.arrow-t c b)
             h : (this.arrow-t d c)
          -> (arrow-eqv-t
               (this.compose (this.compose h g) f)
               (this.compose h (this.compose g f)))
        compose-associative f g h =
          (this.arrow-eqv-relation.pre-symmetric
            (this.compose-associative h g f))
      #+end_src

***** category-product

      #+begin_src cicada
      category-product : -- category-tt category-tt -> category-tt
      category-product #1 #2 = category-cc
        object-t = * #1.object-t #2.object-t

        arrow-t a b =
          * (#1.arrow-t a.1 b.1)
            (#2.arrow-t a.2 b.2)

        arrow-eqv-t lhs rhs =
          * (#1.arrow-eqv-t lhs.1 rhs.1)
            (#2.arrow-eqv-t lhs.2 rhs.2)

        identity =
          * #1.identity
            #2.identity

        compose f g =
          * (#1.compose f.1 g.1)
            (#2.compose f.2 g.2)

        identity-neutral-left f =
          * (#1.identity-neutral-left f.1)
            (#2.identity-neutral-left f.2)

        identity-neutral-right f =
          * (#1.identity-neutral-right f.1)
            (#2.identity-neutral-right f.2)

        compose-associative f g h =
          * (#1.compose-associative f.1 g.1 h.1)
            (#2.compose-associative f.2 g.2 h.2)
      #+end_src

* give

*** give-t

*** (give <return-value> such-that <condition> ...)

    - return such thing literally.

    - when called only return <return-value>.

* product-closed-category

*** product-closed-category-tt

    #+begin_src cicada
    product-closed-category-tt : type-ttt
    product-closed-category-tt = data <: [category-tt]
      product :
        -- [a b] : object-t
        -> give p : object-t such-that (product-t a b p)
    #+end_src

*** >< product-closed-category.product-arrow

    #+begin_src cicada
    product-closed-category.product-arrow :
      -- (arrow-t a b)
         (arrow-t c d)
      -> (arrow-t (product a c) (product b d))
    product-closed-category.product-arrow f g =
      ><
    #+end_src

*** product-closed-category.exponential-t

    #+begin_src cicada
    product-closed-category.exponential-candidate-t : type-tt
    product-closed-category.exponential-candidate-t = data
      ante : object-t
      succ : object-t
      exponential : object-t
      eval : (arrow-t (product exponential ante) succ)

    category.exponential-t : type-tt
    category.exponential-t = data <: [exponential-candidate-t]
      unique-factor :
        -- cand : (exponential-candidate-t ante succ)
        -> unique factor : (arrow-t cand.exponential exponential)
           under arrow-eqv-t such-that
             (arrow-eqv-t
               cand.eval
               (compose eval (product-arrow factor identity)))
    #+end_src

* >< cartesian-closed-category

* void-category

*** void-arrow-s

    #+begin_src cicada
    void-arrow-s : type-t
    void-arrow-s = data
      [ante succ] : void-s
    #+end_src

*** void-arrow-eqv-s

    #+begin_src cicada
    void-arrow-eqv-s : type-t
    void-arrow-eqv-s = data
      [lhs rhs] : (void-arrow-s a b)
    #+end_src

*** void-category

    #+begin_src cicada
    void-category : category-t
    void-category = category-c
      object-s = void-s
      arrow-s = void-arrow-s
      arrow-eqv-s = void-arrow-eqv-s

      identity :
        -- a :: void-s
        -> (void-arrow-s a a)
      identity _ = void-arrow-c

      compose _ _ = void-arrow-c

      identity-neutral-left :
        -- f : (void-arrow-s a b)
        -> (void-arrow-eqv-s f void-arrow-c)
      identity-neutral-left _ = void-arrow-eqv-c

      identity-neutral-right :
        -- f : (void-arrow-s a b)
        -> (void-arrow-eqv-s f void-arrow-c)
      identity-neutral-right _ = void-arrow-eqv-c

      compose-associative :
        -- f : (void-arrow-s a b)
           g : (void-arrow-s b c)
           h : (void-arrow-s c d)
        -> (void-arrow-eqv-s void-arrow-eqv-c void-arrow-eqv-c)
      compose-associative _ _ _ = void-arrow-eqv-c
    #+end_src

* graph-t

*** graph-t

    #+begin_src cicada
    note
      different between graph and category is that,
      composing [linking] two edges does not give you edge but path.

    graph-t : type-tt
    graph-t = data
      node-s : type-t
      edge-s : -- node-s node-s -> type-t
    #+end_src

*** graph.path-s

    #+begin_src cicada
    graph.path-s : type-t
    graph.path-s = data
      :> [node-path-s
          edge-path-s
          link-path-s]
      [start end] : node-s

    graph.node-path-s : type-t
    graph.node-path-s = data
      [start end] : node-s
      node : node-s
      start = node
      end = node

    graph.edge-path-s : type-t
    graph.edge-path-s = data
      [start end] : node-s
      edge : (edge-s start end)

    graph.link-path-s : type-t
    graph.link-path-s = data
      [start end] : node-s
      first : (path-s start middle)
      next : (path-s middle end)
    #+end_src

*** graph.path-eqv-s

    #+begin_src cicada
    graph.path-eqv-s : type-t
    graph.path-eqv-s = data
      :> [refl-path-eqv-s
          node-left-path-eqv-s
          node-right-path-eqv-s
          associative-path-eqv-s]
      [lhs rhs] : (path-s a b)

    graph.refl-path-eqv-s : type-t
    graph.refl-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      lhs = p
      lhs = p

    graph.node-left-path-eqv-s : type-t
    graph.node-left-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      lhs = p
      rhs = (link-path-c (node-path-c a) p)

    graph.node-right-path-eqv-s : type-t
    graph.node-right-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      lhs = p
      rhs = (link-path-c p (node-path-c b))

    graph.associative-path-eqv-s : type-t
    graph.associative-path-eqv-s = data
      [lhs rhs] : (path-s a b)
      p : (path-s a b)
      q : (path-s b c)
      r : (path-s c d)
      lhs = (link-path-c p (link-path-c q r))
      rhs = (link-path-c (link-path-c p q) r)
    #+end_src

*** graph.as-free-category

    #+begin_src cicada
    graph.as-free-category : category-t
    graph.as-free-category = category-c
      object-s = node-s
      arrow-s = path-s
      arrow-eqv-s = path-eqv-s

      identity :
        -- a :: node-s
        -> (path-s a a)
      identity = (node-path-c a)

      compose = link-path-c

      identity-neutral-left :
        -- f : (path-s a b)
        -> (path-eqv-s f (link-path-c (node-path-c a) f))
      identity-neutral-left = node-left-path-eqv-c

      identity-neutral-right :
        -- f : (path-s a b)
        -> (path-eqv-s f (link-path-c f (node-path-c b)))
      identity-neutral-right = node-right-path-eqv-c

      compose-associative :
        -- f : (path-s a b)
           g : (path-s b c)
           h : (path-s c d)
        -> (path-eqv-s
             (link-path-c f (link-path-c g h))
             (link-path-c (link-path-c f g) h))
      compose-associative = associative-path-eqv-c
    #+end_src

* nat-order-category

*** nat-lteq-s

    #+begin_src cicada
    nat-lteq-s : type-t
    nat-lteq-s = data :> [zero-lteq-s succ-lteq-s]
      [l r] : nat-s

    zero-lteq-s : type-t
    zero-lteq-s = data
      [l r] : nat-s
      l = zero-c

    succ-lteq-s : type-t
    succ-lteq-s = data
      [l r] : nat-s
      prev : (nat-lteq-s x y)
      l = (succ-c x)
      r = (succ-c y)
    #+end_src

*** nat-non-negative

    #+begin_src cicada
    nat-non-negative : -- n : nat-s -> (nat-lteq-s zero-c n)
    nat-non-negative = zero-lteq-c
    #+end_src

*** nat-lteq-reflexive

    #+begin_src cicada
    nat-lteq-reflexive : -- n : nat-s -> (nat-lteq-s n n)
    nat-lteq-reflexive n =
      case n
        zero-s zero-lteq-c
        succ-s (succ-lteq-c (recur n.prev))
    #+end_src

*** nat-lteq-transitive

    #+begin_src cicada
    nat-lteq-transitive :
      -- (nat-lteq-s a b)
         (nat-lteq-s b c)
      -> (nat-lteq-s a c)
    nat-lteq-transitive x y =
      case x
        zero-lteq-s zero-lteq-c
        succ-lteq-s (succ-lteq-c (recur x.prev y.prev))
    #+end_src

*** nat-lt-s

    #+begin_src cicada
    nat-lt-s : -- nat-s nat-s -> type-t
    nat-lt-s l r = (nat-lteq-s (succ-c l) r)
    #+end_src

*** nat-archimedean-property

    #+begin_src cicada
    nat-archimedean-property :
      -- x : nat-s
      -> (* y : nat-s
            (nat-lt-s x y))
    nat-archimedean-property x =
      (* (succ-c x) (nat-lteq-reflexive (succ-c x)))
    #+end_src

*** nat-order-category

    #+begin_src cicada
    nat-order-category : category-t
    nat-order-category = category-c
      object-s = nat-s
      arrow-s = nat-lteq-s
      arrow-eqv-s = eqv-s

      identity :
        -- a :: nat-s
        -> (nat-lteq-s a a)
      identity = (nat-lteq-reflexive a)

      compose = nat-lteq-transitive

      identity-neutral-left x =
        case x
          zero-lteq-s eqv-c
          succ-lteq-s (eqv-apply succ-lteq-c (recur x.prev))

      identity-neutral-righ x =
        case x
          zero-lteq-s eqv-c
          succ-lteq-s (eqv-apply succ-lteq-c (recur x.prev))

      compose-associative f g h =
        case [f g h]
          [zero-lteq-s _ _] eqv-c
          [succ-lteq-s succ-lteq-s succ-lteq-s]
            (eqv-apply succ-lteq-c (recur f.prev g.prev h.prev))
    #+end_src

* groupoid

*** groupoid-t

    #+begin_src cicada
    groupoid-t : type-tt
    groupoid-t = data <: [category-t]
      inverse :
        -- f : (arrow-s a b)
        -> (* g : (arrow-s b a)
              (arrow-inverse-s f g))
    #+end_src

* >< nat-total-order

* monoid

*** monoid-t

    #+begin_src cicada
    monoid-t : type-tt
    monoid-t = data
      element-s : type-t

      element-eqv-s :
        -- element-s element-s
        -> type-t

      unit : element-s

      product :
        -- element-s element-s
        -> element-s

      unit-neutral-left :
        -- a : element-s
        -> (element-eqv-s (product a unit) a)

      unit-neutral-right :
        -- a : element-s
        -> (element-eqv-s (product unit a) a)

      product-associative :
        -- a : element-s
           b : element-s
           c : element-s
        -> (element-eqv-s
             (product a (product b c))
             (product (product a b) c))
    #+end_src

*** monoid.as-category

    #+begin_src cicada
    monoid.as-category : category-t
    monoid.as-category = category-c
      object-s = unit-s
      arrow-s _ _ = element-s
      arrow-eqv-s = element-eqv-s
      identity = unit
      compose = product
      identity-neutral-left = unit-neutral-left
      identity-neutral-right = unit-neutral-right
      compose-associative = product-associative
    #+end_src

* >< group

* >< abelian-group

* >< ring

* >< field

* >< vector-space

* >< limit

* container

*** container-t

    #+begin_src cicada
    note
      endofunctor of set-category

    container-t : type-tt
    container-t = data
      fun-s : -- type-t -> type-t
      map : -- (-- a -> b) (fun-t a) -> (fun-s b)
    #+end_src

*** list-container

    #+begin_src cicada
    list-container : container-t
    list-container = container-c
      fun-s = list-s
      map fun list =
        case list
          null-s null-c
          cons-s
            (cons-c (fun list.car) (recur fun list.cdr))
    #+end_src

* const

*** const-s

    #+begin_src cicada
    const-s : type-t
    const-s = data
      [c a] : type-t
      value : c
    #+end_src

*** const-container

    #+begin_src cicada
    const-container : -- type-t -> container-t
    const-container c = container-c
      fun-s = (const-s c)

      map : -- (-- a -> b) (const-s c a) -> (const-s c b)
      map _ x = x
    #+end_src

* monad

*** monad-t

    #+begin_src cicada
    monad-t : type-tt
    monad-t = data <: [container-t]
      pure : -- t -> (fun-s t)
      bind : -- (fun-s a) (-- a -> (fun-s b)) -> (fun-s b)
    #+end_src

*** monad.compose

    #+begin_src cicada
    monad.compose :
      -- (-- a -> (fun-s b))
         (-- b -> (fun-s c))
      -> (-- a -> (fun-s c))
    monad.compose f g = (lambda [a] (bind (f a) g))
    #+end_src

*** monad.flatten

    #+begin_src cicada
    monad.flatten :
      -- (fun-s (fun-s a))
      -> (fun-s a)
    monad.flatten m = (bind m (lambda []))
    #+end_src

*** list-monad

    #+begin_src cicada
    list-monad : monad-t
    list-monad = monad-c
      pure x = (cons-c x null-c)
      bind list fun =
        case list
          null-s null-c
          cons-s (list-append (fun list.car) (recur list.cdr fun))
    #+end_src

* maybe

*** maybe-s

    #+begin_src cicada
    maybe-s : type-t
    maybe-s = data :> [none-s just-s]
      t : type-t

    none-s : type-t
    none-s = data
      t : type-t

    just-s : type-t
    just-s = data
      t : type-t
      value : t
    #+end_src

*** maybe-container

    #+begin_src cicada
    maybe-container : container-t
    maybe-container = container-c
      fun-s = maybe-s
      map fun maybe =
        case maybe
          none-s none-c
          just-s (just-c (fun maybe.value))
    #+end_src

*** maybe-monad

    #+begin_src cicada
    maybe-monad : monad-t
    maybe-monad = monad-c
      pure = just-c
      bind maybe fun =
        case maybe
          none-s none-c
          just-s (fun maybe.value)
    #+end_src

* state

*** state-s

    #+begin_src cicada
    state-s : -- type-t type-t -> type-t
    state-s s a = -- s -> (* s a)
    #+end_src

*** state-monad

    #+begin_src cicada
    state-monad : -- type-t -> monad-t
    state-monad s = monad-c
      fun-s = (state-s s)

      map : -- (-- a -> b)
               (state-s s a)
            -> (state-s s b)
      map : -- (-- a -> b)
               (-- s -> (* s a))
            -> (-- s -> (* s b))
      map f m = lambda [s]
        * (1st (m s))
          (f (2nd (m s)))

      pure : -- t -> (state-s s t)
      pure : -- t -> (-- s -> (* s t))
      pure v = lambda [s] (* s v)

      bind : -- (fun-s a) (-- a -> (fun-s b)) -> (fun-s b)
      bind : -- (state-s s a) (-- a -> (state-s s b)) -> (state-s s b)
      bind : -- (-- s -> (* s a))
                (-- a -> (-- s -> (* s b)))
             -> (-- s -> (* s b))
      bind m f = lambda [s] ((f (2st (m s))) (1st (m s)))
    #+end_src

* tree

*** tree-s

    #+begin_src cicada
    tree-s : type-t
    tree-s = data :> [leaf-s branch-s]
      t : type-t

    leaf-s : type-t
    leaf-s = data
      t : type-t
      value : t

    branch-s : type-t
    branch-s = data
      t : type-t
      [left right] : (tree-s t)
    #+end_src

*** tree-container

    #+begin_src cicada
    tree-container : container-t
    tree-container = container-c
      fun-s = tree-s
      map fun tree =
        case tree
          leaf-s (leaf-c (fun tree.value))
          branch-s
            (branch-c
              (recur fun tree.left)
              (recur fun tree.right))
    #+end_src

*** tree-zip

    #+begin_src cicada
    tree-zip :
      -- (tree-s a)
         (tree-s b)
      -> (maybe-s (tree-s (* a b)))
    tree-zip x y =
      case [x y]
        [leaf-s leaf-s]
          (pure (leaf-c (* x.value y.value)))
        [branch-s branch-s]
          do left <- (recur x.left y.left)
             right <- (recur x.right y.right)
             (pure (branch-c left right))
        [_ _] none-c
    #+end_src

*** tree-numbering

    #+begin_src cicada
    tree-numbering :
      -- (tree-s t)
      -> (state-s nat-s (tree-s nat-s))
    tree-numbering tree =
      case tree
        leaf-s lambda [n]
          (* (nat-inc n) (leaf-c n))
        branch-s
          do left <- (recur tree.left)
             right <- (recur tree.right)
             (pure (branch-c left right))
    #+end_src

* int

*** >< int-s

*** >< mod-s

*** gcd-s

    #+begin_src cicada
    gcd-s : type-t
    gcd-s = data :> [zero-gcd-s mod-gcd-s]
      [x y d] : int-s

    zero-gcd-s : type-t
    zero-gcd-s = data
      [x y d] : int-s
      y = zero-c
      x = d

    mod-gcd-s : type-t
    mod-gcd-s = data
      [x y d] : int-s
      gcd : (gcd-s z x d)
      mod : (mod-s z x y)
    #+end_src

* set-category

*** set-t

    #+begin_src cicada
    note
      The set theory of Errett Bishop.

    set-t : type-tt
    set-t = data
      element-s : type-t
      eqv-s : -> element-s element-s -> type-t
    #+end_src

*** set-morphism-t

    #+begin_src cicada
    set-morphism-t : type-tt
    set-morphism-t = data
      ante : type-t
      succ : type-t

      morphism : -- ante -> succ
    #+end_src

*** set-morphism-eqv-t

    #+begin_src cicada
    set-morphism-eqv-t : type-tt
    set-morphism-eqv-t = data
      lhs : (set-morphism-t a b)
      rhs : (set-morphism-t a b)

      morphism-eqv :
        -- x : a
        -> (eqv-s (lhs.morphism x) (rhs.morphism x))
    #+end_src

*** set-category

    #+begin_src cicada
    set-category : category-tt
    set-category = category-cc
      object-t : type-tt
      object-t = type-t

      arrow-t : -- type-t type-t -> type-tt
      arrow-t a b = (set-morphism-t a b)

      arrow-eqv-t :
        -- (set-morphism-t a b)
           (set-morphism-t a b)
        -> type-tt
      arrow-eqv-t lhs rhs = (set-morphism-eqv-t lhs rhs)

      identity :
        -- a :: type-t
        -> (set-morphism-t a a)
      identity = set-morphism-c
        morphism = nop

      compose :
        -- (set-morphism-t a b)
           (set-morphism-t b c)
        -> (set-morphism-t a c)
      compose f g = set-morphism-c
        morphism = (| f.morphism g.morphism)

      identity-neutral-left :
        -- f : (set-morphism-t a b)
        -> (set-morphism-eqv-t f (compose f identity))
      identity-neutral-left f = set-morphism-eqv-c
        lhs : (set-morphism-t a b)
        lhs = f
        rhs : (set-morphism-t a b)
        rhs = (compose f identity)
        morphism-eqv :
          -- x : a
          -> (eqv-s (f.morphism x) (f.morphism x))
        morphism-eqv x = eqv-c

      identity-neutral-right :
        -- f : (set-morphism-t a b)
        -> (set-morphism-eqv-t f (compose identity f))
      identity-neutral-right f = set-morphism-eqv-c
        morphism-eqv _ = eqv-c

      compose-associative :
        -- f : (set-morphism-t a b)
           g : (set-morphism-t b c)
           h : (set-morphism-t c d)
        -> (set-morphism-eqv-t
             lhs = (compose f (compose g h))
             rhs = (compose (compose f g) h))
      compose-associative f g h = set-morphism-eqv-c
        morphism-eqv _ = eqv-c
    #+end_src

*** set-category -- without type

    #+begin_src cicada
    set-category : category-tt
    set-category = category-cc
      object-t = type-t

      arrow-t a b = (set-morphism-t a b)

      arrow-eqv-t lhs rhs = (set-morphism-eqv-t lhs rhs)

      identity = set-morphism-c
        morphism = nop

      compose f g = set-morphism-c
        morphism = (| f.morphism g.morphism)

      identity-neutral-left _ = set-morphism-eqv-c
        morphism-eqv _ = eqv-c

      identity-neutral-right _ = set-morphism-eqv-c
        morphism-eqv _ = eqv-c

      compose-associative _ _ _ = set-morphism-eqv-c
        morphism-eqv _ = eqv-c
    #+end_src

* preorder-category

*** preorder-morphism-t

    #+begin_src cicada
    preorder-morphism-t : type-tt
    preorder-morphism-t = data
      ante : preorder-t
      succ : preorder-t

      morphism : -- ante.element-s -> succ.element-s

      morphism-respect-pre-relation :
        -- (ante.pre-s x y)
        -> (succ.pre-s (morphism x) (morphism y))
    #+end_src

*** preorder-morphism-eqv-t

    #+begin_src cicada
    preorder-morphism-eqv-t : type-tt
    preorder-morphism-eqv-t = data
      lhs : (preorder-morphism-t a b)
      rhs : (preorder-morphism-t a b)

      morphism-eqv :
        -- x : a.element-s
        -> (eqv-s (lhs.morphism x) (rhs.morphism x))
    #+end_src

*** preorder-category

    #+begin_src cicada
    preorder-category : category-tt
    preorder-category = category-cc
      object-t : type-tt
      object-t = preorder-t

      arrow-t : -- preorder-t preorder-t -> type-tt
      arrow-t a b = (preorder-morphism-t a b)

      arrow-eqv-t :
        -- (preorder-morphism-t a b)
           (preorder-morphism-t a b)
        -> type-tt
      arrow-eqv-t lhs rhs = (preorder-morphism-eqv-t lhs rhs)

      identity :
        -- a :: preorder-t
        -> (preorder-morphism-t a a)
      identity = preorder-morphism-c
        morphism = nop
        morphism-respect-pre-relation = nop

      compose :
        -- (preorder-morphism-t a b)
           (preorder-morphism-t b c)
        -> (preorder-morphism-t a c)
      compose f g = preorder-morphism-c
        morphism = (| f.morphism g.morphism)
        morphism-respect-pre-relation =
          (| f.morphism-respect-pre-relation
             g.morphism-respect-pre-relation)

      identity-neutral-left f = preorder-morphism-eqv-c
        morphism-eqv x = eqv-c

      identity-neutral-right f = preorder-morphism-eqv-c
        morphism-eqv _ = eqv-c

      compose-associative f g h = preorder-morphism-eqv-c
        morphism-eqv _ = eqv-c
    #+end_src

* category-category

*** functor-tt

    - a functor between two categories is a natural-construction
      of the structure of [ante : category-tt]
      in the structure of [succ : category-tt]

    #+begin_src cicada
    functor-tt : type-ttt
    functor-tt = data
      ante : category-tt
      succ : category-tt

      object-map :
        -- ante.object-t
        -> succ.object-t

      arrow-map :
        -- (ante.arrow-t a b)
        -> (succ.arrow-t (object-map a) (object-map b))

      arrow-map-respect-compose :
        -- f : (ante.arrow-t a b)
           g : (ante.arrow-t b c)
        -> (succ.arrow-eqv-t
             (arrow-map (ante.compose f g))
             (succ.compose (arrow-map f) (arrow-map g)))

      arrow-map-respect-identity :
        -- a :: ante.object-t
        -> (succ.arrow-eqv-t
             (arrow-map (ante.identity a))
             (succ.identity (object-map a)))
    #+end_src

*** natural-transformation-tt

    - a natural-transformation is a level up map,
      which maps objects to arrows, and arrows to squares.

    #+begin_src cicada
    natural-transformation-tt : type-ttt
    natural-transformation-tt = data
      lhs : (functor-tt c d)
      rhs : (functor-tt c d)

      component :
        -- a : c.object-t
        -> (d.arrow-t (lhs.object-map a) (rhs.object-map a))

      transformation :
        -- f : (c.arrow-t a b)
        -> (d.arrow-eqv-t
             (d.compose (component a) (rhs.arrow-map f))
             (d.compose (lhs.arrow-map f) (component b)))
    #+end_src

*** >< natural-isomorphism-tt

    #+begin_src cicada
    natural-isomorphism-tt : type-ttt
    natural-isomorphism-tt = data <: [natural-transformation-tt]

    #+end_src

*** >< category-category

    #+begin_src cicada
    category-category : category-ttt
    category-category = category-ccc
      object-tt : category-ttt
      object-tt = category-tt

      arrow-tt :
        -- category-tt category-tt
        -> type-ttt
      arrow-tt a b = (functor-tt a b)

      arrow-eqv-tt :
        -- (functor-tt a b)
           (functor-tt a b)
        -> type-ttt
      arrow-eqv-tt lhs rhs = (natural-transformation-tt lhs rhs)

      ><><><
    #+end_src
