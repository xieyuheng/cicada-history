#+title: prelude

* [todo-stack]

*** we need a syntax for (do)

*** tree example

*** zip example

*** find a way to implement universal construction

*** iso-t -- as a (+class)

*** use number theory -- to test type-checker as prover

*** ML like module system -- [in org-mode ?]

*** about first-classness

    - x -
      if we implement category as type-class [or interface]
      to implement product of category
      we need to be able to treat type-class as first-class
      because a product take two categories and return a new category

    - k -
      how about functor ?

    - x -
      while functor is different
      it is not a category constructor
      but a structure preserving map between existing categories

*** functor type-class in haskell

    - in haskell the category under consideration
      is tye category of types
      where types are objects
      functions are morphisms

    - the functor type-class in haskell
      is a endo-functor from this category to itself

      thus a functor instance in haskell
      is a type constructor of type (-> type -- type)

      thus the functor type-class in haskell
      is limited in the sense of functor
      because type constructor in haskell
      is limited in the sense of function of type (-> type -- type)

    - endo functors are containers

*** type name postfix

    - give up detailed type name postfix
      because for structured function type and product type
      type name postfix is not enough

    - type name postfix
      is only used to distinguish level of types

*** stack as a category constructor

    - stack as product built-in the language
      - take swap as an example  (a, b) => (b, a)
      - also the assoc law (a, (b, c)) => ((a,  b), c)

    - maybe we still need to define stack as a category constructor

*** subtype relation as order relation for algebraic data type

    - for example :
      a < a + b
      a < a * 2

*** universe

    - type-tt = 1 universe
      type-tt : 2 universe
      type-tt : 2 universe

    - nat-t : 1 universe
      (* nat-t nat-t) : 1 universe
      (+ nat-t | nat-t) : 1 universe
      (-> nat-t -- nat-t) : 1 universe

    - 1 universe : 2 universe

    - how about the order relation for those universes ?

*** what is the logic programming interface of the type system ?

* [note]

*** (:) (%) (<) (>)

    - just like `=` in some language can form type
      [in cicada, eqv-c and eqv-t]
      should these form types too ?

*** (+type)

    - type of data in data-field must be of type type-tt
      thus, function can not be stored in data-field

*** -ct is always a subtype of record type

*** (@) -- syntax for unnamed record type

    - while in (+type)
      we define named record type

*** naming convention

    - type

      | -t  | type constructor          |
      |     | union-type constructor    |
      |     | quotient-type constructor |
      | -ct | class-type                |
      | -tt | type of type              |

    - function

      | -p  | predicate        |
      | -c  | data constructor |
      | -cr | create           |

*** level of types

    | 0 | object                          |
    | 1 | type, union-type, quotient-type |
    | 2 | type-class, type-tt             |

*** object as type

    - object are just like type
      just without sumtype
      only product type

*** syntax for unnamed record type

*** subtype relation between classes

    - c1 < c2
      if c1 is more special then c2
      if c1 has more interface functions than c2

*** overload add to different types

    - we can also define something like
      (+class add-ct < (-> type-tt type-tt -- type-tt))
      to add number to array

*** unification

***** what to unify ?

      - in cicada
        <term> := <type-term>, <union-term>, <data-term>
        --- (data <hypo>), (type <hypo>)
        --- <trunk>
        <type-term>  := (<type-constructor> <term> ...)
        <union-term> := (<union-constructor> <term> ...)
        <data-term>  := (<data-constructor> <term> ...)
        <trunk> := function application to be reduced

        data-bind-dict -- <hypo> to data <term>
        type-bind-dict -- <hypo> to type <term>

        <trunk> will be formed,
        when among arguments of a function application
        there is a <hypo> that is not bound to data
        or there is a non-reduce-able <trunk>

      - in logic
        <term> := <predicate-term>, <var>, <constant>
        <predicate-term> := (<predicate-symbol> <term> ...)

***** feature structures

      - <var> with two fields type and data,
        can be viewed as feature structures
        in unification theory

*** vector vs list

    - vector and list have the same data-constructor shape

    - it is *not* true that
      every function can be defined for vector
      can also be defined for list

      - for example zip can be defined for vector of same length

      - when defining zip for vector
        more informations in type
        can help to rule out some not meaningful cases

      list -> list
      vector -> vector
      can *not* be composed to
      list -> vector

    - it is true that
      every function can be defined for list
      can also be defined for vector

      - by dropping the length information

      vector -> vector
      list -> list
      can be composed
      vector -> list

    - vector can be viewed as subtype of list
      we can assert so
      and use this subtype relation to reuse functions

      - in some case [when namings are so different]
        we also need to assert relation between
        fields of type and data-constructors

* bool

*** bool-t

    #+begin_src cicada
    (+type bool-t : type-tt
      (-> -- true-t)
      (-> -- false-t))
    #+end_src

* nat

*** nat-t

    #+begin_src cicada
    (+type nat-t : type-tt
      (-> -- zero-t)
      (-> prev : nat-t -- succ-t))
    #+end_src

*** nat-add

    #+begin_src cicada
    (+fun nat-add : (-> [m n] : nat-t -- nat-t)
      (case n
        (zero-t m)
        (succ-t m n.prev recur succ-c)))
    #+end_src

*** nat-mul

    #+begin_src cicada
    (+fun nat-mul : (-> [m n] : nat-t -- nat-t)
      (case n
        (zero-t n)
        (succ-t m n.prev recur m nat-add)))
    #+end_src

*** nat-factorial

    #+begin_src cicada
    (+fun nat-factorial : (-> n : nat-t -- nat-t)
      (case n
        (zero-t n succ-c)
        (succ-t n.prev recur n nat-mul)))
    #+end_src

* list

*** list-t

    #+begin_src cicada
    (+type list-t : (-> type : type-tt -- type-tt)
      (-> -- type null-t)
      (-> car : type
          cdr : type list-t
       -- type cons-t))
    #+end_src

*** list-length

    #+begin_src cicada
    (+fun list-length
      : (-> list : type list-t
         -- nat-t)
      (case list
        (null-t zero-c)
        (cons-t list.cdr recur succ-c)))
    #+end_src

*** list-append

    #+begin_src cicada
    (+fun list-append
      : (-> list : type list-t
            list2 : type list-t
         -- type list-t)
      (case list2
        (null-t list)
        (cons-t list2.car list list2.cdr recur cons-c)))
    #+end_src

*** list-map

    #+begin_src cicada
    (+fun list-map
      : (-> list : type list-t
            fun : (-> type -- type2)
         -- type2 list-t)
      (case list
        (null-t list)
        (cons-t list.car fun list.cdr {fun} recur cons-c)))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    (+fun list-remove-first
      : (-> x : type
            list : type list-t
         -- type list-t)
      (case list
        (null-t list)
        (cons-t (case [list.car x eq-p]
                   (true-t  list.cdr)
                   (false-t list.car list.cdr x recur cons-c)))))
    #+end_src

* eqv

*** eqv-t

    #+begin_src cicada
    (+type eqv-t
      : (-> type :: type-tt
            [lhs rhs] : type
         -- type-tt)
      (-> value :: type
       -- value value eqv-t))
    #+end_src

*** eqv-apply

    #+begin_src cicada
    (+proof eqv-apply
      : (-> [type type2] :: type-tt
            [x y] :: type
            x y eqv-t
            fun : (-> type -- type2)
         -- x fun y fun eqv-t)
      eqv-c)
    #+end_src

*** eqv-swap

    #+begin_src cicada
    (+proof eqv-swap
      : (-> type :: type-tt
            [x y] :: type
            x y eqv-t
         -- y x eqv-t)
      eqv-c)
    #+end_src

*** eqv-compose

    #+begin_src cicada
    (+proof eqv-compose
      : (-> type :: type-tt
            [x y z] :: type
            x y eqv-t
            y z eqv-t
         -- x z eqv-t)
      eqv-c)
    #+end_src

* nat

*** >< nat-even-p

*** nat-even-t -- re-imp predicate as judgment

    #+begin_src cicada
    (+type nat-even-t : (-> n : nat-t -- type-tt)
      (-> -- zero-c zero-even-t)
      (-> m :: nat-t
          prev : m nat-even-t
       -- m succ-c succ-c even-plus-two-even-t))

    (+proof two-even
      : (-> -- zero-c succ-c succ-c nat-even-t)
      zero-even-c
      even-plus-two-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    (+proof nat-add-associative
      : (-> [x y z] : nat-t
         -- x y nat-add z nat-add
            x y z nat-add nat-add eqv-t)
      (case z
        (zero-t eqv-c)
        (succ-t x y z.prev recur {succ-c} eqv-apply)))
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    (+proof nat-add-commutative
      : (-> [m n] : nat-t
         -- m n nat-add
            n m nat-add eqv-t)
      (case n
        (zero-t m nat-add-zero-commutative)
        (succ-t m n.prev recur {succ-c} eqv-apply
                n.prev m nat-add-succ-commutative eqv-compose)))

    (+proof nat-add-zero-commutative
      : (-> m : nat-t
         -- m zero-c nat-add
            zero-c m nat-add eqv-t)
      (case m
        (zero-t eqv-c)
        (succ-t m.prev recur {succ-c} eqv-apply)))

    (+proof nat-add-succ-commutative
      : (-> [m n] : nat-t
         -- m succ-c n nat-add
            m n nat-add succ-c eqv-t)
      (case n
        (zero-t eqv-c)
        (succ-t m n.prev recur {succ-c} eqv-apply)))
    #+end_src

* list

*** list-length-t -- re-imp function as relation

    #+begin_src cicada
    (note
      (: list-length
         (-> list : type list-t
          -- length : nat-t))
      (: list-length-t
         (-> list : type list-t
             length : nat-t
          -- type-tt)))

    ;; this type is like nat-t
    ;; thus
    ;;   the name of the argument of cons-length-c
    ;;   should not be cdr ?

    (+type list-length-t
      : (-> list : type list-t
            length : nat-t
         -- type-tt)
      (-> -- null-c zero-c null-length-t)
      (-> cdr : list length list-length-t
       -- element :: type
          element list cons-c
          length succ-c cons-length-t))
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    (+fun list-map-preserve-list-length
      : (-> type :: type-tt
            fun :: (-> type -- type2)
            list :: type list-t
            n :: nat-t
            list-length-proof : list n list-length-t
         -- list {fun} map n list-length-t)
      (case list-length-proof
        (null-length-t list-length-proof)
        (cons-length-t list-length-proof.cdr recur cons-length-c)))
    #+end_src

*** list-append-t

    #+begin_src cicada
    ;; in prolog :
    ;;   append([], Succ, Succ).
    ;;   append([Car | Cdr], Succ, [Car | ResultCdr]):-
    ;;     append(Cdr, Succ, ResultCdr).

    (+type list-append-t
      : (-> ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      (-> -- null-c succ succ zero-append-t)
      (-> car :: type
          cdr :: type list-t
          result-cdr :: type list-t
          prev : cdr succ result-cdr list-append-t
       -- car cdr cons-c, succ, car result-cdr cons-c succ-append-t))
    #+end_src

*** [semantic] succ-append-t

    #+begin_src cicada
    (+type succ-append-t
      : (-> ante : type list-t
            succ : type list-t
            result : type list-t
         -- type-tt)
      (-> car :: type
          cdr :: type list-t
          result-cdr :: type list-t
          prev : cdr succ result-cdr list-append-t
       -- car cdr cons-c, succ, car result-cdr cons-c succ-append-t))

    (note for [ante succ result succ-append-c]
      0 hypo-id-c data-hypo-c (quote type) local-let
      (quote type) local-get to-type
      type-tt
      unify
      ><><><
      (@data-type-t
        (name "succ-append-t")
        (field-obj-dict
         (@ (type (quote type) local-get)
            (ante (quote ante) local-get)
            (succ (quote succ) local-get)
            (result (quote result) local-get))))
      (let data-type)
      (@data-obj-t
        (data-type data-type)
        (field-obj-dict
         (@ (prev (quote prev) local-get)))))
    #+end_src

* vect

*** vect-t

    #+begin_src cicada
    (+type vect-t
      : (-> length : nat-t
            type : type-tt
         -- type-tt)
      (-> -- zero-c type null-vect-t)
      (-> car : type
          cdr : length type vect-t
       -- length succ-c type cons-vect-t))
    #+end_src

*** vect-append

    #+begin_src cicada
    (+fun vect-append
      : (-> [m n] :: nat-t
            type :: type-tt
            list : m type vect-t
            list2 : n type vect-t
         -- m n nat-add type vect-t)
      (case list2
        (null-vect-t list)
        (cons-vect-t list2.car list list2.cdr recur cons-vect-c)))
    #+end_src

*** vect-map

    #+begin_src cicada
    (+fun vect-map
      : (-> n :: nat-t
            [type type2] :: type-tt
            list : n type vect-t
            fun : (-> type -- type2)
         -- n type2 vect-t)
      (case list
        (null-vect-t list)
        (cons-vect-t list.car fun list.cdr {fun} recur cons-vect-c)))
    #+end_src

* category

*** category-ct

    #+begin_src cicada
    (+class category-ct
      < (@ object-t : type-tt
           arrow-t : (-> object-t object-t -- type-tt)
           arrow-eqv-t : (-> a b arrow-t a b arrow-t -- type-tt))
      (+sig identity
        : (-> object-t % a
           -- a a arrow-t))
      (+sig compose
        : (-> a b arrow-t
              b c arrow-t
           -- a c arrow-t))
      (+sig identity-left
        : (-> a b arrow-t % f
           -- a identity f compose, f arrow-eqv-t))
      (+sig identity-right
        : (-> a b arrow-t % f
           -- f b identity compose, f arrow-eqv-t))
      (+sig compose-associative
        : (-> a b arrow-t % f
              b c arrow-t % g
              c d arrow-t % h
           -- f g h compose compose
              f g compose h compose arrow-eqv-t)))
    #+end_src

*** (@ nat-t nat-lteq-t eqv-t) : category-ct

***** nat-lteq-t

      #+begin_src cicada
      (+type nat-lteq-t
        : (-> [l r] : nat-t -- type-tt)
        (-> -- zero-c r zero-lteq-t)
        (-> prev : l r nat-lteq-t
         -- l succ-c r succ-c succ-lteq-t))
      #+end_src

***** nat-non-negative

      #+begin_src cicada
      (+fun nat-non-negative
        : (-> n : nat-t -- zero-c n nat-lteq-t)
        zero-lteq-c)
      #+end_src

***** nat-lteq-reflexive

      #+begin_src cicada
      (+fun nat-lteq-reflexive
        : (-> n : nat-t -- n n nat-lteq-t)
        (case n
          (zero-t zero-lteq-c)
          (succ-t n.prev recur succ-lteq-c)))
      #+end_src

***** nat-lteq-transitive

      #+begin_src cicada
      (+fun nat-lteq-transitive
        : (-> a b nat-lteq-t % x
              b c nat-lteq-t % y
           -- a c nat-lteq-t)
        (case x
          (zero-lteq-t zero-lteq-c)
          (succ-lteq-t x.prev y.prev recur succ-lteq-c)))
      #+end_src

***** nat-lt-t

      #+begin_src cicada
      (+fun nat-lt-t
        : (-> [l r] : nat-t -- type-tt)
        l succ-c r nat-lteq-t)
      #+end_src

***** nat-archimedean-property

      #+begin_src cicada
      (+type nat-archimedean-property
        : (-> n : nat-t
           -- m : nat-t
              n m nat-lt-t)
        n succ-c dup nat-lteq-reflexive)
      #+end_src

***** category-ct % (@ nat-t nat-lteq-t eqv-t)

      #+begin_src cicada
      (+instance category-ct % (@ nat-t nat-lteq-t eqv-t)
        (+imp identity nat-lteq-reflexive)
        (+imp compose  nat-lteq-transitive)
        (+imp identity-left
          (let x)
          (case x
            (zero-lteq-t eqv-c)
            (succ-lteq-t x.prev recur {succ-lteq-c} eqv-apply)))
        (+imp identity-righ
          (let x)
          (case x
            (zero-lteq-t eqv-c)
            (succ-lteq-t x.prev recur {succ-lteq-c} eqv-apply)))
        (+imp compose-associative
          (let f g h)
          (case [f g h]
            ([zero-lteq-t _ _] eqv-c)
            ([succ-lteq-t succ-lteq-t succ-lteq-t]
             f.prev g.prev h.prev recur {succ-lteq-c} eqv-apply))))
      #+end_src

*** arrow-inverse-t

    #+begin_src cicada
    (+fun arrow-inverse-t
      : (-> category-ct %% (@ object-t arrow-t arrow-eqv-t)
            a b arrow-t % f
            b a arrow-t % g
         -- type-tt)
      f g compose a identity arrow-eqv-t
      g f compose b identity arrow-eqv-t)
    #+end_src

* >< product

*** ><

    #+begin_src cicada

    #+end_src

* groupoid

*** groupoid-ct

    #+begin_src cicada
    (+class groupoid-ct
      < category-ct
      < (@ object-t : type-tt
           arrow-t : (-> object-t object-t -- type-tt)
           arrow-eqv-t : (-> a b arrow-t a b arrow-t -- type-tt))
      (+sig inverse
        : (-> a b arrow-t % f
           -- b a arrow-t % g
              f g arrow-inverse-t)))
    #+end_src

* >< group

* >< abelian-group

* >< monoid

* >< ring

* >< field

* >< vector-space

* >< category-ct %  (@ type-tt morphism-t fun-eqv-t)

*** >< morphism-t

    #+begin_src cicada
    (+type morphism-t
      )
    #+end_src

*** >< fun-eqv-t

    #+begin_src cicada
    (+fun fun-eqv-t
      : )
    #+end_src

*** >< category-ct % (@ type-tt morphism-t fun-eqv-t)

    #+begin_src cicada
    (+instance category-ct % (@ type-tt morphism-t fun-eqv-t)
      )
    #+end_src

* functor

*** functor-ct

    #+begin_src cicada
    (+class functor-ct
      < (@ fun-t : (-> type-tt -- type-tt))
      (+sig map
        : (-> t1 fun-t
              (-> t1 -- t2)
           -- t2 fun-t)))
    #+end_src

*** functor-ct % (@ list-t)

    #+begin_src cicada
    (+instance functor-ct % (@ list-t)
      (+imp map
        (let l fun)
        (case l
          (null-t null-c)
          (cons-t l.car fun l.cdr {fun} recur cons-c))))
    #+end_src

* applicative

*** >< applicative-ct

    #+begin_src cicada
    (+class applicative-ct
      < functor-ct
      < (@ fun-t : (-> type-tt -- type-tt))
      (+sig ><><><)
      (+sig pure
        : (-> t -- t fun-t)))
    #+end_src

* monad

*** monad-ct

    #+begin_src cicada
    (+class monad-ct
      < applicative-ct
      < (@ fun-t : (-> type-tt -- type-tt))
      (+sig bind
        : (-> t1 fun-t
              (-> t1 -- t2 fun-t)
           -- t2 fun-t)))
    #+end_src

* maybe

*** maybe-t

    #+begin_src cicada
    (+type maybe-t : (-> type : type-tt -- type-tt)
      (-> -- type none-t)
      (-> value : type -- type just-t))
    #+end_src

*** monad-ct % (@ maybe-t)

    #+begin_src cicada
    (+instance monad-ct % (@ maybe-t)
      (+imp pure just-c)
      (+imp bind
        (let maybe fun)
        (case maybe
          (none-t none-c)
          (just-t maybe.value fun))))
    #+end_src

* state

*** state-t

    #+begin_src cicada
    (+fun state-t
      : (-> type-tt % type
            type-tt % value-t
         -- type-tt)
      (-> type -- type value-t))
    #+end_src

*** monad-ct % (@ {value-t state-t})

    #+begin_src cicada
    (+instance monad-ct % (@ {value-t state-t})
      (+imp pure
        (let value)
        {value})
      (+imp bind
        (let state fun)
        {state fun apply}))
    #+end_src

* >< tree

*** tree-t

    #+begin_src cicada
    (+type tree-t : (-> type-tt -- type-tt)
      (-> value : :t -- :t leaf-t)
      (-> left : :t.right : :t -- :t node-t))
    #+end_src

*** tree-t : functor-ct

    #+begin_src cicada
    (+instance tree-t : functor-ct
      (+fun map
        : (-> tree : :t1 tree-t
              fun : (-> :t1 -- :t2)
           -- :t2 tree-t)
        (case tree
          (leaf-t tree.value fun leaf-c)
          (node-t
            tree.left {fun} recur
            tree.right {fun} recur node-c))))
    #+end_src

*** tree-zip

    #+begin_src cicada
    (+fun tree-zip
      : ())
    #+end_src

*** tree-numbering

    #+begin_src cicada
    (+fun tree-numbering
      : (-> nat-t tree : :t tree-t
         -- nat-t nat-t tree-t)
      (case tree
        (leaf-t dup inc swap leaf-c)
        (node-t
          tree.left recur (let left)
          tree.right recur (let right)
          left right node-c)))
    #+end_src

*** tree-numbering-curry

    #+begin_src cicada
    (+fun tree-numbering-curry
      : (-> tree : :t tree-t
         -- (-> nat-t
             -- nat-t tree-t))
      (case tree
        (leaf-t {dup inc swap leaf-c})
        (node-t {tree.left recur apply (let left)
                 tree.right recur apply (let right)
                 left right node-c})))
    #+end_src

*** tree-numbering-state

    #+begin_src cicada
    (+fun tree-numbering-state
      : (-> tree : :t tree-t
         -- nat-t tree-t state-t)
      (case tree
        (leaf-t {dup inc swap leaf} state-c)
        (node-t (do
                  left = [tree.left recur]
                  right = [tree.right recur]
                  [left right node-c]))))
    #+end_src

*** [note] macro expansion of (do)

    #+begin_src cicada
    (do
      left = [tree.left recur]
      right = [tree.right recur]
      [left right node])

    ;; =expand-to=>

    (begin
      [tree.left recur]
      {(let left)
       [tree.right recur]
       {(let right)
        [left right node]
        pure}
       bind}
      bind)
    #+end_src

* number theory

*** int-t

    #+begin_src cicada

    #+end_src

*** mod-t

    #+begin_src cicada
    (+type mod-t
      : (->
         -- )
      (-> ))
    #+end_src

*** gcd-t

    #+begin_src cicada
    (+type gcd-t
      : (-> x : int-t
            y : int-t
            d : int-t
         -- type-tt)
      (-> -- x zero-c x zero-gcd-t)
      (-> gcd : x y d gcd-t
          mod : x y z mod-t
       -- y z d mod-gcd-t))
    #+end_src
