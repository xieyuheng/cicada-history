#+html_head: <link rel="stylesheet" href="css/org-page.css"/>
#+title: prelude

* category-category

*** there is no class-category

    - x -
      there is no class-category only category-category

      a class generates a category
      which is an object of category-category

      a class itself is not an object of class-category
      because
      I can not think of how to define morphism between classes

      morphism can only be defined between categories
      generated by classes

      suppose I have defind
      [space-t : class-tt] and [homology-t : class-tt]
      a meaningful morphism between them
      would be something of type (-- space-t -> homology-t)
      but it also need to

    - use natural-transformation to implement arrow-eqv-s of category

    - we do not generate category from class.
      to specify a class-category,
      we need to gave a class and a category.

*** natural-transformation

    - natural-transformation is a level up map.

      the definition of natural-transformation
      maps object to arrow,
      and arrow to square.

*** natural-isomorphism

    - natural-transformation whose ><><>< are isomorphism
      instead of merely morphism

    - natural-isomorphism is eqv-relation between functors

    - eqv-relation between functors
      is specially important
      because homology and homotopy are functors!

* [todo-stack]

*** arrow-eqv-s -- amend `arrow-eqv-relation` for all `category-@`

    - arrow-eqv-s must be an eqv-relation-t
      for all hom-set [a b arrow-s]

*** bifunctor

    - checking functorial laws of pair of categories,
      [where pair is Cartesian product]
      is equivalent to
      checking functorial laws for each component of the pair.

      - this is the whole point of Cartesian product

*** can function not be stored in data-field ?

*** set-category

    - surjective

    - injective

    - bijective

*** prove iso for universal-construction

    - a universal-construction is unique up to unique isomorphism

    - we need to use unique to prove eqv

*** representable-functor

*** nat-total-order

*** monad as category

*** dependent-category -- use pullback and pushout

*** topos-theory

*** logic programming

    - what is the logic programming interface of the type system ?

*** new (do) notation

*** use number theory -- to test type-checker as prover

*** sub-set relation in set-t

    - maybe use (<) as syntax

*** algebraic structure

    - (*) and (sum) in set-t
      provide two commutative monoidal structures -- semi-ring-t
      for we canâ€™t define subtraction of types.
      -- a.k.a rig-t, ring without negative.

      - note that, to be monoidal-category,
        the binary operator must also be a bifunctor.

        i.e. the monoidal product must be
        compatible with the structure of the category,
        which is defined by morphisms.

    - order relation for algebraic data type

      for example :
      a < a + b
      a < a * 2

      this can be viewed as a functor from set-t to rational-s

    ------

    - x -
      can we extend the algebraic structure to dependent type ?

    - k -
      we will need to extend the algebraic structure to object

    - x -
      object are just like type.
      just without sum-type, only product-type.

*** should (:) (%) form types too ? -- like eqv-c

* [note]

*** (:) (%)

    - (%) is reversed (:)

*** (*)

    - literal tuple-type -- (* <type> ...)

    - inhabit by literal tuple -- (* <data> ...)

*** []

    - syntax for values on stack

    - type on stack [<type> ...]

    - inhabit by data on stack [<data> ...]

*** (@)

    - product-type with named fields

    - literal record-type -- (@ <field> : <type> ...)

    - inhabited by literal record-data (@ <field> = <data> ...)

*** (union)

    - union of set theory

    - literal union-type -- (union <type> ...)

    - we do not have literal union-data,
      the union-type is inhabited by [<data> : <type>] and so on

*** (data)

    - data-type

    - named record-type

    - it names a type-constructor for the data-type,
      whose return type is set-t

    - it also names a data-constructor,
      whose return type is constructed by the type-constructor.

    - to inhabit a data-type constructed by type-constructor,
      we call its data-constructor.

      - <name>-c -- call the data-constructor
        with ordered arguments on stack

      - <name>-cr -- call the data-constructor
        with one record-data on the top of stack

      - (<name>-@ <field> = <data> ...) -- literal syntax
        in which the order of <data> does not matter

*** (sum)

    - sum-type

    - named data-type list

    - type-constructor of each data-type have the same type

    - it also names a type-constructor for the sum-type,
      which has the same type as the data-type's type-constructor

    - since it always create new data-type list,
      it can be viewed as disjoin-union,
      because data-types in the list are disjoin.

*** (class)

    - class-type

    - named record-type just like data-type

    - but unlike data-type,
      it can only names a class-constructor with zero arity.

      thus the class-constructor
      is only act as a name of the class-type.

    - to inhabit a class-type,
      we can only use the literal syntax
      (<name>-@ <field> = <data> ...) -- instance object of the class

    - also a class-type can inherit other class-types,
      bringing in the sub-class relation between class-types

*** (<:)

    - sub-class relation between class-types

    - [c1 <: c2] means c1 inherit c2 's fields,
      thus c1 is more special then c2,
      because c1 has more interface functions than c2.

    - whatever object inhabits c1 also inhabits c2.

*** (<class>-&)

    - a syntax for partial-class-type

    - some of the fields of the a partial-class-type
      are already inhabited by data

    - to inhabited such partial-class-type

    - we only need to inhabit remaining fields

    ------

    - x -
      without sexp
      our design of syntax seems get lost

*** data-type vs class-type

***** low-level vs high-level

      - data-type's fields' types are often other data-types.

      - class-type's fields' types are often set-t or arrow-type,
        i.e. of higher levels.

***** implicit vs explicit

      - data-type's type-constructor can take arguments,
        the informations in the arguments,
        can be viewed as implicit
        to the data constructed by its data-constructor.

      - class-type's class-constructor can not take arguments,
        all the informations
        are explicitly stored in its instance object.

*** level of universe

***** >< accumulative or not ?

***** >< level rule

***** >< searchable-set vs non-searchable-set

***** level table

      | - | data, object                           |
      |---+----------------------------------------|
      | 0 | <data>-s                               |
      |   | data-type, sum-type                    |
      |   | union-type, record-type, tuple-type    |
      |---+----------------------------------------|
      | 1 | set-t, class-t, preorder-t, category-t |
      |---+----------------------------------------|
      | 2 | set-tt, class-tt, category-tt          |

***** level examples

      | 0                     | 1                   | 2               |
      |-----------------------+---------------------+-----------------|
      | nat-s                 | set-t               | set-tt          |
      | (* nat-s nat-s)       | set-t               | set-tt          |
      | [nat-s nat-s]         | [set-t set-s]       | [set-tt set-tt] |
      | (union nat-t, bool-s) | set-t               | set-tt          |
      | (-- nat-s -> nat-s)   | set-t               | set-tt          |
      | list-s                | (-- set-t -> set-s) | set-tt          |

*** conventions

***** top of stack as main argument

      - take `nat-add` as a example,
        we (case) over the argument at the top of the stack.

*** implicit-ness

***** builtin level polymorphism

      - we can not really afford to
        split category-t* to category-t and category-tt,
        because we have to redefined so many classes along category-t.

      - instead we assume that when a class is define in one level,
        it is defined for all levels.

        and all the postfix changes
        are handled by the language implicitly.

        - for example, when
          [category-t : class-tt] is defined,
          [category-tt : class-ttt] is also defined.

      - a convention is that
        we only write down the level or levels
        in which the class is most used.

        - for example,
          we define  [category-morphism-tt : class-ttt]
          instead of [category-morphism-t : class-tt]
          and we define [category-category : category-ttt]
          instead of    [category-category : category-tt]

***** >< implicit generic-ness of haskell type-class

      - by maintain a map from type-constructor to class.

      - something like the template of c++.

* void

*** void-s

    #+begin_src cicada
    void-s : set-t
    void-s = sum
    #+end_src

*** absurd

    #+begin_src cicada
    absurd : -- void-s -> t
    #+end_src

* unit

*** unit-s

    #+begin_src cicada
    unit-s : set-t
    unit-s = data
      unit-c :
        -- -> unit-s
    #+end_src

*** unit

    #+begin_src cicada
    unit : -- a -> unit-s
    unit = lambda drop unit-c
    #+end_src

* bool

*** bool-s

    #+begin_src cicada
    bool-s : set-t
    bool-s = sum
      true-c :
        -- -> true-s
      false-c :
        -- -> false-s
    #+end_src

* nat

*** nat-s

    #+begin_src cicada
    nat-s : set-t
    nat-s = sum
      zero-c :
        -- -> zero-s
      succ-c :
        -- prev : nat-s -> succ-s
    #+end_src

*** nat-add

    #+begin_src cicada
    nat-add : -- nat-s nat-s -> nat-s
    nat-add = lambda
      let m n in
      case n
        zero-s m
        succ-s m n.prev recur succ-c
    #+end_src

*** nat-mul

    #+begin_src cicada
    nat-mul : -- nat-s nat-s -> nat-s
    nat-mul = lambda
      let m n in
      case n
        zero-s n
        succ-s m n.prev recur m nat-add
    #+end_src

*** nat-factorial

    #+begin_src cicada
    nat-factorial : -- nat-s -> nat-s
    nat-factorial = lambda
      let n in
      case n
        zero-s zero-c succ-c
        succ-s n.prev recur n nat-mul
    #+end_src

* list

*** list-s

    #+begin_src cicada
    list-s : -- set-t -> set-t
    list-s = sum
      @ t : set-t
      null-c :
        -- -> t null-s
      cons-c :
        -- car : t
           cdr : t list-s
        -> t cons-s
    #+end_src

*** list-length

    #+begin_src cicada
    list-length : -- t list-s -> nat-s
    list-length = lambda
      let list in
      case list
        null-s zero-c
        cons-s list.cdr recur succ-c
    #+end_src

*** list-append

    #+begin_src cicada
    list-append :
      -- t list-s
         t list-s
      -> t list-s
    list-append = lambda
      let ante succ in
      case succ
        null-s ante
        cons-s succ.car ante succ.cdr recur cons-c
    #+end_src

*** list-map

    #+begin_src cicada
    list-map :
      -- a list-s
         -- a -> b
      -> b list-s
    list-map = lambda
      let list fun in
      case list
        null-s list
        cons-s list.car fun list.cdr {fun} recur cons-c
    #+end_src

*** list-remove-first

    #+begin_src cicada
    list-remove-first :
      -- t
         t list-s
      -> t list-s
    list-remove-first = lambda
      let x list in
      case list
        null-s list
        cons-s case [list.car x eq-p]
          true-s list.cdr
          false-s list.car list.cdr x recur cons-c
    #+end_src

* eqv

*** eqv-s

    #+begin_src cicada
    eqv-s : -- t t -> set-t
    eqv-s = data
      @ [lhs rhs] : t
      eqv-c :
        -- -> v v eqv-s
    #+end_src

*** eqv-apply

    #+begin_src cicada
    eqv-apply :
      -- [x y] :: a
         x y eqv-s
         fun : -- a -> b
      -> x fun y fun eqv-s
    eqv-apply = lambda
      let v fun in
      eqv-c
    #+end_src

*** eqv-swap

    #+begin_src cicada
    eqv-swap :
      -- [x y] :: t
         x y eqv-s
      -> y x eqv-s
    eqv-swap = lambda
      let v in
      eqv-c
    #+end_src

*** eqv-compose

    #+begin_src cicada
    eqv-compose :
      -- [x y z] :: t
         x y eqv-s
         y z eqv-s
      -> x z eqv-s
    eqv-compose = lambda
      let v u in
      eqv-c
    #+end_src

* nat

*** nat-even-p

    #+begin_src cicada
    nat-even-p : -- nat-s -> bool-s
    nat-even-p = lambda
      let x in
      case x
        zero-s true-c
        succ-s case x.prev
          zero-s false-c
          succ-s x.prev.prev recur
    #+end_src

*** nat-even-s

    #+begin_src cicada
    nat-even-s : -- nat-s -> set-t
    nat-even-s = sum
      @ nat : nat-s
      zero-even-c :
        -- -> zero-c zero-even-s
      even-plus-two-even-c :
        -- prev : m nat-even-s
        -> m succ-c succ-c even-plus-two-even-s

    two-even : -- -> zero-c succ-c succ-c nat-even-s
    two-even = lambda zero-even-c even-plus-two-even-c
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    nat-add-associative :
      -- [x y z] : nat-s
      -> x y nat-add z nat-add
         x y z nat-add nat-add eqv-s
    nat-add-associative = lambda
      let x y z in
      case z
        zero-s eqv-c
        succ-s x y z.prev recur {succ-c} eqv-apply
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    nat-add-commutative :
      -- [m n] : nat-s
      -> m n nat-add
         n m nat-add eqv-s
    nat-add-commutative = lambda
      let m n in
      case n
        zero-s m nat-add-zero-commutative
        succ-s
          m n.prev recur {succ-c} eqv-apply
          n.prev m nat-add-succ-commutative eqv-compose
    #+end_src

*** nat-add-zero-commutative

    #+begin_src cicada
    nat-add-zero-commutative :
      -- m : nat-s
      -> m zero-c nat-add
         zero-c m nat-add eqv-s
    nat-add-zero-commutative = lambda
      let m in
      case m
        zero-s eqv-c
        succ-s m.prev recur {succ-c} eqv-apply
    #+end_src

*** nat-add-succ-commutative

    #+begin_src cicada
    nat-add-succ-commutative :
      -- [m n] : nat-s
      -> m succ-c n nat-add
         m n nat-add succ-c eqv-s
    nat-add-succ-commutative = lambda
      let m n in
      case n
        zero-s eqv-c
        succ-s m n.prev recur {succ-c} eqv-apply
    #+end_src

* list

*** list-length-s -- re-imp function as relation

    #+begin_src cicada
    note
      list-length :
        -- list : t list-s
        -> length : nat-s
      list-length-s :
        -- list : t list-s
           length : nat-s
        -> set-t

    list-length-s : -- t list-t, nat-s -> set-t
    list-length-s = sum
      @ list : t list-s
        length : nat-s
      zero-length-c :
        -- -> null-c zero-c zero-length-s
      succ-length-c :
        -- prev : list length list-length-s
        -> element :: t
           element list cons-c
           length succ-c succ-length-s
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    list-map-preserve-list-length :
      -- fun :: -- a -> b
         list :: a list-s
         n :: nat-s
         list n list-length-s
      -> list {fun} list-map n list-length-s
    list-map-preserve-list-length = lambda
      let h in
      case h
        zero-length-s h
        succ-length-s h.prev recur succ-length-c
    #+end_src

*** list-append-s

    #+begin_src cicada
    note in prolog, we will have :
      append([], Succ, Succ).
      append([Car | Cdr], Succ, [Car | ResultCdr]):-
        append(Cdr, Succ, ResultCdr).

    list-append-s : -- t list-s t list-s t list-s -> set-t
    list-append-s = sum
      @ [ante succ result] : t list-s
      zero-append-c :
        -- -> null-c succ succ zero-append-s
      succ-append-c :
        -- car :: t
           cdr :: t list-s
           result-cdr :: t list-s
           prev : cdr succ result-cdr list-append-s
        -> car cdr cons-c, succ, car result-cdr cons-c succ-append-s
    #+end_src

* vect

*** vect-s

    #+begin_src cicada
    vect-s : -- nat-s set-t -> set-t
    vect-s = sum
      @ length : nat-s
        t : set-t
      null-vect-c :
        -- -> zero-c t null-vect-s
      cons-vect-c :
        -- car : t
           cdr : length t vect-s
        -> length succ-c t cons-vect-s
    #+end_src

*** vect-append

    #+begin_src cicada
    vect-append :
      -- m t vect-s
         n t vect-s
      -> m n nat-add t vect-s
    vect-append = lambda
      let x y in
      case y
        null-vect-s x
        cons-vect-s y.car x y.cdr recur cons-vect-c
    #+end_src

*** vect-map

    #+begin_src cicada
    vect-map : -- n a vect-s (-- a -> b) -> n b vect-s
    vect-map = lambda
      let list fun in
      case list
        null-vect-s list
        cons-vect-s list.car fun list.cdr {fun} recur cons-vect-c
    #+end_src

* order

*** preorder

***** preorder-t

      #+begin_src cicada
      note
        preorder is a thin category
        with at most one morphism from an object to another.

      preorder-t : class-tt
      preorder-t = class
        element-s : set-t

        pre-s :
          -- element-s element-s
          -> set-t

        pre-reflexive :
          -- element-s % a
          -> a a pre-s

        pre-transitive :
          -- a b pre-s
             b c pre-s
          -> a c pre-s
      #+end_src

*** partial-order

***** partial-order-t

      #+begin_src cicada
      partial-order-t <: preorder-t
      partial-order-t = class
        element-eqv-s :
          -- element-s
             element-s
          -> set-t
        pre-anti-symmetric :
          -- a b pre-s
             b a pre-s
          -> a b element-eqv-s
      #+end_src

*** eqv-relation

***** eqv-relation-t

      #+begin_src cicada
      eqv-relation-t <: preorder-t
      eqv-relation-t = class
        pre-symmetric :
          -- a b pre-s
          -> b a pre-s
      #+end_src

*** total-order

***** total-order-t

      #+begin_src cicada
      total-order-t <: partial-order-t
      total-order-t = class
        pre-connex :
          -- [a b] : element-s
          -> (union a b pre-s b a pre-s)
      #+end_src

* unique

*** (unique ... under ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s = macro
      (-- y : $t -> $x y $eqv-s)
    #+end_src

*** (unique ... under ... such-that ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s such-that $theorem  = macro
      * $x $theorem
        -- y : $t
           y $theorem
        -> $x y $eqv-s
    #+end_src

* category

*** category-t

    #+begin_src cicada
    category-t : class-tt
    category-t = class
      object-s : set-t
      arrow-s : -- object-s object-s -> set-t
      arrow-eqv-s : -- a b arrow-s a b arrow-s -> set-t

      identity : -- object-s % a -> a a arrow-s

      compose : -- a b arrow-s b c arrow-s -> a c arrow-s

      identity-neutral-left :
        -- a b arrow-s % f
        -> a identity f compose, f arrow-eqv-s

      identity-neutral-right :
        -- a b arrow-s % f
        -> f b identity compose, f arrow-eqv-s

      compose-associative :
        -- a b arrow-s % f
           b c arrow-s % g
           c d arrow-s % h
        -> f g h compose compose
           f g compose h compose arrow-eqv-s

      arrow-eqv-relation :
        -- [a b] :: object-s
        -> eqv-relation-&
             element-s = a b arrow-s
             pre-s = lambda arrow-eqv-s
    #+end_src

*** basic relation

***** category.arrow-inverse-s

      #+begin_src cicada
      category.arrow-inverse-s :
        -- a b arrow-s
           b a arrow-s
        -> set-t
      category.arrow-inverse-s = lambda
        let f g in
        * f g compose a identity arrow-eqv-s
          g f compose b identity arrow-eqv-s
      #+end_src

***** category.isomorphic-object-s

      #+begin_src cicada
      category.isomorphic-object-s : -- object-s object-s -> set-t
      category.isomorphic-object-s = lambda
        let a b in
        * a b arrow-s % f
          b a arrow-s % g
          f g compose a identity arrow-eqv-s
          g f compose b identity arrow-eqv-s
      #+end_src

*** universal construction

***** category.product-object-s

      #+begin_src cicada
      category.product-object-s :
        -- object-s % a
           object-s % b
           object-s % p
           p a arrow-s % pa
           p b arrow-s % pb
        -> set-t
      category.product-object-s = lambda
        let a b p pa pb in
        -- object-s % q
           q a arrow-s % qa
           q b arrow-s % qb
        -> unique q p arrow-s % qp
           under arrow-eqv-s such-that
             * qa, qp pa compose arrow-eqv-s
               qb, qp pb compose arrow-eqv-s
      #+end_src

***** category.coproduct-object-s

      #+begin_src cicada
      category.coproduct-object-s :
        -- object-s % a
           object-s % b
           object-s % p
           a p arrow-s % ap
           b p arrow-s % bp
        -> set-t
      category.product-object-s = lambda
        let a b p ap bp in
        -- object-s % q
           a q arrow-s % aq
           a q arrow-s % bq
        -> unique p q arrow-s % pq
           under arrow-eqv-s such-that
             * aq, ap pq compose arrow-eqv-s
               bq, bp pq compose arrow-eqv-s
      #+end_src

***** category.initial-object-s

      #+begin_src cicada
      category.initial-object-s : -- object-s -> set-t
      category.initial-object-s = lambda
        let a in
        -- object-s % b
        -> unique a b arrow-s % f under arrow-eqv-s
      #+end_src

***** category.terminal-object-s

      #+begin_src cicada
      category.terminal-object-s : -- object-s -- set-t
      category.terminal-object-s = lambda
        let a in
        -- object-s % b
        -> unique b a arrow-s % f under arrow-eqv-s
      #+end_src

*** other structure as category

***** preorder.as-category

      #+begin_src cicada
      note
        to view a preorder as a category
        we simple view all arrow of the same type as eqv

      preorder.as-category : category-t
      preorder.as-category = category-@
        object-s = element-s

        arrow-s = lambda pre-s

        arrow-eqv-s = lambda
          drop drop unit-s

        identity = lambda pre-reflexive

        compose = lambda pre-transitive

        identity-neutral-left = lambda
          drop unit-c

        identity-neutral-right = lambda
          drop unit-c

        compose-associative = lambda
          drop drop drop unit-c
      #+end_src

*** build new category from old category

***** category.opposite

      #+begin_src cicada
      category.opposite : category-t
      category.opposite = category-@
        object-s = lambda this.object-s

        arrow-s :
          -- object-s object-s
          -> set-t
        arrow-s = lambda swap this.arrow-s

        arrow-eqv-s :
          -- b a this.arrow-s b a this.arrow-s
          -> set-t
        arrow-eqv-s = lambda this.arrow-eqv-s

        identity :
          -- object-s % a
          -> a a arrow-s
        identity = lambda this.identity

        compose :
          -- b a this.arrow-s
             c b this.arrow-s
          -> c a this.arrow-s
        compose = lambda swap this.compose

        identity-neutral-left :
          -- b a this.arrow-s % f
          -> f a identity this.compose, f arrow-eqv-s
        identity-neutral-left = lambda this.identity-neutral-right

        identity-neutral-right :
          -- b a this.arrow-s % f
          -> b identity f this.compose, f arrow-eqv-s
        identity-neutral-right = lambda this.identity-neutral-left

        compose-associative :
          -- b a this.arrow-s % f
             c b this.arrow-s % g
             d c this.arrow-s % h
          -> h g this.compose f this.compose
             h g f this.compose this.compose arrow-eqv-s
        compose-associative = lambda
          let f g h in
          h g f this.compose-associative
          this.arrow-eqv-relation.pre-symmetric
      #+end_src

***** category-product

      #+begin_src cicada
      category-product : -- category-t category-t -> category-t
      category-product = lambda
        let #1 #2 in category-@

        object-s = lambda * #1.object-s #2.object-s

        arrow-s = lambda
          let a b in
          * a.1 b.1 #1.arrow-s
            a.2 b.2 #2.arrow-s

        arrow-eqv-s = lambda
          let lhs rhs in
          * lhs.1 rhs.1 #1.arrow-eqv-s
            lhs.2 rhs.2 #2.arrow-eqv-s

        identity = lambda
          let a in
          * a.1 #1.identity
            a.2 #2.identity

        compose = lambda
          let f g in
          * f.1 g.1 #1.compose
            f.2 g.2 #2.compose

        identity-neutral-left = lambda
          let f in
          * f.1 #1.identity-neutral-left
            f.2 #2.identity-neutral-left

        identity-neutral-right = lambda
          let f in
          * f.1 #1.identity-neutral-right
            f.2 #2.identity-neutral-right

        compose-associative = lambda
          let f g h in
          * f.1 g.1 h.1 #1.compose-associative
            f.2 g.2 h.2 #2.compose-associative
      #+end_src

* product-closed-category-t

  #+begin_src cicada
  product-closed-category-t <: category-t
  product-closed-category-t = class
    product :
      -- object-s % a
         object-s % b
      -> object-s % p
         p a arrow-s % pa
         p b arrow-s % pb
         a b p pa pb product-object-s
  #+end_src

* void-category

*** void-arrow-s

    #+begin_src cicada
    void-arrow-s : -- void-s void-s -> set-t
    void-arrow-s = data
      @ [ante succ] : void-s
      void-arrow-c :
        -- -> ante succ void-arrow-s
    #+end_src

*** void-arrow-eqv-s

    #+begin_src cicada
    void-arrow-eqv-s :
      -- a b void-arrow-s
         a b void-arrow-s
      -> set-t
    void-arrow-eqv-s = data
      @ [lhs rhs] : a b void-arrow-s
      void-arrow-eqv-c :
        -- -> lhs rhs void-arrow-eqv-s
    #+end_src

*** void-category

    #+begin_src cicada
    void-category : category-t
    void-category = category-@
      object-s = lambda void-s
      arrow-s = lambda void-arrow-s
      arrow-eqv-s = lambda void-arrow-eqv-s

      identity :
        -- void-s % a
        -> a a void-arrow-s
      identity = lambda
        drop void-arrow-c

      compose = lambda
        drop drop void-arrow-c

      identity-neutral-left :
        -- a b void-arrow-s % f
        -> void-arrow-c f void-arrow-eqv-s
      identity-neutral-left = lambda
        drop void-arrow-eqv-c

      identity-neutral-right :
        -- a b void-arrow-s % f
        -> void-arrow-c f void-arrow-eqv-s
      identity-neutral-right = lambda
        drop void-arrow-eqv-c

      compose-associative :
        -- a b void-arrow-s % f
           b c void-arrow-s % g
           c d void-arrow-s % h
        -> void-arrow-eqv-c void-arrow-eqv-c void-arrow-eqv-s
      compose-associative = lambda
        drop drop drop void-arrow-eqv-c
    #+end_src

* graph-t

*** graph-t

    #+begin_src cicada
    note
      different between graph and category is that,
      composing [linking] two edges does not give you edge but path.

    graph-t : class-tt
    graph-t = class
      node-s : set-t
      edge-s : -- node-s node-s -> set-t
    #+end_src

*** graph.path-s

    #+begin_src cicada
    graph.path-s : -- node-s node-s -> set-t
    graph.path-s = sum
      @ [start end] : node-s
      node-path-c :
        -- node-s % node
        -> node node node-path-s
      edge-path-c :
        -- a b edge-s % edge
        -> a b edge-path-s
      link-path-c :
        -- a b path-s % first
           b c path-s % next
        -> a c link-path-s
    #+end_src

*** graph.path-eqv-s

    #+begin_src cicada
    graph.path-eqv-s : -- a b path-t, a b path-s -> set-t
    graph.path-eqv-s = sum
      @ [lhs rhs] : a b path-s
      refl-path-eqv-c :
        -- a b path-s % p
        -> p p refl-path-eqv-s
      node-left-path-eqv-c :
        -- a b path-s % p
        -> a node-path-c p link-path-c
           p node-left-path-eqv-s
      node-right-path-eqv-c :
        -- a b path-s % p
        -> p b node-path-c link-path-c
           p node-right-path-eqv-s
      associative-path-eqv-c :
        -- a b path-s % p
           b c path-s % q
           c d path-s % r
        -> p q r link-path-c link-path-c
           p q link-path-c r link-path-c associative-path-eqv-s
    #+end_src

*** graph.as-free-category

    #+begin_src cicada
    graph.as-free-category : category-t
    graph.as-free-category = category-@
      object-s = lambda node-s
      arrow-s = lambda path-s
      arrow-eqv-s = lambda path-eqv-s

      identity :
        -- node-s % a
        -> a a path-s
      identity = lambda
        let a in
        a node-path-c

      compose = lambda link-path-c

      identity-neutral-left :
        -- a b path-s % f
        -> a node-path-c f link-path-c
           f path-eqv-s
      identity-neutral-left = lambda node-left-path-eqv-c

      identity-neutral-right :
        -- a b path-s % f
        -> f b node-path-c link-path-c
           f path-eqv-s
      identity-neutral-right = lambda node-right-path-eqv-c

      compose-associative :
        -- a b path-s % f
           b c path-s % g
           c d path-s % h
        -> f g h link-path-c link-path-c
           f g link-path-c h link-path-c path-eqv-s
      compose-associative = lambda associative-path-eqv-c
    #+end_src

* nat-order-category

*** nat-lteq-s

    #+begin_src cicada
    nat-lteq-s : -- nat-s nat-s -> set-t
    nat-lteq-s = sum
      @ [l r] : nat-s
      zero-lteq-c :
        -- -> zero-c r zero-lteq-s
      succ-lteq-c :
        -- prev : l r nat-lteq-s
        -> l succ-c r succ-c succ-lteq-s
    #+end_src

*** nat-non-negative

    #+begin_src cicada
    nat-non-negative : -- n : nat-s -> zero-c n nat-lteq-s
    nat-non-negative = lambda zero-lteq-c
    #+end_src

*** nat-lteq-reflexive

    #+begin_src cicada
    nat-lteq-reflexive : -- n : nat-s -> n n nat-lteq-s
    nat-lteq-reflexive = lambda
      let n in
      case n
        zero-s zero-lteq-c
        succ-s n.prev recur succ-lteq-c
    #+end_src

*** nat-lteq-transitive

    #+begin_src cicada
    nat-lteq-transitive :
      -- a b nat-lteq-s
         b c nat-lteq-s
      -> a c nat-lteq-s
    nat-lteq-transitive = lambda
      let x y in
      case x
        zero-lteq-s zero-lteq-c
        succ-lteq-s x.prev y.prev recur succ-lteq-c
    #+end_src

*** nat-lt-s

    #+begin_src cicada
    nat-lt-s : -- nat-s nat-s -> set-t
    nat-lt-s = lambda
      let l r in
      l succ-c r nat-lteq-s
    #+end_src

*** nat-archimedean-property

    #+begin_src cicada
    nat-archimedean-property :
      -- x : nat-s
      -> y : nat-s
         x y nat-lt-s
    nat-archimedean-property = lambda
      succ-c dup nat-lteq-reflexive
    #+end_src

*** nat-order-category

    #+begin_src cicada
    nat-order-category : category-t
    nat-order-category = category-@
      object-s = lambda nat-s
      arrow-s = lambda nat-lteq-s
      arrow-eqv-s = lambda eqv-s

      identity = lambda nat-lteq-reflexive

      compose  = lambda nat-lteq-transitive

      identity-neutral-left = lambda
        let x in
        case x
          zero-lteq-s eqv-c
          succ-lteq-s x.prev recur {succ-lteq-c} eqv-apply

      identity-righ = lambda
        let x in
        case x
          zero-lteq-s eqv-c
          succ-lteq-s x.prev recur {succ-lteq-c} eqv-apply

      compose-associative = lambda
        let f g h in
        case [f g h]
          [zero-lteq-s _ _] eqv-c
          [succ-lteq-s succ-lteq-s succ-lteq-s]
            f.prev g.prev h.prev recur {succ-lteq-c} eqv-apply
    #+end_src

* groupoid

*** groupoid-t

    #+begin_src cicada
    groupoid-t <: category-t
    groupoid-t = class
      inverse :
        -- a b arrow-s % f
        -> b a arrow-s % g
           f g arrow-inverse-s
    #+end_src

* >< nat-total-order

* monoid

*** monoid-t

    #+begin_src cicada
    monoid-t : class-tt
    monoid-t = class
      element-s : set-t

      element-eqv-s :
        -- element-s element-s
        -> set-t

      unit : element-s

      product :
        -- element-s element-s
        -> element-s

      unit-neutral-left :
        -- a : element-s
        -> a unit product, a element-eqv-s

      unit-neutral-right :
        -- a : element-s
        -> unit a product, a element-eqv-s

      product-associative :
        -- a : element-s
           b : element-s
           c : element-s
        -> a b c product product
           a b product c product element-eqv-s
    #+end_src

*** monoid.as-category

    #+begin_src cicada
    monoid.as-category : category-t
    monoid.as-category = category-@
      object-s = lambda unit-s
      arrow-s = lambda drop drop element-s
      arrow-eqv-s = lambda element-eqv-s
      identity = lambda drop unit
      compose = lambda product
      identity-neutral-left = lambda unit-neutral-left
      identity-neutral-right = lambda unit-neutral-right
      compose-associative = lambda product-associative
    #+end_src

* >< group

* >< abelian-group

* >< ring

* >< field

* >< vector-space

* >< limit

* functor

*** functor-t

    #+begin_src cicada
    note
      endofunctor of set-category

    functor-t : class-tt
    functor-t = class
      fun-s : -- set-t -> set-t
      map : -- a fun-t, (-- a -> b) -> b fun-s
    #+end_src

*** list-functor

    #+begin_src cicada
    list-functor : functor-t
    list-functor = functor-@
      fun-s = lambda list-s
      map = lambda
        let list fun in
        case list
          null-s null-c
          cons-s
            list.car fun
            list.cdr {fun} recur
            cons-c
    #+end_src

* const

*** const-s

    #+begin_src cicada
    const-s : -- set-t set-t -> set-t
    const-s = data
      @ [a c] : set-t
      const-c : -- value : c -> a c const-s
    #+end_src

*** const-functor

    #+begin_src cicada
    const-functor : -- set-t -> functor-t
    const-functor = lambda
      let c in functor-@
      fun-s = lambda {c const-s}

      map : -- a c const-t, (-- a -> b) -> b c const-s
      map = lambda drop
    #+end_src

* monad

*** monad-t

    #+begin_src cicada
    monad-t <: functor-t
    monad-t = class
      pure : -- t -> t fun-s
      bind : -- a fun-t, (-- a -> b fun-s) -> b fun-s
    #+end_src

*** monad.compose

    #+begin_src cicada
    monad.compose :
      -- (-- a -> b fun-s)
         (-- b -> c fun-s)
      -> (-- a -> c fun-s)
    monad.compose = lambda
      let f g in
      {f {g} bind}
    #+end_src

*** monad.flatten

    #+begin_src cicada
    monad.flatten :
      -- a fun-s fun-s
      -> a fun-s
    monad.flatten = lambda {} bind
    #+end_src

*** list-monad

    #+begin_src cicada
    list-monad : monad-t
    list-monad = monad-@
      pure = lambda null-c cons-c
      bind = lambda
        let list fun in
        case list
          null-s null-c
          cons-s
            list.car fun
            list.cdr {fun} recur
            list-append
    #+end_src

* maybe

*** maybe-s

    #+begin_src cicada
    maybe-s : -- set-t -> set-t
    maybe-s = sum
      @ t : set-t
      none-c :
        -- -> t none-s
      just-c :
        -- value : t -> t just-s
    #+end_src

*** maybe-functor

    #+begin_src cicada
    maybe-functor : functor-t
    maybe-functor = functor-@
      fun-s = lambda maybe-s
      map = lambda
        let maybe fun in
        case maybe
          none-s none-c
          just-s maybe.value fun just-c
    #+end_src

*** maybe-monad

    #+begin_src cicada
    maybe-monad : monad-t
    maybe-monad = monad-@
      pure = lambda just-c
      bind = lambda
        let maybe fun in
        case maybe
          none-s none-c
          just-s maybe.value fun
    #+end_src

* state

*** state-s

    #+begin_src cicada
    state-s : -- set-t set-t -> set-t
    state-s = lambda
      let a s in
      -- s -> s a
    #+end_src

*** state-monad

    #+begin_src cicada
    state-monad : -- set-t -> monad-t
    state-monad = lambda
      let s in monad-@
      fun-s = lambda {s state-s}
      map : -- a s state-t, (-- a -> b)
            -> b s state-s
      map : -- (-- s -> s a), (-- a -> b)
            -> (-- s -> s b)
      map = lambda
        let state fun in
        {state fun}
      pure = lambda
        let value in
        {value}
      bind = lambda
        let state fun in
        {state fun apply}
    #+end_src

* tree

*** tree-s

    #+begin_src cicada
    tree-s : -- set-t -> set-t
    tree-s = sum
      @ t : set-t
      leaf-c :
        -- t % value -> t leaf-s
      branch-c :
        -- t tree-s % [left right]
        -> t branch-s
    #+end_src

*** tree-functor

    #+begin_src cicada
    tree-functor : functor-t
    tree-functor = functor-@
      fun-s = lambda tree-s
      map = lambda
        let tree fun in
        case tree
          leaf-s tree.value fun leaf-c
          branch-s
            tree.left {fun} recur
            tree.right {fun} recur branch-c
    #+end_src

*** tree-zip

    #+begin_src cicada
    tree-zip :
      -- a tree-s
         b tree-s
      -> (* a b) tree-s maybe-s
    tree-zip = lambda
      let x y in
      case [x y]
        [leaf-s leaf-s]
          x.value y.value prod leaf-c pure
        [branch-s branch-s]
          do x.left y.left recur >- left
             x.right y.right recur >- right
             left right branch-c pure
        else none-c
    #+end_src

*** tree-numbering-with-nat

    #+begin_src cicada
    tree-numbering-with-nat :
      -- nat-t, t tree-s
      -> nat-t, nat-s tree-s
    tree-numbering-with-nat = lambda
      let tree in
      case tree
        leaf-s dup inc swap leaf-c
        branch-s
          tree.left recur let left in
          tree.right recur let right in
          left right branch-c
    #+end_src

*** tree-numbering

    #+begin_src cicada
    tree-numbering :
      -- t tree-s
      -> nat-s tree-s state-s
    tree-numbering = lambda
      let tree in
      case tree
        leaf-s {dup inc swap leaf-c}
        branch-s
          do tree.left recur >- left
             tree.right recur >- right
             left right branch-c
    #+end_src

* int

*** >< int-s

*** >< mod-s

*** gcd-s

    #+begin_src cicada
    gcd-s : -- int-s int-s int-s -> set-t
    gcd-s = sum
      @ [x y d] : int-s
      zero-gcd-c :
        -- -> x zero-c x zero-gcd-s
      mod-gcd-c :
        -- gcd : x y d gcd-s
           mod : x y z mod-s
        -> y z d mod-gcd-s
    #+end_src

* set-category

*** set-morphism-t

    #+begin_src cicada
    set-morphism-t : class-tt
    set-morphism-t = class
      ante : set-t
      succ : set-t

      morphism : -- ante -> succ
    #+end_src

*** set-morphism-eqv-t

    #+begin_src cicada
    set-morphism-eqv-t : class-tt
    set-morphism-eqv-t = class
      lhs : set-morphism-& a b
      rhs : set-morphism-& a b

      morphism-eqv :
        -- x : a
        -> x lhs.morphism x rhs.morphism eqv-s
    #+end_src

*** set-category

    #+begin_src cicada
    set-category : category-tt
    set-category = category-@
      object-t : class-tt
      object-t = set-t

      arrow-t : -- set-t set-t -> class-tt
      arrow-t = lambda
        let a b in
        set-morphism-& a b

      arrow-eqv-t :
        -- set-morphism-& a b
           set-morphism-& a b
        -> class-tt
      arrow-eqv-t = lambda
        let lhs rhs in
        set-morphism-eqv-& lhs rhs

      identity :
        -- set-t % a
        -> set-morphism-& a a
      identity = lambda drop set-morphism-@
        morphism = lambda

      compose :
        -- set-morphism-& a b
           set-morphism-& b c
        -> set-morphism-& a c
      compose = lambda let f g in set-morphism-@
        morphism = lambda f.morphism g.morphism

      identity-neutral-left :
        -- f : set-morphism-& a b
        -> set-morphism-eqv-& f b identity compose, f
      identity-neutral-left = lambda let f in set-morphism-eqv-@
        lhs : set-morphism-& a b
        lhs = f b identity compose
        rhs : set-morphism-& a b
        rhs = f
        morphism-eqv :
          -- x : a
          -> x f.morphism x f.morphism eqv-s
        morphism-eqv = lambda let x in eqv-c

      identity-neutral-right :
        -- f : set-morphism-& a b
        -> set-morphism-eqv-& a identity f compose, f
      identity-neutral-right = lambda let f in set-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c

      compose-associative :
        -- f : set-morphism-& a b
           g : set-morphism-& b c
           h : set-morphism-& c d
        -> set-morphism-eqv-&
             lhs = f g h compose compose
             rhs = f g compose h compose
      compose-associative = lambda let f g h in set-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c
    #+end_src

*** set-category -- without type

    #+begin_src cicada
    set-category : category-tt
    set-category = category-@
      object-t = set-t

      arrow-t = lambda
        let a b in
        set-morphism-& a b

      arrow-eqv-t = lambda
        let lhs rhs in
        set-morphism-eqv-& lhs rhs

      identity = lambda drop set-morphism-@
        morphism = lambda

      compose = lambda let f g in set-morphism-@
        morphism = lambda f.morphism g.morphism

      identity-neutral-left = lambda drop set-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c

      identity-neutral-right = lambda drop set-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c

      compose-associative = lambda drop drop drop set-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c
    #+end_src

* preorder-category

*** preorder-morphism-t

    #+begin_src cicada
    preorder-morphism-t : class-tt
    preorder-morphism-t = class
      ante : preorder-t
      succ : preorder-t

      morphism : -- ante.element-s -> succ.element-s

      morphism-respect-pre-relation :
        -- x y ante.pre-s
        -> x morphism y morphism succ.pre-s
    #+end_src

*** preorder-morphism-eqv-t

    #+begin_src cicada
    preorder-morphism-eqv-t : class-tt
    preorder-morphism-eqv-t = class
      lhs : preorder-morphism-& a b
      rhs : preorder-morphism-& a b

      morphism-eqv :
        -- x : a.element-s
        -> x lhs.morphism x rhs.morphism eqv-s
    #+end_src

*** preorder-category

    #+begin_src cicada
    preorder-category : category-tt
    preorder-category = category-@
      object-t : class-tt
      object-t = preorder-t

      arrow-t : -- preorder-t preorder-t -> class-tt
      arrow-t = lambda
        let a b in
        preorder-morphism-& a b

      arrow-eqv-t :
        -- preorder-morphism-& a b
           preorder-morphism-& a b
        -> class-tt
      arrow-eqv-t = lambda
        let lhs rhs in
        preorder-morphism-eqv-& lhs rhs

      identity :
        -- preorder-t % a
        -> preorder-morphism-& a a
      identity = lambda drop preorder-morphism-@
        morphism = lambda
        morphism-respect-pre-relation = lambda

      compose :
        -- preorder-morphism-& a b
           preorder-morphism-& b c
        -> preorder-morphism-& a c
      compose = lambda let f g in preorder-morphism-@
        morphism = lambda f.morphism g.morphism
        morphism-respect-pre-relation = lambda
          f.morphism-respect-pre-relation
          g.morphism-respect-pre-relation

      identity-neutral-left = lambda let f in preorder-morphism-eqv-@
        morphism-eqv = lambda let x in eqv-c

      identity-neutral-right = lambda let f in preorder-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c

      compose-associative = lambda let f g h in preorder-morphism-eqv-@
        morphism-eqv = lambda drop eqv-c
    #+end_src

* category-category

*** category-morphism-tt

    - a category-morphism-tt is a functor between two categories.

    - a functor between two categories is a natural-construction
      of the structure of [ante : category-tt]
      in the structure of [succ : category-tt]

    #+begin_src cicada
    category-morphism-tt : class-ttt
    category-morphism-tt = class
      ante : category-tt
      succ : category-tt

      object-map :
        -- ante.object-t
        -> succ.object-t

      arrow-map :
        -- a b ante.arrow-t
        -> a object-map b object-map succ.arrow-t

      arrow-map-respect-compose :
        -- a b ante.arrow-t % f
           b c ante.arrow-t % g
        -> f g ante.compose arrow-map
           f arrow-map g arrow-map succ.compose
           succ.arrow-eqv-t

      arrow-map-respect-identity :
        -- a : ante.object-t
        -> a object-map succ.identity
           a ante.identity arrow-map
           succ.arrow-eqv-t
    #+end_src

*** category-morphism-eqv-tt

    #+begin_src cicada
    category-morphism-eqv-tt : class-ttt
    category-morphism-eqv-tt = class
      lhs : category-morphism-&& a b
      rhs : category-morphism-&& a b

      morphism-eqv :
        ><><><
    #+end_src

*** category-category

    #+begin_src cicada
    category-category : category-ttt
    category-category = category-@
      object-tt : category-tt
      object-tt = lambda category-tt

      arrow-tt :
        -- category-tt category-tt
        -> class-ttt
      arrow-tt = lambda
        let a b in
        category-morphism-&& a b

      arrow-eqv-tt :
        -- category-morphism-&& a b
           category-morphism-&& a b
        -> class-ttt
      arrow-eqv-tt = lambda
        let lhs rhs in
        category-morphism-eqv-&& lhs rhs

      ><><><
    #+end_src
