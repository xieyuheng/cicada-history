#+html_head: <link rel="stylesheet" href="css/org-page.css"/>
#+title: prelude
* not to much lambda
* fix argument order -- map, add, append
* fix state
* fix multi-return-value
* fix the use of `-&`
* [todo-stack]

*** category-category

***** there is no class-category

      - x -
        there is no class-category only category-category

        a class generates a category
        which is an object of category-category

        a class itself is not an object of class-category
        because
        I can not think of how to define morphism between classes

        morphism can only be defined between categories
        generated by classes

        suppose I have defind
        [space-t : class-tt] and [homology-t : class-tt]
        a meaningful morphism between them
        would be something of type (-- space-t -> homology-t)
        but it also need to

      - use natural-transformation to implement arrow-eqv-s of category

      - we do not generate category from class.
        to specify a class-category,
        we need to gave a class and a category.

***** natural-transformation

      - natural-transformation is a level up map.

        the definition of natural-transformation
        maps object to arrow,
        and arrow to square.

***** natural-isomorphism

      - natural-transformation whose ><><>< are isomorphism
        instead of merely morphism

      - natural-isomorphism is eqv-relation between functors

      - eqv-relation between functors
        is specially important
        because homology and homotopy are functors!

*** arrow-eqv-s -- amend `arrow-eqv-relation` for all `category-@`

    - arrow-eqv-s must be an eqv-relation-t
      for all hom-set [a b arrow-s]

*** bifunctor

    - checking functorial laws of pair of categories,
      [where pair is Cartesian product]
      is equivalent to
      checking functorial laws for each component of the pair.

      - this is the whole point of Cartesian product

*** can function not be stored in data-field ?

*** set-category

    - surjective

    - injective

    - bijective

*** prove iso for universal-construction

    - a universal-construction is unique up to unique isomorphism

    - we need to use unique to prove eqv

*** representable-functor

*** nat-total-order

*** monad as category

*** dependent-category -- use pullback and pushout

    - maybe we still need to get out of category at the end

    - to open a new mode of explanation

*** topos-theory

*** logic programming

    - what is the logic programming interface of the type system ?

*** new (do) notation

*** use number theory -- to test type-checker as prover

*** sub-set relation in set-t

    - maybe use (<) as syntax

*** algebraic structure

    - (*) and (sum) in set-t
      provide two commutative monoidal structures -- semi-ring-t
      for we canâ€™t define subtraction of types.
      -- a.k.a rig-t, ring without negative.

      - note that, to be monoidal-category,
        the binary operator must also be a bifunctor.

        i.e. the monoidal product must be
        compatible with the structure of the category,
        which is defined by morphisms.

    - order relation for algebraic data type

      for example :
      a < a + b
      a < a * 2

      this can be viewed as a functor from set-t to rational-s

    ------

    - x -
      can we extend the algebraic structure to dependent type ?

    - k -
      we will need to extend the algebraic structure to object

    - x -
      object are just like type.
      just without sum-type, only product-type.

*** should (:) (%) form types too ? -- like eqv-c

* [note]

*** (:) (%)

    - (%) is reversed (:)

*** (*)

    - literal tuple-type -- (* <type> ...)

    - inhabit by literal tuple -- (* <data> ...)

*** []

    - syntax for values on stack

    - type on stack [<type> ...]

    - inhabit by data on stack [<data> ...]

*** (@)

    - product-type with named fields

    - literal record-type -- (@ <field> : <type> ...)

    - inhabited by literal record-data (@ <field> = <data> ...)

*** (union)

    - union of set theory

    - literal union-type -- (union <type> ...)

    - we do not have literal union-data,
      the union-type is inhabited by [<data> : <type>] and so on

*** (data)

    - data-type

    - named record-type

    - it names a type-constructor for the data-type,
      whose return type is set-t

    - it also names a data-constructor,
      whose return type is constructed by the type-constructor.

    - to inhabit a data-type constructed by type-constructor,
      we call its data-constructor.

      - <name>-c -- call the data-constructor
        with ordered arguments on stack

      - <name>-cr -- call the data-constructor
        with one record-data on the top of stack

      - (<name>-@ <field> = <data> ...) -- literal syntax
        in which the order of <data> does not matter

*** (sum)

    - sum-type

    - named data-type list

    - type-constructor of each data-type have the same type

    - it also names a type-constructor for the sum-type,
      which has the same type as the data-type's type-constructor

    - since it always create new data-type list,
      it can be viewed as disjoin-union,
      because data-types in the list are disjoin.

*** (class)

    - class-type

    - named record-type just like data-type

    - but unlike data-type,
      it can only names a class-constructor with zero arity.

      thus the class-constructor
      is only act as a name of the class-type.

    - to inhabit a class-type,
      we can only use the literal syntax
      (<name>-@ <field> = <data> ...) -- instance object of the class

    - also a class-type can inherit other class-types,
      bringing in the sub-class relation between class-types

*** (<:)

    - sub-class relation between class-types

    - [c1 <: c2] means c1 inherit c2 's fields,
      thus c1 is more special then c2,
      because c1 has more interface functions than c2.

    - whatever object inhabits c1 also inhabits c2.

*** (<class>-&)

    - a syntax for partial-class-type

    - some of the fields of the a partial-class-type
      are already inhabited by data

    - to inhabited such partial-class-type

    - we only need to inhabit remaining fields

    ------

    - x -
      without sexp
      our design of syntax seems get lost

*** data-type vs class-type

***** low-level vs high-level

      - data-type's fields' types are often other data-types.

      - class-type's fields' types are often set-t or arrow-type,
        i.e. of higher levels.

***** implicit vs explicit

      - data-type's type-constructor can take arguments,
        the informations in the arguments,
        can be viewed as implicit
        to the data constructed by its data-constructor.

      - class-type's class-constructor can not take arguments,
        all the informations
        are explicitly stored in its instance object.

*** level of universe

***** >< accumulative or not ?

***** >< level rule

***** >< searchable-set vs non-searchable-set

***** level table

      | - | data, object                           |
      |---+----------------------------------------|
      | 0 | <data>-s                               |
      |   | data-type, sum-type                    |
      |   | union-type, record-type, tuple-type    |
      |---+----------------------------------------|
      | 1 | set-t, class-t, preorder-t, category-t |
      |---+----------------------------------------|
      | 2 | set-tt, class-tt, category-tt          |

***** level examples

      | 0                     | 1                   | 2               |
      |-----------------------+---------------------+-----------------|
      | nat-s                 | set-t               | set-tt          |
      | (* nat-s nat-s)       | set-t               | set-tt          |
      | [nat-s nat-s]         | [set-t set-s]       | [set-tt set-tt] |
      | (union nat-t, bool-s) | set-t               | set-tt          |
      | (-- nat-s -> nat-s)   | set-t               | set-tt          |
      | list-s                | (-- set-t -> set-s) | set-tt          |

*** implicit-ness

***** builtin level polymorphism

      - we can not really afford to
        split category-t* to category-t and category-tt,
        because we have to redefined so many classes along category-t.

      - instead we assume that when a class is define in one level,
        it is defined for all levels.

        and all the postfix changes
        are handled by the language implicitly.

        - for example, when
          [category-t : class-tt] is defined,
          [category-tt : class-ttt] is also defined.

      - a convention is that
        we only write down the level or levels
        in which the class is most used.

        - for example,
          we define  [category-morphism-tt : class-ttt]
          instead of [category-morphism-t : class-tt]
          and we define [category-category : category-ttt]
          instead of    [category-category : category-tt]

***** >< implicit generic-ness of haskell type-class

      - by maintain a map from type-constructor to class.

      - something like the template of c++.

* void

*** void-s

    #+begin_src cicada
    void-s : set-t
    void-s = sum
    #+end_src

*** absurd

    #+begin_src cicada
    absurd : -- void-s -> t
    #+end_src

* unit

*** unit-s

    #+begin_src cicada
    unit-s : set-t
    unit-s = data
      unit-c : unit-s
    #+end_src

*** unit

    #+begin_src cicada
    unit : -- a -> unit-s
    (unit a) = unit-c
    #+end_src

* bool

*** bool-s

    #+begin_src cicada
    bool-s : set-t
    bool-s = sum
      true-c : true-s
      false-c : false-s
    #+end_src

* nat

*** nat-s

    #+begin_src cicada
    nat-s : set-t
    nat-s = sum
      zero-c : zero-s
      succ-c : -- prev : nat-s -> succ-s
    #+end_src

*** nat-add

    #+begin_src cicada
    nat-add : -- nat-s nat-s -> nat-s
    nat-add = lambda [m n]
      case n
        zero-s m
        succ-s (succ-c (recur m n.prev))
    #+end_src

*** nat-mul

    #+begin_src cicada
    nat-mul : -- nat-s nat-s -> nat-s
    nat-mul = lambda [m n]
      case n
        zero-s n
        succ-s (nat-add (recur m n.prev) m)
    #+end_src

*** nat-factorial

    #+begin_src cicada
    nat-factorial : -- nat-s -> nat-s
    nat-factorial = lambda [n]
      case n
        zero-s (succ-c zero-c)
        succ-s (nat-mul (recur n.prev) n)
    #+end_src

* list

*** list-s

    #+begin_src cicada
    list-s : -- set-t -> set-t
    list-s = sum
      @ t : set-t
      null-c : (null-s t)
      cons-c :
        -- car : t
           cdr : (list-s t)
        -> (cons-s t)
    #+end_src

*** list-length

    #+begin_src cicada
    list-length : -- (list-s t) -> nat-s
    list-length = lambda [list]
      case list
        null-s zero-c
        cons-s (succ-c (recur list.cdr))
    #+end_src

*** list-append

    #+begin_src cicada
    list-append :
      -- (list-s t)
         (list-s t)
      -> (list-s t)
    list-append = lambda [ante succ]
      case succ
        null-s ante
        cons-s (cons-c succ.car (recur ante succ.cdr))
    #+end_src

*** list-map

    #+begin_src cicada
    list-map :
      -- (list-s a)
         -- a -> b
      -> (list-s b)
    list-map = lambda [list fun]
      case list
        null-s list
        cons-s (cons-c (fun list.car) (recur list.cdr fun))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    list-remove-first :
      -- t
         (list-s t)
      -> (list-s t)
    list-remove-first = lambda [x list]
      case list
        null-s list
        cons-s case (eq-p list.car x)
          true-s list.cdr
          false-s (cons-c list.car (recur list.cdr x))
    #+end_src

* eqv

*** eqv-s

    #+begin_src cicada
    eqv-s : -- t t -> set-t
    eqv-s = data
      @ [lhs rhs] : t
      eqv-c : (eqv-s v v)
    #+end_src

*** eqv-apply

    #+begin_src cicada
    eqv-apply :
      -- [x y] :: a
         (eqv-s x y)
         fun : -- a -> b
      -> (eqv-s (fun x) (fun y))
    eqv-apply = lambda [v fun] eqv-c
    #+end_src

*** eqv-swap

    #+begin_src cicada
    eqv-swap :
      -- [x y] :: t
         (eqv-s x y)
      -> (eqv-s y x)
    eqv-swap = lambda [v] eqv-c
    #+end_src

*** eqv-compose

    #+begin_src cicada
    eqv-compose :
      -- [x y z] :: t
         (eqv-s x y)
         (eqv-s y z)
      -> (eqv-s x z)
    eqv-compose = lambda [v u] eqv-c
    #+end_src

* nat

*** nat-even-p

    #+begin_src cicada
    nat-even-p : -- nat-s -> bool-s
    nat-even-p = lambda [x]
      case x
        zero-s true-c
        succ-s case x.prev
          zero-s false-c
          succ-s (recur x.prev.prev)
    #+end_src

*** nat-even-s

    #+begin_src cicada
    nat-even-s : -- nat-s -> set-t
    nat-even-s = sum
      @ nat : nat-s
      zero-even-c : (zero-even-s zero-c)
      even-plus-two-even-c :
        -- prev : (nat-even-s m)
        -> (even-plus-two-even-s (succ-c (succ-c m)))

    two-even : (nat-even-s (succ-c (succ-c zero-c)))
    two-even = lambda (even-plus-two-even-c zero-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    nat-add-associative :
      -- [x y z] : nat-s
      -> (eqv-s
           (nat-add (nat-add x y) z)
           (nat-add x (nat-add y z)))
    nat-add-associative = lambda [x y z]
      case z
        zero-s eqv-c
        succ-s (eqv-apply (recur x y z.prev) succ-c)
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    nat-add-commutative :
      -- [m n] : nat-s
      -> (eqv-s
           (nat-add m n)
           (nat-add n m))
    nat-add-commutative = lambda [m n]
      case n
        zero-s (nat-add-zero-commutative m)
        succ-s
          (eqv-compose
            (eqv-apply (recur m n.prev) succ-c)
            (nat-add-succ-commutative n.prev m))
    #+end_src

*** nat-add-zero-commutative

    #+begin_src cicada
    nat-add-zero-commutative :
      -- m : nat-s
      -> (eqv-s
           (nat-add m zero-c)
           (nat-add zero-c m))
    nat-add-zero-commutative = lambda [m]
      case m
        zero-s eqv-c
        succ-s (eqv-apply (recur m.prev) succ-c)
    #+end_src

*** nat-add-succ-commutative

    #+begin_src cicada
    nat-add-succ-commutative :
      -- [m n] : nat-s
      -> (eqv-s
           (nat-add (succ-c m) n)
           (succ-c (nat-add m n)))
    nat-add-succ-commutative = lambda [m n]
      case n
        zero-s eqv-c
        succ-s (eqv-apply (recur m n.prev) succ-c)
    #+end_src

* list

*** list-length-s -- re-imp function as relation

    #+begin_src cicada
    note
      list-length :
        -- list : (list-s t)
        -> length : nat-s
      list-length-s :
        -- list : (list-s t)
           length : nat-s
        -> set-t

    list-length-s : -- (list-t t) nat-s -> set-t
    list-length-s = sum
      @ list : (list-s t)
        length : nat-s
      zero-length-c : (zero-length-s null-c zero-c)
      succ-length-c :
        -- prev : (list-length-s list length)
        -> element :: t
           (cons-c element list)
           (succ-length-s (succ-c length))
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    list-map-preserve-list-length :
      -- fun :: -- a -> b
         list :: (list-s a)
         n :: nat-s
         (list-length-s list n)
      -> (list-length-s (list-map list fun) n)
    list-map-preserve-list-length = lambda [h]
      case h
        zero-length-s h
        succ-length-s (succ-length-c (recur h.prev))
    #+end_src

*** list-append-s

    #+begin_src cicada
    note in prolog, we will have :
      append([], Succ, Succ).
      append([Car | Cdr], Succ, [Car | ResultCdr]):-
        append(Cdr, Succ, ResultCdr).

    list-append-s : -- (list-s t) (list-s t) (list-s t) -> set-t
    list-append-s = sum
      @ [ante succ result] : (list-s t)
      zero-append-c : (zero-append-s null-c succ succ)
      succ-append-c :
        -- car :: t
           cdr :: (list-s t)
           result-cdr :: (list-s t)
           prev : (list-append-s cdr succ result-cdr)
        -> (succ-append-s
             (cons-c car cdr) succ
             (cons-c car result-cdr))
    #+end_src

* vect

*** vect-s

    #+begin_src cicada
    vect-s : -- nat-s set-t -> set-t
    vect-s = sum
      @ length : nat-s
        t : set-t
      null-vect-c : (null-vect-s zero-c t)
      cons-vect-c :
        -- car : t
           cdr : (vect-s length t)
        -> (cons-vect-s (succ-c length) t)
    #+end_src

*** vect-append

    #+begin_src cicada
    vect-append :
      -- (vect-s m t)
         (vect-s n t)
      -> (vect-s (nat-add m n) t)
    vect-append = lambda [x y]
      case y
        null-vect-s x
        cons-vect-s (cons-vect-c (recur y.car x y.cdr))
    #+end_src

*** vect-map

    #+begin_src cicada
    vect-map : -- (vect-s n a) (-- a -> b) -> (vect-s n b)
    vect-map = lambda [list fun]
      case list
        null-vect-s list
        cons-vect-s (cons-vect-c (fun list.car) (recur list.cdr fun))
    #+end_src

* order

*** preorder

***** preorder-t

      #+begin_src cicada
      note
        preorder is a thin category
        with at most one morphism from an object to another.

      preorder-t : class-tt
      preorder-t = class
        element-s : set-t

        pre-s :
          -- element-s element-s
          -> set-t

        pre-reflexive :
          -- element-s % a
          -> (pre-s a a)

        pre-transitive :
          -- (pre-s a b)
             (pre-s b c)
          -> (pre-s a c)
      #+end_src

*** partial-order

***** partial-order-t

      #+begin_src cicada
      partial-order-t <: preorder-t
      partial-order-t = class
        element-eqv-s :
          -- element-s
             element-s
          -> set-t
        pre-anti-symmetric :
          -- (pre-s a b)
             (pre-s b a)
          -> (element-eqv-s a b)
      #+end_src

*** eqv-relation

***** eqv-relation-t

      #+begin_src cicada
      eqv-relation-t <: preorder-t
      eqv-relation-t = class
        pre-symmetric :
          -- (pre-s a b)
          -> (pre-s b a)
      #+end_src

*** total-order

***** total-order-t

      #+begin_src cicada
      total-order-t <: partial-order-t
      total-order-t = class
        pre-connex :
          -- [a b] : element-s
          -> (union (pre-s a b) (pre-s b a))
      #+end_src

* unique

*** (unique ... under ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s = macro
      (-- y : $t -> ($eqv-s $x y))
    #+end_src

*** (unique ... under ... such-that ...)

    #+begin_src cicada
    unique [$x : $t] under $eqv-s such-that $theorem  = macro
      * $x $theorem
        -- y : $t
           y $theorem
        -> ($eqv-s $x y)
    #+end_src

* category

*** category-t

    #+begin_src cicada
    category-t : class-tt
    category-t = class
      object-s : set-t
      arrow-s : -- object-s object-s -> set-t
      arrow-eqv-s : -- (arrow-s a b) (arrow-s a b) -> set-t

      identity : -- object-s % a -> (arrow-s a a)

      compose : -- (arrow-s a b) (arrow-s b c) -> (arrow-s a c)

      identity-neutral-left :
        -- (arrow-s a b) % f
        -> (arrow-eqv-s (compose (identity a) f) f)

      identity-neutral-right :
        -- (arrow-s a b) % f
        -> (arrow-eqv-s (compose f (identity b)) f)

      compose-associative :
        -- (arrow-s a b) % f
           (arrow-s b c) % g
           (arrow-s c d) % h
        -> (arrow-eqv-s
             (compose f (compose g h))
             (compose (compose f g) h))

      arrow-eqv-relation :
        -- [a b] :: object-s
        -> (eqv-relation-&
             element-s = (arrow-s a b)
             pre-s = lambda arrow-eqv-s)
    #+end_src

*** basic relation

***** category.arrow-inverse-s

      #+begin_src cicada
      category.arrow-inverse-s :
        -- (arrow-s a b)
           (arrow-s b a)
        -> set-t
      category.arrow-inverse-s = lambda [f g]
        * (arrow-eqv-s (compose f g) (identity a))
          (arrow-eqv-s (compose g f) (identity b))
      #+end_src

***** category.isomorphic-object-s

      #+begin_src cicada
      category.isomorphic-object-s : -- object-s object-s -> set-t
      category.isomorphic-object-s = lambda [a b]
        * (arrow-s a b) % f
          (arrow-s b a) % g
          (arrow-eqv-s (compose f g) (identity a))
          (arrow-eqv-s (compose g f) (identity b))
      #+end_src

*** universal construction

***** category.product-object-s

      #+begin_src cicada
      category.product-object-s :
        -- object-s % a
           object-s % b
           object-s % p
           (arrow-s p a) % pa
           (arrow-s p b) % pb
        -> set-t
      category.product-object-s = lambda [a b p pa pb]
        -- object-s % q
           (arrow-s q a) % qa
           (arrow-s q b) % qb
        -> unique (arrow-s q p) % qp
           under arrow-eqv-s such-that
             * (arrow-eqv-s qa (compose qp pa))
               (arrow-eqv-s qb (compose qp pb))
      #+end_src

***** category.coproduct-object-s

      #+begin_src cicada
      category.coproduct-object-s :
        -- object-s % a
           object-s % b
           object-s % p
           (arrow-s a p) % ap
           (arrow-s b p) % bp
        -> set-t
      category.product-object-s = lambda [a b p ap bp]
        -- object-s % q
           (arrow-s a q) % aq
           (arrow-s a q) % bq
        -> unique (arrow-s p q) % pq
           under arrow-eqv-s such-that
             * (arrow-eqv-s aq (compose ap pq))
               (arrow-eqv-s bq (compose bp pq))
      #+end_src

***** category.initial-object-s

      #+begin_src cicada
      category.initial-object-s : -- object-s -> set-t
      category.initial-object-s = lambda [a]
        -- object-s % b
        -> unique (arrow-s a b) % f under arrow-eqv-s
      #+end_src

***** category.terminal-object-s

      #+begin_src cicada
      category.terminal-object-s : -- object-s -- set-t
      category.terminal-object-s = lambda [a]
        -- object-s % b
        -> unique (arrow-s b a) % f under arrow-eqv-s
      #+end_src

*** other structure as category

***** preorder.as-category

      #+begin_src cicada
      note
        to view a preorder as a category
        we simple view all arrow of the same type as eqv

      preorder.as-category : category-t
      preorder.as-category = category-@
        object-s = element-s

        arrow-s = lambda pre-s

        arrow-eqv-s = lambda [_ _] unit-s

        identity = lambda pre-reflexive

        compose = lambda pre-transitive

        identity-neutral-left = lambda [_] unit-c

        identity-neutral-right = lambda [_] unit-c

        compose-associative = lambda [_ _ _] unit-c
      #+end_src

*** build new category from old category

***** category.opposite

      #+begin_src cicada
      category.opposite : category-t
      category.opposite = category-@
        object-s = this.object-s

        arrow-s :
          -- object-s object-s
          -> set-t
        arrow-s = lambda [a b] (this.arrow-s b a)

        arrow-eqv-s :
          -- (this.arrow-s b a) (this.arrow-s b a)
          -> set-t
        arrow-eqv-s = lambda this.arrow-eqv-s

        identity :
          -- object-s % a
          -> (arrow-s a a)
        identity = lambda this.identity

        compose :
          -- (this.arrow-s b a)
             (this.arrow-s c b)
          -> (this.arrow-s c a)
        compose = lambda [f g] (this.compose g f)

        identity-neutral-left :
          -- (this.arrow-s b a) % f
          -> (arrow-eqv-s (this.compose f (identity a)) f)
        identity-neutral-left = lambda this.identity-neutral-right

        identity-neutral-right :
          -- (this.arrow-s b a) % f
          -> (arrow-eqv-s (this.compose (identity b) f) f)
        identity-neutral-right = lambda this.identity-neutral-left

        compose-associative :
          -- (this.arrow-s b a) % f
             (this.arrow-s c b) % g
             (this.arrow-s d c) % h
          -> (arrow-eqv-s
               (this.compose (this.compose h g) f)
               (this.compose h (this.compose g f)))
        compose-associative = lambda [f g h]
          (this.arrow-eqv-relation.pre-symmetric
            (this.compose-associative h g f))
      #+end_src

***** category-product

      #+begin_src cicada
      category-product : -- category-t category-t -> category-t
      category-product = lambda
        let #1 #2 in category-@

        object-s = lambda * #1.object-s #2.object-s

        arrow-s = lambda [a b]
          * (#1.arrow-s a.1 b.1)
            (#2.arrow-s a.2 b.2)

        arrow-eqv-s = lambda [lhs rhs]
          * (#1.arrow-eqv-s lhs.1 rhs.1)
            (#2.arrow-eqv-s lhs.2 rhs.2)

        identity = lambda [a]
          * (#1.identity a.1)
            (#2.identity a.2)

        compose = lambda [f g]
          * (#1.compose f.1 g.1)
            (#2.compose f.2 g.2)

        identity-neutral-left = lambda [f]
          * (#1.identity-neutral-left f.1)
            (#2.identity-neutral-left f.2)

        identity-neutral-right = lambda [f]
          * (#1.identity-neutral-right f.1)
            (#2.identity-neutral-right f.2)

        compose-associative = lambda [f g h]
          * (#1.compose-associative f.1 g.1 h.1)
            (#2.compose-associative f.2 g.2 h.2)
      #+end_src

* product-closed-category-t

  #+begin_src cicada
  product-closed-category-t <: category-t
  product-closed-category-t = class
    product :
      -- object-s % a
         object-s % b
      -> object-s % p
         (arrow-s p a) % pa
         (arrow-s p b) % pb
         (product-object-s a b p pa pb)
  #+end_src

* void-category

*** void-arrow-s

    #+begin_src cicada
    void-arrow-s : -- void-s void-s -> set-t
    void-arrow-s = data
      @ [ante succ] : void-s
      void-arrow-c : (void-arrow-s ante succ)
    #+end_src

*** void-arrow-eqv-s

    #+begin_src cicada
    void-arrow-eqv-s :
      -- (void-arrow-s a b)
         (void-arrow-s a b)
      -> set-t
    void-arrow-eqv-s = data
      @ [lhs rhs] : (void-arrow-s a b)
      void-arrow-eqv-c : (void-arrow-eqv-s lhs rhs)
    #+end_src

*** void-category

    #+begin_src cicada
    void-category : category-t
    void-category = category-@
      object-s = lambda void-s
      arrow-s = lambda void-arrow-s
      arrow-eqv-s = lambda void-arrow-eqv-s

      identity :
        -- void-s % a
        -> (void-arrow-s a a)
      identity = lambda [_] void-arrow-c

      compose = lambda [_ _] void-arrow-c

      identity-neutral-left :
        -- (void-arrow-s a b) % f
        -> (void-arrow-eqv-s void-arrow-c f)
      identity-neutral-left = lambda [_] void-arrow-eqv-c

      identity-neutral-right :
        -- (void-arrow-s a b) % f
        -> (void-arrow-eqv-s void-arrow-c f)
      identity-neutral-right = lambda [_] void-arrow-eqv-c

      compose-associative :
        -- (void-arrow-s a b) % f
           (void-arrow-s b c) % g
           (void-arrow-s c d) % h
        -> (void-arrow-eqv-s void-arrow-eqv-c void-arrow-eqv-c)
      compose-associative = lambda [_ _ _] void-arrow-eqv-c
    #+end_src

* graph-t

*** graph-t

    #+begin_src cicada
    note
      different between graph and category is that,
      composing [linking] two edges does not give you edge but path.

    graph-t : class-tt
    graph-t = class
      node-s : set-t
      edge-s : -- node-s node-s -> set-t
    #+end_src

*** graph.path-s

    #+begin_src cicada
    graph.path-s : -- node-s node-s -> set-t
    graph.path-s = sum
      @ [start end] : node-s
      node-path-c :
        -- node-s % node
        -> (node-path-s node node)
      edge-path-c :
        -- (edge-s a b) % edge
        -> (edge-path-s a b)
      link-path-c :
        -- (path-s a b) % first
           (path-s b c) % next
        -> (link-path-s a c)
    #+end_src

*** graph.path-eqv-s

    #+begin_src cicada
    graph.path-eqv-s : -- (path-t a b) (path-s a b) -> set-t
    graph.path-eqv-s = sum
      @ [lhs rhs] : (path-s a b)
      refl-path-eqv-c :
        -- (path-s a b) % p
        -> (refl-path-eqv-s p p)
      node-left-path-eqv-c :
        -- (path-s a b) % p
        -> (node-left-path-eqv-s
             (link-path-c (node-path-c a) p)
             p)
      node-right-path-eqv-c :
        -- (path-s a b) % p
        -> (node-right-path-eqv-s
             (link-path-c p (node-path-c b)))
             p
      associative-path-eqv-c :
        -- (path-s a b) % p
           (path-s b c) % q
           (path-s c d) % r
        -> (associative-path-eqv-s
             (link-path-c p (link-path-c q r)))
             (link-path-c (link-path-c p q) r)
    #+end_src

*** graph.as-free-category

    #+begin_src cicada
    graph.as-free-category : category-t
    graph.as-free-category = category-@
      object-s = lambda node-s
      arrow-s = lambda path-s
      arrow-eqv-s = lambda path-eqv-s

      identity :
        -- node-s % a
        -> (path-s a a)
      identity = lambda node-path-c

      compose = lambda link-path-c

      identity-neutral-left :
        -- (path-s a b) % f
        -> (path-eqv-s
             (link-path-c (node-path-c a) f)
             f)
      identity-neutral-left = lambda node-left-path-eqv-c

      identity-neutral-right :
        -- (path-s a b) % f
        -> (path-eqv-s
             (link-path-c f (node-path-c b))
             f)
      identity-neutral-right = lambda node-right-path-eqv-c

      compose-associative :
        -- (path-s a b) % f
           (path-s b c) % g
           (path-s c d) % h
        -> (path-eqv-s
             (link-path-c f (link-path-c g h))
             (link-path-c (link-path-c f g) h))
      compose-associative = lambda associative-path-eqv-c
    #+end_src

* nat-order-category

*** nat-lteq-s

    #+begin_src cicada
    nat-lteq-s : -- nat-s nat-s -> set-t
    nat-lteq-s = sum
      @ [l r] : nat-s
      zero-lteq-c : (zero-lteq-s zero-c r)
      succ-lteq-c :
        -- prev : (nat-lteq-s l r)
        -> (succ-lteq-s (succ-c l) (succ-c r))
    #+end_src

*** nat-non-negative

    #+begin_src cicada
    nat-non-negative : -- n : nat-s -> (nat-lteq-s zero-c n)
    nat-non-negative = lambda zero-lteq-c
    #+end_src

*** nat-lteq-reflexive

    #+begin_src cicada
    nat-lteq-reflexive : -- n : nat-s -> (nat-lteq-s n n)
    nat-lteq-reflexive = lambda [n]
      case n
        zero-s zero-lteq-c
        succ-s (succ-lteq-c (recur n.prev))
    #+end_src

*** nat-lteq-transitive

    #+begin_src cicada
    nat-lteq-transitive :
      -- (nat-lteq-s a b)
         (nat-lteq-s b c)
      -> (nat-lteq-s a c)
    nat-lteq-transitive = lambda [x y]
      case x
        zero-lteq-s zero-lteq-c
        succ-lteq-s (succ-lteq-c (recur x.prev y.prev))
    #+end_src

*** nat-lt-s

    #+begin_src cicada
    nat-lt-s : -- nat-s nat-s -> set-t
    nat-lt-s = lambda [l r]
      (nat-lteq-s (succ-c l) r)
    #+end_src

*** nat-archimedean-property

    #+begin_src cicada
    nat-archimedean-property :
      -- x : nat-s
      -> (* y : nat-s
            (nat-lt-s x y))
    nat-archimedean-property = lambda [x]
      (* (succ-c x) (nat-lteq-reflexive (succ-c x)))
    #+end_src

*** nat-order-category

    #+begin_src cicada
    nat-order-category : category-t
    nat-order-category = category-@
      object-s = lambda nat-s
      arrow-s = lambda nat-lteq-s
      arrow-eqv-s = lambda eqv-s

      identity = lambda nat-lteq-reflexive

      compose  = lambda nat-lteq-transitive

      identity-neutral-left = lambda [x]
        case x
          zero-lteq-s eqv-c
          succ-lteq-s (eqv-apply (recur x.prev) succ-lteq-c)

      identity-righ = lambda [x]
        case x
          zero-lteq-s eqv-c
          succ-lteq-s (eqv-apply (recur x.prev) succ-lteq-c)

      compose-associative = lambda [f g h]
        case [f g h]
          [zero-lteq-s _ _] eqv-c
          [succ-lteq-s succ-lteq-s succ-lteq-s]
            (eqv-apply (recur f.prev g.prev h.prev) succ-lteq-c)
    #+end_src

* groupoid

*** groupoid-t

    #+begin_src cicada
    groupoid-t <: category-t
    groupoid-t = class
      inverse :
        -- (arrow-s a b) % f
        -> (arrow-s b a) % g
           (arrow-inverse-s f g)
    #+end_src

* >< nat-total-order

* monoid

*** monoid-t

    #+begin_src cicada
    monoid-t : class-tt
    monoid-t = class
      element-s : set-t

      element-eqv-s :
        -- element-s element-s
        -> set-t

      unit : element-s

      product :
        -- element-s element-s
        -> element-s

      unit-neutral-left :
        -- a : element-s
        -> (element-eqv-s (product a unit) a)

      unit-neutral-right :
        -- a : element-s
        -> (element-eqv-s (product unit a) a)

      product-associative :
        -- a : element-s
           b : element-s
           c : element-s
        -> (element-eqv-s
             (product a (product b c))
             (product (product a b) c))
    #+end_src

*** monoid.as-category

    #+begin_src cicada
    monoid.as-category : category-t
    monoid.as-category = category-@
      object-s = lambda unit-s
      arrow-s = lambda [_ _] element-s
      arrow-eqv-s = lambda element-eqv-s
      identity = lambda [_] unit
      compose = lambda product
      identity-neutral-left = lambda unit-neutral-left
      identity-neutral-right = lambda unit-neutral-right
      compose-associative = lambda product-associative
    #+end_src

* >< group

* >< abelian-group

* >< ring

* >< field

* >< vector-space

* >< limit

* functor

*** functor-t

    #+begin_src cicada
    note
      endofunctor of set-category

    functor-t : class-tt
    functor-t = class
      fun-s : -- set-t -> set-t
      map : -- (fun-t a) (-- a -> b) -> (fun-s b)
    #+end_src

*** list-functor

    #+begin_src cicada
    list-functor : functor-t
    list-functor = functor-@
      fun-s = lambda list-s
      map = lambda [list fun]
        case list
          null-s null-c
          cons-s
            (cons-c (fun list.car) (recur list.cdr fun))
    #+end_src

* const

*** const-s

    #+begin_src cicada
    const-s : -- set-t set-t -> set-t
    const-s = data
      @ [c a] : set-t
      const-c : -- value : c -> (const-s c a)
    #+end_src

*** const-functor

    #+begin_src cicada
    const-functor : -- set-t -> functor-t
    const-functor = lambda
      let c in functor-@
      fun-s = lambda (const-s c)

      map : -- (const-s c a) (-- a -> b) -> (const-s c b)
      map = lambda [_]
    #+end_src

* monad

*** monad-t

    #+begin_src cicada
    monad-t <: functor-t
    monad-t = class
      pure : -- t -> (fun-s t)
      bind : -- (fun-s a) (-- a -> (fun-s b)) -> (fun-s b)
    #+end_src

*** monad.compose

    #+begin_src cicada
    monad.compose :
      -- (-- a -> (fun-s b))
         (-- b -> (fun-s c))
      -> (-- a -> (fun-s c))
    monad.compose = lambda [f g]
      (lambda [a] (bind (f a) g))
    #+end_src

*** monad.flatten

    #+begin_src cicada
    monad.flatten :
      -- (fun-s (fun-s a))
      -> (fun-s a)
    monad.flatten = lambda [m] (bind m (lambda))
    #+end_src

*** list-monad

    #+begin_src cicada
    list-monad : monad-t
    list-monad = monad-@
      pure = lambda [x] (cons-c x null-c)
      bind = lambda [list fun]
        case list
          null-s null-c
          cons-s (list-append (fun list.car) (recur list.cdr fun))
    #+end_src

* maybe

*** maybe-s

    #+begin_src cicada
    maybe-s : -- set-t -> set-t
    maybe-s = sum
      @ t : set-t
      none-c : (none-s t)
      just-c :
        -- value : t -> (just-s t)
    #+end_src

*** maybe-functor

    #+begin_src cicada
    maybe-functor : functor-t
    maybe-functor = functor-@
      fun-s = lambda maybe-s
      map = lambda [maybe fun]
        case maybe
          none-s none-c
          just-s (just-c (fun maybe.value))
    #+end_src

*** maybe-monad

    #+begin_src cicada
    maybe-monad : monad-t
    maybe-monad = monad-@
      pure = lambda just-c
      bind = lambda [maybe fun]
        case maybe
          none-s none-c
          just-s (fun maybe.value)
    #+end_src

* state

*** state-s

    #+begin_src cicada
    state-s : -- set-t set-t -> set-t
    state-s = lambda [s a] -- s -> (* s a)
    #+end_src

*** state-monad

    #+begin_src cicada
    state-monad : -- set-t -> monad-t
    state-monad = lambda [s] monad-@
      fun-s = lambda (state-s s)
      map : -- (state-s a s) (-- a -> b)
            -> (state-s b s)
      map : -- (-- s -> (* s a)) (-- a -> b)
            -> (-- s -> (* s b))
      map = lambda [state fun]
        (lambda [s] (fun (state s)))
      pure = lambda [value] {value}
      bind = lambda [state fun] {state fun apply}
    #+end_src

* tree

*** tree-s

    #+begin_src cicada
    tree-s : -- set-t -> set-t
    tree-s = sum
      @ t : set-t
      leaf-c :
        -- t % value -> (leaf-s t)
      branch-c :
        -- (tree-s t) % [left right]
        -> (branch-s t)
    #+end_src

*** tree-functor

    #+begin_src cicada
    tree-functor : functor-t
    tree-functor = functor-@
      fun-s = lambda tree-s
      map = lambda [tree fun]
        case tree
          leaf-s (leaf-c (fun tree.value))
          branch-s
            (branch-c
              (recur tree.left fun)
              (recur tree.right fun))
    #+end_src

*** tree-zip

    #+begin_src cicada
    tree-zip :
      -- (tree-s a)
         (tree-s b)
      -> (maybe-s (tree-s (* a b)))
    tree-zip = lambda [x y]
      case [x y]
        [leaf-s leaf-s]
          (pure (leaf-c (* x.value y.value)))
        [branch-s branch-s]
          do left <- (recur x.left y.left)
             right <- (recur x.right y.right)
             (pure (branch-c left right))
        else none-c
    #+end_src

*** tree-numbering

    #+begin_src cicada
    tree-numbering :
      -- (tree-s t)
      -> (state-s (tree-s nat-s))
    tree-numbering = lambda [tree]
      case tree
        leaf-s {dup inc swap leaf-c}
        branch-s
          do left <- (recur tree.left)
             right <- (recur tree.right)
             (branch-c left right)
    #+end_src

* int

*** >< int-s

*** >< mod-s

*** gcd-s

    #+begin_src cicada
    gcd-s : -- int-s int-s int-s -> set-t
    gcd-s = sum
      @ [x y d] : int-s
      zero-gcd-c : (zero-gcd-s x zero-c x)
      mod-gcd-c :
        -- gcd : (gcd-s x y d)
           mod : (mod-s x y z)
        -> (mod-gcd-s y z d)
    #+end_src

* set-category

*** set-morphism-t

    #+begin_src cicada
    set-morphism-t : class-tt
    set-morphism-t = class
      ante : set-t
      succ : set-t

      morphism : -- ante -> succ
    #+end_src

*** set-morphism-eqv-t

    #+begin_src cicada
    set-morphism-eqv-t : class-tt
    set-morphism-eqv-t = class
      lhs : set-morphism-& a b
      rhs : set-morphism-& a b

      morphism-eqv :
        -- x : a
        -> (eqv-s (lhs.morphism x) (rhs.morphism x))
    #+end_src

*** set-category

    #+begin_src cicada
    set-category : category-tt
    set-category = category-@
      object-t : class-tt
      object-t = set-t

      arrow-t : -- set-t set-t -> class-tt
      arrow-t = lambda [a b]
        set-morphism-& a b

      arrow-eqv-t :
        -- set-morphism-& a b
           set-morphism-& a b
        -> class-tt
      arrow-eqv-t = lambda [lhs rhs]
        set-morphism-eqv-& lhs rhs

      identity :
        -- set-t % a
        -> set-morphism-& a a
      identity = lambda [_] set-morphism-@
        morphism = lambda

      compose :
        -- set-morphism-& a b
           set-morphism-& b c
        -> set-morphism-& a c
      compose = lambda [f g] set-morphism-@
        morphism = lambda f.morphism g.morphism

      identity-neutral-left :
        -- f : set-morphism-& a b
        -> set-morphism-eqv-& (compose f (identity b)) f
      identity-neutral-left = lambda [f] set-morphism-eqv-@
        lhs : set-morphism-& a b
        lhs = (compose f (identity b))
        rhs : set-morphism-& a b
        rhs = f
        morphism-eqv :
          -- x : a
          -> (eqv-s (f.morphism x) (f.morphism x))
        morphism-eqv = lambda [x] eqv-c

      identity-neutral-right :
        -- f : set-morphism-& a b
        -> set-morphism-eqv-& (compose (identity a) f) f
      identity-neutral-right = lambda [f] set-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c

      compose-associative :
        -- f : set-morphism-& a b
           g : set-morphism-& b c
           h : set-morphism-& c d
        -> set-morphism-eqv-&
             lhs = (compose f (compose g h))
             rhs = (compose (compose f g) h)
      compose-associative = lambda [f g h] set-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c
    #+end_src

*** set-category -- without type

    #+begin_src cicada
    set-category : category-tt
    set-category = category-@
      object-t = set-t

      arrow-t = lambda [a b]
        set-morphism-& a b

      arrow-eqv-t = lambda [lhs rhs]
        set-morphism-eqv-& lhs rhs

      identity = lambda [_] set-morphism-@
        morphism = lambda

      compose = lambda [f g] set-morphism-@
        morphism = lambda f.morphism g.morphism

      identity-neutral-left = lambda [_] set-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c

      identity-neutral-right = lambda [_] set-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c

      compose-associative = lambda [_ _ _] set-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c
    #+end_src

* preorder-category

*** preorder-morphism-t

    #+begin_src cicada
    preorder-morphism-t : class-tt
    preorder-morphism-t = class
      ante : preorder-t
      succ : preorder-t

      morphism : -- ante.element-s -> succ.element-s

      morphism-respect-pre-relation :
        -- (ante.pre-s x y)
        -> (succ.pre-s (morphism x) (morphism y))
    #+end_src

*** preorder-morphism-eqv-t

    #+begin_src cicada
    preorder-morphism-eqv-t : class-tt
    preorder-morphism-eqv-t = class
      lhs : preorder-morphism-& a b
      rhs : preorder-morphism-& a b

      morphism-eqv :
        -- x : a.element-s
        -> (eqv-s (lhs.morphism x) (rhs.morphism x))
    #+end_src

*** preorder-category

    #+begin_src cicada
    preorder-category : category-tt
    preorder-category = category-@
      object-t : class-tt
      object-t = preorder-t

      arrow-t : -- preorder-t preorder-t -> class-tt
      arrow-t = lambda [a b]
        preorder-morphism-& a b

      arrow-eqv-t :
        -- preorder-morphism-& a b
           preorder-morphism-& a b
        -> class-tt
      arrow-eqv-t = lambda [lhs rhs]
        preorder-morphism-eqv-& lhs rhs

      identity :
        -- preorder-t % a
        -> preorder-morphism-& a a
      identity = lambda [_] preorder-morphism-@
        morphism = lambda
        morphism-respect-pre-relation = lambda

      compose :
        -- preorder-morphism-& a b
           preorder-morphism-& b c
        -> preorder-morphism-& a c
      compose = lambda [f g] preorder-morphism-@
        morphism = lambda f.morphism g.morphism
        morphism-respect-pre-relation = lambda
          f.morphism-respect-pre-relation
          g.morphism-respect-pre-relation

      identity-neutral-left = lambda [f] preorder-morphism-eqv-@
        morphism-eqv = lambda [x] eqv-c

      identity-neutral-right = lambda [f] preorder-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c

      compose-associative = lambda [f g h] preorder-morphism-eqv-@
        morphism-eqv = lambda [_] eqv-c
    #+end_src

* category-category

*** category-morphism-tt

    - a category-morphism-tt is a functor between two categories.

    - a functor between two categories is a natural-construction
      of the structure of [ante : category-tt]
      in the structure of [succ : category-tt]

    #+begin_src cicada
    category-morphism-tt : class-ttt
    category-morphism-tt = class
      ante : category-tt
      succ : category-tt

      object-map :
        -- ante.object-t
        -> succ.object-t

      arrow-map :
        -- (ante.arrow-t a b)
        -> (succ.arrow-t (object-map a) (object-map b))

      arrow-map-respect-compose :
        -- (ante.arrow-t a b) % f
           (ante.arrow-t b c) % g
        -> (succ.arrow-eqv-t
             (arrow-map (ante.compose f g))
             (succ.compose (arrow-map f) (arrow-map g)))


      arrow-map-respect-identity :
        -- a : ante.object-t
        -> (succ.arrow-eqv-t
             (succ.identity (object-map a))
             (arrow-map (ante.identity a)))
    #+end_src

*** category-morphism-eqv-tt

    #+begin_src cicada
    category-morphism-eqv-tt : class-ttt
    category-morphism-eqv-tt = class
      lhs : category-morphism-&& a b
      rhs : category-morphism-&& a b

      morphism-eqv :
        ><><><
    #+end_src

*** category-category

    #+begin_src cicada
    category-category : category-ttt
    category-category = category-@
      object-tt : category-tt
      object-tt = lambda category-tt

      arrow-tt :
        -- category-tt category-tt
        -> class-ttt
      arrow-tt = lambda [a b]
        category-morphism-&& a b

      arrow-eqv-tt :
        -- category-morphism-&& a b
           category-morphism-&& a b
        -> class-ttt
      arrow-eqv-tt = lambda [lhs rhs]
        category-morphism-eqv-&& lhs rhs

      ><><><
    #+end_src
