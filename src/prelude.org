#+title: prelude

* [todo-stack]

*** finish the syntax change

*** convention about function arguments

    - x -
      which argument to (case) ?
      take `nat-add` as a example

*** type-t as a category

***** problem

      - how to view type-t as a category ?
        and formalize its feature in the language itself.

      - x -
        by doing so
        I hope to clarify the meaning of stack and arrow in cicada

      - k -
        maybe we can say
        the syntax is optimized for function-completion object-product

      - x -
        if so,
        we must get rid of explicit (* a b)
        by eqv it with [a b]

      - k -
        this means "stack as product built-in the language"

      - x -
        by emphasizing this
        our aim will be really distinguishable
        namely
        design the syntax
        so that it is easier to express composition

      - k -
        can we say we are constructing a functor here ?

      - x -
        yes
        our stack functor will make more arrows composable
        and our arrows can be composed in ways like :

        f : (-> t1 t2 -- t3 t4)
        g : (-> t t3 t4 -- t6 t7)
        h : (-> t t1 t2 -- t6 t7)
        t t1 t2 -- f
        t t3 t4 -- g
        t6 t7

        f : (-> t1 t2 -- t t3 t4)
        g : (-> t3 t4 -- t6 t7)
        h : (-> t t1 t2 -- t t6 t7)
        t1 t2 -- f
        t t3 t4 -- g
        t t6 t7

        ------

        f : (t1, t2) -> (t3, t4)
        g : (t, t3, t4) -> (t6, t7)
        h : (t, t1, t2) -> (t6, t7)

        f (t, t1, t2) = (t, t3, t4)
        g (t, t3, t4) = (t6, t7)

        f : (t1, t2) -> (t, t3, t4)
        g : (t3, t4) -> (t6, t7)
        h : (t, t1, t2) -> (t, t6, t7)

        f (t1, t2) = (t, t3, t4)
        g (t, t3, t4) = (t, t6, t7)

***** ><><>< stack as product built-in the language

      - take swap as an example  (a, b) => (b, a)

      - also the assoc law (a, (b, c)) => ((a,  b), c)

***** iso-t -- as a (+class)

***** universe

      - type-t = 1 universe
        type-t : 2 universe

      - nat-t : 1 universe
        (* nat-t nat-t) : 1 universe
        (+ nat-t | nat-t) : 1 universe
        (-> nat-t -- nat-t) : 1 universe

      - 1 universe : 2 universe

      - how about the order relation for those universes ?

*** test

***** use number theory -- to test type-checker as prover

*** syntax

***** syntax for renaming fields of record type

      - to use convention naming for group and so on

***** what is the logic programming interface of the type system ?

*** algebraic-data-type

***** subtype relation as order relation for algebraic data type

      - for example :
        a < a + b
        a < a * 2

* [note]

*** (:) (%) (<) (>)

    - just like `=` in some language can form type
      [in cicada, eqv-c and eqv-t]
      should these form types too ?

*** (+type)

    - type of data in data-field must be of type type-t
      thus, function can not be stored in data-field

*** -ct is always a subtype of record type

*** (@) -- syntax for unnamed record type

    - while in (+type)
      we define named record type

*** level of types

    | 0 | object                          |
    | 1 | type, union-type, quotient-type |
    | 2 | type-class, type-t              |

*** object as type

    - object are just like type
      just without sumtype
      only product type

*** subtype relation between classes

    - c1 < c2
      if c1 is more special then c2
      if c1 has more interface functions than c2

*** functor

***** functor type-class in haskell

      - in haskell the category under consideration
        is the category of types
        where types are objects
        functions are morphisms

      - the functor type-class in haskell
        is a endo-functor from this category to itself

        thus a functor instance in haskell
        is a type constructor of type (-> type -- type)

        thus the functor type-class in haskell
        is limited in the sense of functor
        because type constructor in haskell
        is limited in the sense of function of type (-> type -- type)

      - endo-functors are containers

***** a functor might as well be called a natural-construction

      - thus the name of natural-transformation make sense

*** natural-transformation

***** natural-transformation is a level up map

      - the definition of natural-transformation
        maps object to arrow
        and arrow to square

*** unification

***** what to unify ?

      - in cicada
        <term> := <type-term>, <union-term>, <data-term>
        --- (data <hypo>), (type <hypo>)
        --- <trunk>
        <type-term>  := (<type-constructor> <term> ...)
        <union-term> := (<union-constructor> <term> ...)
        <data-term>  := (<data-constructor> <term> ...)
        <trunk> := function application to be reduced

        data-bind-dict -- <hypo> to data <term>
        type-bind-dict -- <hypo> to type <term>

        <trunk> will be formed,
        when among arguments of a function application
        there is a <hypo> that is not bound to data
        or there is a non-reduce-able <trunk>

      - in logic
        <term> := <predicate-term>, <var>, <constant>
        <predicate-term> := (<predicate-symbol> <term> ...)

***** feature structures

      - <var> with two fields type and data,
        can be viewed as feature structures
        in unification theory

*** vector vs list

    - vector and list have the same data-constructor shape

    - it is *not* true that
      every function can be defined for vector
      can also be defined for list

      - for example zip can be defined for vector of same length

      - when defining zip for vector
        more informations in type
        can help to rule out some not meaningful cases

      list -> list
      vector -> vector
      can *not* be composed to
      list -> vector

    - it is true that
      every function can be defined for list
      can also be defined for vector

      - by dropping the length information

      vector -> vector
      list -> list
      can be composed
      vector -> list

    - vector can be viewed as subtype of list
      we can assert so
      and use this subtype relation to reuse functions

      - in some case [when namings are so different]
        we also need to assert relation between
        fields of type and data-constructors

* bool

*** bool-t

    #+begin_src cicada
    (: bool-t type-t)
    (= bool-t
       (type
         (-> -- true-t)
         (-> -- false-t)))
    #+end_src

* nat

*** nat-t

    #+begin_src cicada
    (: nat-t type-t)
    (= nat-t
       (type
         (-> -- zero-t)
         (-> prev : nat-t -- succ-t)))
    #+end_src

*** nat-add

    #+begin_src cicada
    (: nat-add (-> nat-t nat-t -- nat-t))
    (= nat-add
       (let m n)
       (case n
         (zero-t m)
         (succ-t m n.prev recur succ-c)))
    #+end_src

*** nat-mul

    #+begin_src cicada
    (: nat-mul (-> nat-t nat-t -- nat-t))
    (= nat-mul
       (let m n)
       (case n
         (zero-t n)
         (succ-t m n.prev recur m nat-add)))
    #+end_src

*** nat-factorial

    #+begin_src cicada
    (: nat-factorial (-> nat-t -- nat-t))
    (= nat-factorial
       (let n)
       (case n
         (zero-t n succ-c)
         (succ-t n.prev recur n nat-mul)))
    #+end_src

* list

*** list-t

    #+begin_src cicada
    (: list-t (-> type-t -- type-t))
    (= list-t
       (type (@ type : type-t)
         (-> -- type null-t)
         (-> car : type
             cdr : type list-t
          -- type cons-t)))
    #+end_src

*** list-length

    #+begin_src cicada
    (: list-length (-> type list-t -- nat-t))
    (= list-length
       (let list)
       (case list
         (null-t zero-c)
         (cons-t list.cdr recur succ-c)))
    #+end_src

*** list-append

    #+begin_src cicada
    (: list-append
       (-> type list-t
           type list-t
        -- type list-t))
    (= list-append
       (let ante succ)
       (case succ
         (null-t ante)
         (cons-t succ.car ante succ.cdr recur cons-c)))
    #+end_src

*** list-map

    #+begin_src cicada
    (: list-map
       (-> a list-t
           (-> a -- b)
        -- b list-t))
    (= list-map
       (let list fun)
       (case list
         (null-t list)
         (cons-t list.car fun list.cdr {fun} recur cons-c)))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    (: list-remove-first
       (-> type
           type list-t
        -- type list-t))
    (= list-remove-first
       (let x list)
       (case list
         (null-t list)
         (cons-t (case [list.car x eq-p]
                   (true-t  list.cdr)
                   (false-t list.car list.cdr x recur cons-c)))))
    #+end_src

* eqv

*** eqv-t

    #+begin_src cicada
    (: eqv-t
       (-> type :: type-t
           type
        -- type-t))
    (= eqv-t
       (type
         (-> value :: type
          -- value value eqv-t)))
    #+end_src

*** eqv-apply

    #+begin_src cicada
    (: eqv-apply
       (-> [a b] :: type-t
           [x y] :: a
           x y eqv-t
           fun : (-> a -- b)
        -- x fun y fun eqv-t))
    (= eqv-apply eqv-c)
    #+end_src

*** eqv-swap

    #+begin_src cicada
    (: eqv-swap
       (-> type :: type-t
           [x y] :: type
           x y eqv-t
        -- y x eqv-t))
    (= eqv-swap eqv-c)
    #+end_src

*** eqv-compose

    #+begin_src cicada
    (: eqv-compose
       (-> type :: type-t
           [x y z] :: type
           x y eqv-t
           y z eqv-t
        -- x z eqv-t))
    (= eqv-compose eqv-c)
    #+end_src

* nat

*** >< nat-even-p

*** nat-even-t -- re-imp predicate as judgment

    #+begin_src cicada
    (: nat-even-t (-> nat-t -- type-t))
    (= nat-even-t
       (type
         (-> -- zero-c zero-even-t)
         (-> m :: nat-t
             prev : m nat-even-t
          -- m succ-c succ-c even-plus-two-even-t)))

    (: two-even (-> -- zero-c succ-c succ-c nat-even-t))
    (= two-even zero-even-c even-plus-two-even-c)
    #+end_src

*** nat-add-associative

    #+begin_src cicada
    (: nat-add-associative
       (-> [x y z] : nat-t
        -- x y nat-add z nat-add
           x y z nat-add nat-add eqv-t))
    (= nat-add-associative
       (let x y z)
       (case z
         (zero-t eqv-c)
         (succ-t x y z.prev recur {succ-c} eqv-apply)))
    #+end_src

*** nat-add-commutative

    #+begin_src cicada
    (: nat-add-commutative
       (-> [m n] : nat-t
        -- m n nat-add
           n m nat-add eqv-t))
    (= nat-add-commutative
       (let m n)
       (case n
         (zero-t m nat-add-zero-commutative)
         (succ-t
           m n.prev recur {succ-c} eqv-apply
           n.prev m nat-add-succ-commutative eqv-compose)))
    #+end_src

*** nat-add-zero-commutative

    #+begin_src cicada
    (: nat-add-zero-commutative
       (-> m : nat-t
        -- m zero-c nat-add
           zero-c m nat-add eqv-t))
    (= nat-add-zero-commutative
       (let m)
       (case m
         (zero-t eqv-c)
         (succ-t m.prev recur {succ-c} eqv-apply)))
    #+end_src

*** nat-add-succ-commutative

    #+begin_src cicada
    (: nat-add-succ-commutative
       (-> [m n] : nat-t
        -- m succ-c n nat-add
           m n nat-add succ-c eqv-t))
    (= nat-add-succ-commutative
       (let m n)
       (case n
         (zero-t eqv-c)
         (succ-t m n.prev recur {succ-c} eqv-apply)))
    #+end_src

* list

*** list-length-t -- re-imp function as relation

    #+begin_src cicada
    (note
      (: list-length
         (-> list : type list-t
          -- length : nat-t))
      (: list-length-t
         (-> list : type list-t
             length : nat-t
          -- type-t)))

    (: list-length-t (-> type list-t, nat-t -- type-t))
    (= list-length-t
       (type (@ list : type list-t
                length : nat-t)
         (-> -- null-c zero-c zero-length-t)
         (-> prev : list length list-length-t
             -- element :: type
             element list cons-c
             length succ-c succ-length-t)))
    #+end_src

*** list-map-preserve-list-length

    #+begin_src cicada
    (: list-map-preserve-list-length
       (-> [a b] :: type-t
           fun :: (-> a -- b)
           list :: a list-t
           n :: nat-t
           list n list-length-t
        -- list {fun} list-map n list-length-t))
    (= list-map-preserve-list-length
       (let h)
       (case h
         (zero-length-t h)
         (succ-length-t h.prev recur succ-length-c)))
    #+end_src

*** list-append-t

    #+begin_src cicada
    ;; in prolog :
    ;;   append([], Succ, Succ).
    ;;   append([Car | Cdr], Succ, [Car | ResultCdr]):-
    ;;     append(Cdr, Succ, ResultCdr).

    (: list-append-t (-> type list-t type list-t type list-t -- type-t))
    (= list-append-t
       (type (@ [ante succ result] : type list-t)
         (-> -- null-c succ succ zero-append-t)
         (-> car :: type
             cdr :: type list-t
             result-cdr :: type list-t
             prev : cdr succ result-cdr list-append-t
          -- car cdr cons-c, succ, car result-cdr cons-c succ-append-t)))
    #+end_src

*** [semantic] succ-append-t

    #+begin_src cicada
    (note for [ante succ result succ-append-c]
      0 hypo-id-c data-hypo-c (quote type) local-let
      (quote type) local-get to-type
      type-t
      unify
      ><><><
      (@data-type-t
        (name "succ-append-t")
        (field-obj-dict
         (@ (type (quote type) local-get)
            (ante (quote ante) local-get)
            (succ (quote succ) local-get)
            (result (quote result) local-get))))
      (let data-type)
      (@data-obj-t
        (data-type data-type)
        (field-obj-dict
         (@ (prev (quote prev) local-get)))))
    #+end_src

* vect

*** vect-t

    #+begin_src cicada
    (: vect-t (-> nat-t type-t -- type-t))
    (= vect-t
       (type (@ length : nat-t
                type : type-t)
         (-> -- zero-c type null-vect-t)
         (-> car : type
             cdr : length type vect-t
             -- length succ-c type cons-vect-t)))
    #+end_src

*** vect-append

    #+begin_src cicada
    (: vect-append
       (-> m t vect-t
           n t vect-t
        -- m n nat-add t vect-t))
    (= vect-append
       (let x y)
       (case y
         (null-vect-t x)
         (cons-vect-t y.car x y.cdr recur cons-vect-c)))
    #+end_src

*** vect-map

    #+begin_src cicada
    (: vect-map (-> n a vect-t (-> a -- b) -- n b vect-t))
    (= vect-map
       (let list fun)
       (case list
         (null-vect-t list)
         (cons-vect-t list.car fun list.cdr {fun} recur cons-vect-c)))
    #+end_src

* category

*** category-ct

    #+begin_src cicada
    (: category-ct class-t)
    (= category-ct
       (class
         (: object-t type-t)
         (: arrow-t (-> object-t object-t -- type-t))
         (: arrow-eqv-t (-> a b arrow-t a b arrow-t -- type-t))
         (: identity
            (-> object-t % a
             -- a a arrow-t))
         (: compose
            (-> a b arrow-t
                b c arrow-t
             -- a c arrow-t))
         (: identity-left
            (-> a b arrow-t % f
             -- a identity f compose, f arrow-eqv-t))
         (: identity-right
            (-> a b arrow-t % f
             -- f b identity compose, f arrow-eqv-t))
         (: compose-associative
            (-> a b arrow-t % f
                b c arrow-t % g
                c d arrow-t % h
             -- f g h compose compose
                f g compose h compose arrow-eqv-t))))
    #+end_src

*** category-ct -- indentation

    #+begin_src cicada
    category-ct = class
      object-t : type-t
      arrow-t : -> object-t object-t -- type-t
      arrow-eqv-t : -> a b arrow-t a b arrow-t -- type-t
      identity :
        -> object-t % a
        -- a a arrow-t
      compose :
        -> a b arrow-t
           b c arrow-t
        -- a c arrow-t
      identity-left :
        -> a b arrow-t % f
        -- a identity f compose, f arrow-eqv-t
      identity-right :
        -> a b arrow-t % f
        -- f b identity compose, f arrow-eqv-t
      compose-associative :
        -> a b arrow-t % f
           b c arrow-t % g
           c d arrow-t % h
        -- f g h compose compose
           f g compose h compose arrow-eqv-t
    #+end_src

*** arrow-inverse-t

    #+begin_src cicada
    (: arrow-inverse-t
       (-> cat :: category-ct
           a b cat.arrow-t
           b a cat.arrow-t
        -- type-t))
    (= arrow-inverse-t
       (let f g)
       f g compose a identity arrow-eqv-t
       g f compose b identity arrow-eqv-t)
    #+end_src

* nat-lteq-t

*** nat-lteq-t

    #+begin_src cicada
    (+type nat-lteq-t
      : (-> [l r] : nat-t -- type-t)
      (-> -- zero-c r zero-lteq-t)
      (-> prev : l r nat-lteq-t
       -- l succ-c r succ-c succ-lteq-t))
    #+end_src

*** nat-non-negative

    #+begin_src cicada
    (+fun nat-non-negative
      : (-> n : nat-t -- zero-c n nat-lteq-t)
      zero-lteq-c)
    #+end_src

*** nat-lteq-reflexive

    #+begin_src cicada
    (+fun nat-lteq-reflexive
      : (-> n : nat-t -- n n nat-lteq-t)
      (case n
        (zero-t zero-lteq-c)
        (succ-t n.prev recur succ-lteq-c)))
    #+end_src

*** nat-lteq-transitive

    #+begin_src cicada
    (+fun nat-lteq-transitive
      : (-> a b nat-lteq-t % x
            b c nat-lteq-t % y
         -- a c nat-lteq-t)
      (case x
        (zero-lteq-t zero-lteq-c)
        (succ-lteq-t x.prev y.prev recur succ-lteq-c)))
    #+end_src

*** nat-lt-t

    #+begin_src cicada
    (+fun nat-lt-t
      : (-> [l r] : nat-t -- type-t)
      l succ-c r nat-lteq-t)
    #+end_src

*** nat-archimedean-property

    #+begin_src cicada
    (+type nat-archimedean-property
      : (-> n : nat-t
         -- m : nat-t
            n m nat-lt-t)
      n succ-c dup nat-lteq-reflexive)
    #+end_src

*** category-ct % (@ nat-t nat-lteq-t eqv-t)

    #+begin_src cicada
    (+instance category-ct % (@ nat-t nat-lteq-t eqv-t)
      (+imp identity nat-lteq-reflexive)
      (+imp compose  nat-lteq-transitive)
      (+imp identity-left
        (let x)
        (case x
          (zero-lteq-t eqv-c)
          (succ-lteq-t x.prev recur {succ-lteq-c} eqv-apply)))
      (+imp identity-righ
        (let x)
        (case x
          (zero-lteq-t eqv-c)
          (succ-lteq-t x.prev recur {succ-lteq-c} eqv-apply)))
      (+imp compose-associative
        (let f g h)
        (case [f g h]
          ([zero-lteq-t _ _] eqv-c)
          ([succ-lteq-t succ-lteq-t succ-lteq-t]
           f.prev g.prev h.prev recur {succ-lteq-c} eqv-apply))))
    #+end_src

* product

*** arrow-unique-t

    #+begin_src cicada
    (+fun arrow-unique-t
      : (-> category-ct %% (@ object-t arrow-t arrow-eqv-t)
            a b arrow-t % f
            (-> a b arrow-t -- type-t) % theorem
         -- type-t)
      (* f theorem
         (-> a b arrow-t % g
             g theorem
          -- f g arrow-eqv-t)))
    #+end_src

*** object-product-t

    #+begin_src cicada
    (+fun object-product-t
      : (-> category-ct %% (@ object-t arrow-t arrow-eqv-t)
            object-t % a
            object-t % b
            object-t % p
            p a arrow-t % fst
            p b arrow-t % snd
         -- type-t)
      (-> object-t % q
          q a arrow-t % fst~
          q b arrow-t % snd~
       -- q p arrow-t % m
          {(let m)
           (* fst~, m fst compose arrow-eqv-t
              snd~, m snd compose arrow-eqv-t)}
          m swap arrow-unique-t))
    #+end_src

*** >< object-product-t -- (unique)

    #+begin_src cicada
    (+fun object-product-t
      : (-> category-ct %% (@ object-t arrow-t arrow-eqv-t)
            object-t % a
            object-t % b
            object-t % p
            p a arrow-t % fst
            p b arrow-t % snd
         -- type-t)
      (-> object-t % q
          q a arrow-t % fst~
          q b arrow-t % snd~
       -- (unique m : q p arrow-t
            fst~, m fst compose arrow-eqv-t
            snd~, m snd compose arrow-eqv-t)))
    #+end_src

*** product-closed-ct

    #+begin_src cicada
    (+class product-closed-ct
      < category-ct
      < (@ object-t : type-t
           arrow-t : (-> object-t object-t -- type-t)
           arrow-eqv-t : (-> a b arrow-t a b arrow-t -- type-t))
      (+sig product
        : (-> object-t % a
              object-t % b
           -- object-t % p
              p a arrow-t % fst
              p b arrow-t % snd
              a b p fst snd object-product-t)))
    #+end_src

*** >< category-product-ct -- first class (+class)

    #+begin_src cicada
    (+class category-product-ct
      )
    #+end_src

* >< limit

*** ><

    #+begin_src cicada

    #+end_src

* groupoid

*** groupoid-ct

    #+begin_src cicada
    (+class groupoid-ct
      < category-ct
      < (@ object-t : type-t
           arrow-t : (-> object-t object-t -- type-t)
           arrow-eqv-t : (-> a b arrow-t a b arrow-t -- type-t))
      (+sig inverse
        : (-> a b arrow-t % f
           -- b a arrow-t % g
              f g arrow-inverse-t)))
    #+end_src

* >< group

* >< abelian-group

* >< monoid

* >< ring

* >< field

* >< vector-space

* >< morphism

*** morphism-t

    - x -
      it seems fun-eqv-t must be built-in
      because `succ` and `ante` are not limited to `type-t`

    #+begin_src cicada
    (+fun morphism-t
      : (-> [succ ante] : type-t -- type-t)
      (-> succ -- ante))
    #+end_src

*** fun-eqv-t

    - x -
      it seems fun-eqv-t must be built-in
      because `f` and `g` are not limited to `(-> a -- b)`

    #+begin_src cicada
    (+type fun-eqv-t
      : (-> [lhs rhs] : (-> a -- b) -- type-t)
      (-> (-> x : a -- x lhs x rhs eqv-t)
       -- {lhs} {rhs} fun-eqv-t))
    #+end_src

*** category-ct % (@ type-t morphism-t fun-eqv-t)

    #+begin_src cicada
    (+instance category-ct % (@ type-t morphism-t fun-eqv-t)
      (+imp identity )
      (+imp compose  )
      (+imp identity-left )
      (+imp identity-righ )
      (+imp compose-associative ))
    #+end_src

* functor

*** functor-ct

    #+begin_src cicada
    (+class functor-ct
      < (@ fun-t : (-> type-t -- type-t))
      (+sig map
        : (-> a fun-t
              (-> a -- b)
           -- b fun-t)))
    #+end_src

*** functor-ct % (@ list-t)

    #+begin_src cicada
    (+instance functor-ct % (@ list-t)
      (+imp map
        (let list fun)
        (case list
          (null-t null-c)
          (cons-t
            list.car fun
            list.cdr {fun} recur
            cons-c))))
    #+end_src

* monad

*** monad-ct

    #+begin_src cicada
    (+class monad-ct
      < functor-ct
      < (@ fun-t : (-> type-t -- type-t))
      (+sig pure
        : (-> t -- t fun-t))
      (+sig bind
        : (-> a fun-t
              (-> a -- b fun-t)
           -- b fun-t)))
    #+end_src

*** monad-compose

    #+begin_src cicada
    (+fun monad-compose
      : (-> monad-ct %% (@ fun-t)
            (-> a -- b fun-t) % f
            (-> b -- c fun-t) % g
         -- (-> a -- c fun-t))
      {f {g} bind})
    #+end_src

*** monad-flatten

    #+begin_src cicada
    (+fun monad-flatten
      : (-> monad-ct %% (@ fun-t)
            a fun-t fun-t
         -- a fun-t)
      {} bind)
    #+end_src

*** monad-ct % (@ list-t)

    #+begin_src cicada
    (+instance monad-ct % (@ list-t)
      (+imp pure null-c cons-c)
      (+imp bind
        (let list fun)
        (case list
          (null-t null-c)
          (cons-t
            list.car fun
            list.cdr {fun} recur
            list-append))))
    #+end_src

* maybe

*** maybe-t

    #+begin_src cicada
    (+type maybe-t : (-> type : type-t -- type-t)
      (-> -- type none-t)
      (-> value : type -- type just-t))
    #+end_src

*** functor-ct % (@ maybe-t)

    #+begin_src cicada
    (+instance functor-ct % (@ maybe-t)
      (+imp map
        (let maybe fun)
        (case maybe
          (none-t none-c)
          (just-t maybe.value fun just-c))))
    #+end_src

*** monad-ct % (@ maybe-t)

    #+begin_src cicada
    (+instance monad-ct % (@ maybe-t)
      (+imp pure just-c)
      (+imp bind
        (let maybe fun)
        (case maybe
          (none-t none-c)
          (just-t maybe.value fun))))
    #+end_src

* state

*** state-t

    #+begin_src cicada
    (+fun state-t
      : (-> type-t % type
            type-t % value-t
         -- type-t)
      (-> type -- type value-t))
    #+end_src

*** monad-ct % (@ {value-t state-t})

    #+begin_src cicada
    (+instance monad-ct % (@ {value-t state-t})
      (+imp pure
        (let value)
        {value})
      (+imp bind
        (let state fun)
        {state fun apply}))
    #+end_src

* tree

*** tree-t

    #+begin_src cicada
    (+type tree-t : (-> type-t -- type-t)
      (-> t % value -- t leaf-t)
      (-> t tree-t % [left right]
       -- t branch-t))
    #+end_src

*** functor-ct % (@ tree-t)

    #+begin_src cicada
    (+instance functor-ct % (@ tree-t)
      (+imp map
        (let tree fun)
        (case tree
          (leaf-t tree.value fun leaf-c)
          (branch-t
            tree.left {fun} recur
            tree.right {fun} recur branch-c))))
    #+end_src

*** tree-zip

    #+begin_src cicada
    (+fun tree-zip
      : (-> a tree-t % tree-a
            b tree-t % tree-b
         -- (* a b) tree-t maybe-t)
      (case [tree-a tree-b]
        ([leaf-t leaf-t]
         tree-a.value tree-b.value prod leaf-c pure)
        ([branch-t branch-t]
         (do tree-a.left tree-b.left recur (>- left)
             tree-a.right tree-b.right recur (>- right)
             left right branch-c pure))
        (else none-c)))
    #+end_src

*** tree-numbering-with-nat

    #+begin_src cicada
    (+fun tree-numbering-with-nat
      : (-> nat-t, t tree-t % tree
         -- nat-t, nat-t tree-t)
      (case tree
        (leaf-t dup inc swap leaf-c)
        (branch-t
          tree.left recur (let left)
          tree.right recur (let right)
          left right branch-c)))
    #+end_src

*** tree-numbering

    #+begin_src cicada
    (+fun tree-numbering
      : (-> t tree-t % tree
         -- nat-t tree-t state-t)
      (case tree
        (leaf-t {dup inc swap leaf-c})
        (branch-t
          (do tree.left recur (>- left)
              tree.right recur (>- right)
              left right branch-c))))
    #+end_src

* int

*** int-t

    #+begin_src cicada

    #+end_src

* number theory

*** mod-t

    #+begin_src cicada
    (+type mod-t
      : (->
         -- )
      (-> ))
    #+end_src

*** gcd-t

    #+begin_src cicada
    (+type gcd-t
      : (-> x : int-t
            y : int-t
            d : int-t
         -- type-t)
      (-> -- x zero-c x zero-gcd-t)
      (-> gcd : x y d gcd-t
          mod : x y z mod-t
       -- y z d mod-gcd-t))
    #+end_src

* >< category-ct

*** category-ct

    #+begin_src cicada
    (+class category-ct
      (: object-t type-t)
      (: arrow-t (-> object-t object-t -- type-t))
      (: arrow-eqv-t (-> a b arrow-t a b arrow-t -- type-t))
      (: identity
         (-> object-t % a
          -- a a arrow-t))
      (: compose
         (-> a b arrow-t
             b c arrow-t
          -- a c arrow-t))
      (: identity-left
         (-> a b arrow-t % f
          -- a identity f compose, f arrow-eqv-t))
      (: identity-right
         (-> a b arrow-t % f
          -- f b identity compose, f arrow-eqv-t))
      (: compose-associative
         (-> a b arrow-t % f
             b c arrow-t % g
             c d arrow-t % h
          -- f g h compose compose
             f g compose h compose arrow-eqv-t)))
    #+end_src

*** category-ct % (@ nat-t nat-lteq-t eqv-t)

    #+begin_src cicada
    (+class category-ct
      (: object-t type-t)
      (: arrow-t (-> object-t object-t -- type-t))
      (: arrow-eqv-t (-> a b arrow-t a b arrow-t -- type-t))
      (: identity
         (-> object-t % a
          -- a a arrow-t))
      (: compose
         (-> a b arrow-t
             b c arrow-t
          -- a c arrow-t))
      (: identity-left
         (-> a b arrow-t % f
          -- a identity f compose, f arrow-eqv-t))
      (: identity-right
         (-> a b arrow-t % f
          -- f b identity compose, f arrow-eqv-t))
      (: compose-associative
         (-> a b arrow-t % f
             b c arrow-t % g
             c d arrow-t % h
          -- f g h compose compose
             f g compose h compose arrow-eqv-t)))

    (+instance category-ct
      (= object-t nat-t)
      (= arrow-t nat-lteq-t)
      (= arrow-eqv-t eqv-t)
      (= identity nat-lteq-reflexive)
      (= compose  nat-lteq-transitive)
      (= identity-left
         (let x)
         (case x
           (zero-lteq-t eqv-c)
           (succ-lteq-t x.prev recur {succ-lteq-c} eqv-apply)))
      (= identity-righ
         (let x)
         (case x
           (zero-lteq-t eqv-c)
           (succ-lteq-t x.prev recur {succ-lteq-c} eqv-apply)))
      (= compose-associative
         (let f g h)
         (case [f g h]
           ([zero-lteq-t _ _] eqv-c)
           ([succ-lteq-t succ-lteq-t succ-lteq-t]
            f.prev g.prev h.prev recur {succ-lteq-c} eqv-apply))))
    #+end_src

*** arrow-inverse-t

    #+begin_src cicada
    (+fun arrow-inverse-t
      : (-> (with category-ct)
            a b arrow-t % f
            b a arrow-t % g
         -- type-t)
      f g compose a identity arrow-eqv-t
      g f compose b identity arrow-eqv-t)
    #+end_src

* >< dependent-category

*** dependent-category-ct

    #+begin_src cicada
    (+class dependent-category-ct
      (: object-t type-t)
      (: object-eqv-t (-> object-t object-t -- type-t))
      (: arrow-t (-> object-t object-t -- type-t))
      (: arrow-eqv-t (-> a b arrow-t a b arrow-t -- type-t))
      (: substitution-t monoid-ct)
      (: substitute
         (-> object-t substitution-t -- object-t))
      (: unification
         (-> a : object-t
             b : object-t
          -- c : object-t
             s : substitution-t
             a s substitute c object-eqv-t
             b s substitute c object-eqv-t))
      (: identity
         (-> a : object-t
          -- a a arrow-t))
      (: cut
         (-> a b arrow-t
             c d arrow-t
          -- a b c unifier substitute
             d b c unifier substitute
             arrow-t))
      (: identity-left
         (->
          -- ))
      (: identity-right
         (->
          -- ))
      (: cut-associative
         (->
          -- )))
    #+end_src

*** unifier

    #+begin_src cicada
    (+fun unifier
      : (-> (with dependent-category-ct)
            object-t
            object-t
         -- substitution-t)
      unification drop drop swap drop)
    #+end_src

*** unify

    #+begin_src cicada
    (+fun unify
      : (-> (with dependent-category-ct)
            object-t
            object-t
         -- object-t)
      unification drop drop drop)
    #+end_src

* >< about (+class)

  - x -
    what belong to argument of the constructor ?
    what belong to interface function ?

    it seems
    we pick up some fields as key fields
    from the dependent record
    the record is the real thing

  - k -
    I think it basicly says
    type class is not the right way to implement
    abstract mathematical structure

    type class can only take one argument

    type class can not be viewed as subtype of type-t

    the argument must occur in generaic function

  - x -
    we need to learn haskell really well
    we use it to write interpreter instead of compiler
    but how should we model mathematical structure ?

  - k -
    thinking about agde module system ?
