#+title: todo

* exponentials

* category-category

*** there is no class-category

    - x -
      there is no class-category only category-category

      a class generates a category
      which is an object of category-category

      a class itself is not an object of class-category
      because
      I can not think of how to define morphism between classes

      morphism can only be defined between categories
      generated by classes

      suppose I have defind
      [space-t : class-tt] and [homology-t : class-tt]
      a meaningful morphism between them
      would be something of type (-- space-t -> homology-t)
      but it also need to

    - use natural-transformation to implement arrow-eqv-s of category

    - we do not generate category from class.
      to specify a class-category,
      we need to gave a class and a category.

*** natural-transformation

    - natural-transformation is a level up map.

      the definition of natural-transformation
      maps object to arrow,
      and arrow to square.

*** natural-isomorphism

    - natural-transformation whose ><><>< are isomorphism
      instead of merely morphism

    - natural-isomorphism is eqv-relation between functors

    - eqv-relation between functors
      is specially important
      because homology and homotopy are functors!

* arrow-eqv-s -- amend `arrow-eqv-relation` for all category

  - arrow-eqv-s must be an eqv-relation-t
    for all hom-set [a b arrow-s]

* bifunctor

  - checking functorial laws of pair of categories,
    [where pair is Cartesian product]
    is equivalent to
    checking functorial laws for each component of the pair.

    - this is the whole point of Cartesian product

* set-category

  - surjective

  - injective

  - bijective

* prove iso for universal-construction

  - a universal-construction is unique up to unique isomorphism

  - we need to use unique to prove eqv

* representable-functor

* nat-total-order

* monad as category

* dependent-category -- use pullback and pushout

  - maybe we still need to get out of category at the end

  - to open a new mode of explanation

* topos-theory

* logic programming

  - what is the logic programming interface of the type system ?

* use number theory -- to test type-checker as prover

* sub-set relation in set-t

  - maybe also use (<:) as syntax

* algebraic structure

  - (*) and (sum) in set-t
    provide two commutative monoidal structures -- semi-ring-t
    for we can’t define subtraction of types.
    -- a.k.a rig-t, ring without negative.

    - note that, to be monoidal-category,
      the binary operator must also be a bifunctor.

      i.e. the monoidal product must be
      compatible with the structure of the category,
      which is defined by morphisms.

  - order relation for algebraic data type

    for example :
    a < a + b
    a < a * 2

    this can be viewed as a functor from set-t to rational-s

  ------

  - x -
    can we extend the algebraic structure to dependent type ?

  - k -
    we will need to extend the algebraic structure to object

  - x -
    object are just like type.
    just without sum-type, only product-type.

* should (:) (%) (<:) form types too ? -- like eqv-c

* other topics to be formalized

*** Ordinal number

    - https://en.wikipedia.org/wiki/Ordinal_number

    - well-order

    - Order type

    - Every well-ordered set is order-equivalent
      to exactly one ordinal number.

*** Cardinal number

    - https://en.wikipedia.org/wiki/Cardinal_number

    - In category theory,
      the cardinal numbers form a skeleton of the category of sets.

*** Skeleton (category theory)

    - https://en.wikipedia.org/wiki/Skeleton_(category_theory)

*** Cantor's diagonal argument

    - https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument
