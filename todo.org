#+html_head: <link rel="stylesheet" href="css/org-page.css"/>
#+title: todo

* category-category

* universal-construction

  - a carefully designed modelling of universal-construction
    is the core of modelling category-theory

* prove iso for universal-construction

  - a universal-construction is unique up to unique isomorphism

  - we need to use unique to prove eqv

* set

*** representable-functor and set

*** fix set-morphism-t -- with set-t

    - maybe no top level eqv-t

    - x -
      maybe we can not afford to do this.
      for syntax reason.

*** set-category

    - surjective

    - injective

    - bijective

* arrow-eqv-t -- amend `arrow-eqv-relation` for all category

  - arrow-eqv-t must be an eqv-relation-t
    for all hom-set [a b arrow-t]

* bifunctor

  - checking functorial laws of pair of categories,
    [where pair is Cartesian product]
    is equivalent to
    checking functorial laws for each component of the pair.

    - this is the whole point of Cartesian product

* nat-total-order

* monad as category

* dependent-category -- use pullback, pushout and equalizer

  - maybe we still need to get out of category at the end

  - to open a new mode of explanation

* topos-theory

* logic programming interface of the type system

* use number theory to test type-checker as prover

* algebraic structure

  - (*) and (+) in type-t
    provide two commutative monoidal structures -- semi-ring-t
    for we canâ€™t define subtraction of types.
    -- a.k.a rig-t, ring without negative.

    - note that, to be monoidal-category,
      the binary operator must also be a bifunctor.

      i.e. the monoidal product must be
      compatible with the structure of the category,
      which is defined by morphisms.

  - order relation for algebraic data type

    for example :
    a < a + b
    a < a * 2

    this can be viewed as a functor from type-t to rational-t

  - x -
    can we extend the algebraic structure to dependent type ?

  - k -
    we will need to extend the algebraic structure to object

  - x -
    object are just like type.
    just without sum-type, only product-type.

* should (:) (<:) form types too ? -- like eqv-c
