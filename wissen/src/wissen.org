#+property: tangle lib.rs
#+title: Wissen
- occur_check
- DeductionTree
- `prove () {}`
* prolog

*** feature

    #+begin_src rust
    #![feature (uniform_paths)]
    #![feature (bind_by_move_pattern_guards)]
    #![feature (box_patterns)]
    #![feature (box_syntax)]

    #![allow (dead_code)]
    #+end_src

*** use

    #+begin_src rust
    use std::fmt;
    use std::sync::Arc;
    use std::collections::VecDeque;
    use std::collections::HashMap;
    use std::collections::HashSet;
    use uuid::Uuid;
    use dic::Dic;
    use error_report::{
        // Span,
        ErrorMsg,
        ErrorInCtx,
    };
    #[cfg (test)]
    use error_report::{
        ErrorCtx,
    };
    use mexp::{
        SyntaxTable,
        Mexp,
        Arg,
    };
    #+end_src

* utility

*** vec_to_string

    #+begin_src rust
    fn vec_to_string <T> (vec: &Vec <T>, delimiter: &str) -> String
    where T : ToString {
        let mut s = String::new ();
        for x in vec {
            s += &x.to_string ();
            s += delimiter;
        }
        for _ in 0 .. delimiter.len () {
            s.pop ();
        }
        s
    }
    #+end_src

*** vec_to_lines

    #+begin_src rust
    fn vec_to_lines <T> (vec: &Vec <T>) -> String
    where T : ToString {
        let mut s = vec_to_string (vec, "\n");
        if ! s.is_empty () {
            s += "\n";
        }
        s
    }
    #+end_src

* Term

*** Term

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub enum Term {
        Var   (VarTerm),
        Tuple (TupleTerm),
    }
    #+end_src

*** VarTerm

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub struct VarTerm {
        name: String,
        id: Option <Id>,
    }
    #+end_src

*** VarTerm::to_string

    #+begin_src rust
    impl ToString for VarTerm {
        fn to_string (&self) -> String {
            let mut s = format! ("{}", self.name);
            if let Some (id) = &self.id {
                s += &format! ("#{}", id.to_string ());
            }
            s
        }
    }
    #+end_src

*** Id

    #+begin_src rust
    #[derive (Clone)]
    #[derive (PartialEq, Eq, Hash)]
    pub enum Id {
        Uuid (uuid::adapter::Hyphenated),
        Local (usize),
    }
    #+end_src

*** Id::uuid

    #+begin_src rust
    impl Id {
        fn uuid () -> Self {
            Id::Uuid (Uuid::new_v4 () .to_hyphenated ())
        }
    }
    #+end_src

*** Id::local

    #+begin_src rust
    impl Id {
        fn local (counter: usize) -> Self {
            Id::Local (counter)
        }
    }
    #+end_src

*** Id::fmt

    #+begin_src rust
    impl fmt::Debug for Id {
        fn fmt (&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Id::Uuid (uuid) => write! (f, "{}", uuid),
                Id::Local (counter) => write! (f, "{}", counter),
            }
        }
    }
    #+end_src

*** Id::to_string

    #+begin_src rust
    impl ToString for Id {
        fn to_string (&self) -> String {
            match self {
                Id::Uuid (uuid) => format! ("{}", uuid),
                Id::Local (counter) => format! ("{}", counter),
            }
        }
    }
    #+end_src

*** TupleTerm

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub struct TupleTerm {
        head: String,
        body: Vec <Term>,
    }
    #+end_src

*** TupleTerm::to_string

    #+begin_src rust
    impl ToString for TupleTerm {
        fn to_string (&self) -> String {
            if self.body.len () == 0 {
                format! ("{}", self.head)
            } else {
                format! (
                    "{} ({})",
                    self.head,
                    vec_to_string (&self.body, " "))
            }
        }
    }
    #+end_src

*** Term::var

    #+begin_src rust
    impl Term {
        fn var (s: &str) -> Term {
            Term::Var (VarTerm {
                name: s.to_string (),
                id: Some (Id::uuid ()),
            })
        }
    }
    #+end_src

*** Term::var_no_id

    #+begin_src rust
    impl Term {
        fn var_no_id (s: &str) -> Term {
            Term::Var (VarTerm {
                name: s.to_string (),
                id: None,
            })
        }
    }
    #+end_src

*** Term::var_local

    #+begin_src rust
    impl Term {
        fn var_local (s: &str, counter: usize) -> Term {
            Term::Var (VarTerm {
                name: s.to_string (),
                id: Some (Id::local (counter)),
            })
        }
    }
    #+end_src

*** Term::tuple

    #+begin_src rust
    impl Term {
        fn tuple (h: &str, vec: Vec <Term>) -> Term {
            Term::Tuple (TupleTerm {
                head: h.to_string (),
                body: vec,
            })
        }
    }
    #+end_src

*** Term::duplicate

    #+begin_src rust
    impl Term {
        fn duplicate (
            &self,
            var_map: &mut HashMap <VarTerm, VarTerm>,
        ) -> Term {
            match self {
                Term::Var (var) => {
                    if let Some (dup_var) = var_map.get (var) {
                        Term::Var (dup_var.clone ())
                    } else {
                        let new_var = VarTerm {
                            name: var.name.clone (),
                            id: Some (Id::uuid ()),
                        };
                        var_map.insert (
                            var.clone (),
                            new_var.clone ());
                        Term::Var (new_var)
                    }
                }
                Term::Tuple (tuple) => {
                    let mut new_tuple = TupleTerm {
                        head: tuple.head.clone (),
                        body: Vec::new (),
                    };
                    for term in &tuple.body {
                        new_tuple.body.push (
                            term.duplicate (var_map));
                    }
                    Term::Tuple (new_tuple)
                }
            }
        }
    }
    #+end_src

*** Term::fresh

    #+begin_src rust
    impl Term {
        fn fresh (&self) -> Term {
            let mut var_map = HashMap::new ();
            self.duplicate (&mut var_map)
        }
    }
    #+end_src

*** Term::to_string

    #+begin_src rust
    impl ToString for Term {
        fn to_string (&self) -> String {
            match self {
                Term::Var (var) => var.to_string (),
                Term::Tuple (tuple) => tuple.to_string (),
            }
        }
    }
    #+end_src

* Subst

*** Subst

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub enum Subst {
        Null,
        Cons {
           var: VarTerm,
           term: Term,
           next: Arc <Subst>,
        },
    }
    #+end_src

*** Subst::new

    #+begin_src rust
    impl Subst {
        fn new () -> Self {
            Subst::Null
        }
    }
    #+end_src

*** Subst::extend

    #+begin_src rust
    impl Subst {
        fn extend (&self, var: VarTerm, term: Term) -> Self {
            Subst::Cons {
                var, term,
                next: Arc::new (self.clone ()),
            }
        }
    }
    #+end_src

*** Subst::find

    #+begin_src rust
    impl Subst {
        pub fn find (&self, var: &VarTerm) -> Option <&Term> {
            match self {
                Subst::Null => None,
                Subst::Cons {
                    var: first, term, next,
                } => {
                    if first == var {
                        Some (term)
                    } else {
                        next.find (var)
                    }
                }
            }
        }
    }
    #+end_src

*** Subst::walk

    #+begin_src rust
    impl Subst {
        pub fn walk (&self, term: &Term) -> Term {
            match term {
                Term::Var (var) => {
                    if let Some (new_term) = self.find (var) {
                        self.walk (new_term)
                    } else {
                        term.clone ()
                    }
                }
                _ => term.clone ()
            }
        }
    }
    #+end_src

*** Subst::unify

    #+begin_src rust
    impl Subst {
        pub fn unify (
            &self,
            u: &Term,
            v: &Term,
        ) -> Option <Subst> {
            let u = self.walk (u);
            let v = self.walk (v);
            match (u, v) {
                (Term::Var (u),
                 Term::Var (v),
                ) if u == v => {
                    Some (self.clone ())
                }
                (Term::Var (u), v) => {
                    Some (self.extend (u, v))
                }
                (u, Term::Var (v)) => {
                    Some (self.extend (v, u))
                }
                (Term::Tuple (ut),
                 Term::Tuple (vt),
                ) => {
                    if ut.head != vt.head {
                        return None;
                    }
                    if ut.body.len () != vt.body.len () {
                        return None;
                    }
                    let mut subst = self.clone ();
                    let zip = ut.body.iter () .zip (vt.body.iter ());
                    for (u, v) in zip {
                        subst = subst.unify (u, v)?;
                    }
                    Some (subst)
                }
            }
        }
    }
    #+end_src

*** Subst::null_p

    #+begin_src rust
    impl Subst {
        pub fn null_p (&self) -> bool {
            &Subst::Null == self
        }
    }
    #+end_src

*** Subst::cons_p

    #+begin_src rust
    impl Subst {
        pub fn cons_p (&self) -> bool {
            &Subst::Null != self
        }
    }
    #+end_src

*** Subst::len

    #+begin_src rust
    impl Subst {
        pub fn len (&self) -> usize {
            let mut len = 0;
            let mut subst = self;
            while let Subst::Cons { next, .. } = subst {
                len += 1;
                subst = &next;
            }
            len
        }
    }
    #+end_src

*** Subst::to_string

    #+begin_src rust
    impl ToString for Subst {
        fn to_string (&self) -> String {
            let mut s = String::new ();
            let mut subst = self.clone ();
            while let Subst::Cons {
                var,
                term,
                next,
            } = subst {
                s += &var.to_string ();
                s += " = ";
                s += &term.to_string ();
                s += "\n";
                subst = (*next) .clone ();
            }
            s
        }
    }
    #+end_src

*** Subst::apply

    #+begin_src rust
    impl Subst {
        pub fn apply (&self, term: &Term) -> Term {
            let term = self.walk (term);
            match term {
                Term::Var (_) => term,
                Term::Tuple (TupleTerm {
                    head,
                    body,
                }) => {
                    let body = body.iter ()
                        .map (|x| self.apply (x))
                        .collect ();
                    Term::Tuple (TupleTerm {
                        head,
                        body,
                    })
                }
            }
        }
    }
    #+end_src

*** Subst::localize_by_term

    #+begin_src rust
    impl Subst {
        pub fn localize_by_term (&self, term: &Term) -> Subst {
            let term = self.walk (term);
            match term {
                Term::Var (var) => {
                    self.extend (
                        var.clone (),
                        Term::var_local (
                            &var.name,
                            self.len ()))
                }
                Term::Tuple (TupleTerm {
                    body, ..
                }) => {
                    let mut subst = self.clone ();
                    for term in &body {
                        subst = subst.localize_by_term (term);
                    }
                    subst
                }
            }
        }
    }
    #+end_src

*** Subst::reify_var

    #+begin_src rust
    impl Subst {
        pub fn reify_var (&self, var: &VarTerm) -> Term {
            let term = Term::Var (var.clone ());
            let term = self.apply (&term);
            let new_subst = Subst::new ();
            let local_subst = new_subst.localize_by_term (&term);
            local_subst.apply (&term)
        }
    }
    #+end_src

* Prop

*** Prop

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub enum Prop {
        Disj (Vec <String>),
        Conj (Vec <Term>, Vec <Query>),
    }
    #+end_src

*** Prop::duplicate

    #+begin_src rust
    impl Prop {
        fn duplicate (
            &self,
            var_map: &mut HashMap <VarTerm, VarTerm>,
        ) -> Prop {
            match self {
                Prop::Disj (_name_vec) => {
                    self.clone ()
                }
                Prop::Conj (args, query_vec) => {
                    let mut new_args = Vec::new ();
                    for arg in args {
                        new_args.push (
                            arg.duplicate (var_map))
                    }
                    let mut new_query_vec = Vec::new ();
                    for query in query_vec {
                        new_query_vec.push (
                            query.duplicate (var_map))
                    }
                    Prop::Conj (new_args, new_query_vec)
                }
            }
        }
    }
    #+end_src

*** Prop::fresh

    #+begin_src rust
    impl Prop {
        fn fresh (&self) -> Prop {
            let mut var_map = HashMap::new ();
            self.duplicate (&mut var_map)
        }
    }
    #+end_src

*** Prop::apply

    #+begin_src rust
    impl Prop {
        fn apply (
            self,
            args: &Vec <Term>,
            mut subst: Subst,
        ) -> Option <(Vec <Vec <Arc <Query>>>, Subst)> {
            match self {
                Prop::Disj (name_vec) => {
                    let mut query_matrix = Vec::new ();
                    for name in name_vec {
                        let query = Arc::new (Query {
                            name: name,
                            args: args.clone (),
                        });
                        query_matrix.push (vec! [query]);
                    }
                    Some ((query_matrix, subst))
                }
                Prop::Conj (terms, query_vec) => {
                    if args.len () != terms.len () {
                        eprintln! ("- [warning] Prop::apply");
                        eprintln! ("  arity mismatch");
                        return None;
                    }
                    let zip = args.iter () .zip (terms.iter ());
                    for (u, v) in zip {
                        if let Some (
                            new_subst
                        ) = subst.unify (u, v) {
                            subst = new_subst;
                        } else {
                            return None;
                        }
                    }
                    let query_matrix = vec! [
                        query_vec
                            .into_iter ()
                            .map (|x| Arc::new (x))
                            .collect ()
                    ];
                    Some ((query_matrix, subst))
                }
            }
        }
    }
    #+end_src

*** Prop::to_string

    #+begin_src rust
    impl ToString for Prop {
        fn to_string (&self) -> String {
            match self {
                Prop::Disj (name_vec) => {
                    format! (
                        "disj ({})",
                        vec_to_string (&name_vec, " "))
                }
                Prop::Conj (terms, query_vec) => {
                    format! (
                        "conj ({}) {}",
                        vec_to_string (&terms, " "),
                        if query_vec.len () == 0 {
                            format! ("{{}}")
                        } else {
                            format! (
                                "{{ {} }}",
                                vec_to_string (&query_vec, " "))
                        })
                }
            }
        }
    }
    #+end_src

* Query

*** Query

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq, Hash)]
    pub struct Query {
        name: String,
        args: Vec <Term>,
    }
    #+end_src

*** Query::duplicate

    #+begin_src rust
    impl Query {
        fn duplicate (
            &self,
            var_map: &mut HashMap <VarTerm, VarTerm>,
        ) -> Query {
            let mut new_args = Vec::new ();
            for arg in &self.args {
                new_args.push (
                    arg.duplicate (var_map));
            }
            Query {
                name: self.name.clone (),
                args: new_args,
            }
        }
    }
    #+end_src

*** Query::to_string

    #+begin_src rust
    impl ToString for Query {
        fn to_string (&self) -> String {
            format! (
                "{} ({})",
                self.name,
                vec_to_string (&self.args, " "))
        }
    }
    #+end_src

* Wissen

*** Wissen

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Wissen {
        prop_dic: Dic <Prop>,
    }
    #+end_src

*** Wissen::new

    #+begin_src rust
    impl Wissen {
        pub fn new () -> Self {
            Wissen {
                prop_dic: Dic::new (),
            }
        }
    }
    #+end_src

*** Wissen::find_prop

    #+begin_src rust
    impl Wissen {
        fn find_prop (&self, name: &str) -> Option <Prop> {
            if let Some (
                prop
            ) = self.prop_dic.get (name) {
                Some (prop.fresh ())
            } else {
                None
            }
        }
    }
    #+end_src

*** Wissen::proving

    #+begin_src rust
    impl Wissen {
        pub fn proving <'a> (
            &'a self,
            query_vec: &Vec <Query>,
        ) -> Proving <'a> {
            let mut query_queue = VecDeque::new ();
            for query in query_vec {
                query_queue.push_back (Arc::new (query.clone ()))
            }
            let proof = Proof {
                wissen: self,
                subst: Subst::new (),
                query_queue,
            };
            Proving {
                proof_queue: vec! [proof] .into (),
            }
        }
    }
    #+end_src

*** Wissen::to_string

    #+begin_src rust
    impl ToString for Wissen {
        fn to_string (&self) -> String {
            let mut s = String::new ();
            for (name, prop) in self.prop_dic.iter () {
                s += name;
                s += " = ";
                s += &prop.to_string ();
                s += "\n";
            }
            format! ("<wissen>\n{}</wissen>\n", s)
        }
    }
    #+end_src

*** Wissen::prop

    #+begin_src rust
    impl Wissen {
        pub fn prop (&mut self, name: &str, prop: &Prop) {
           self.prop_dic.ins (name, Some (prop.clone ()));
        }
    }
    #+end_src

*** Wissen::wis

    #+begin_src rust
    impl Wissen {
        pub fn wis <'a> (
            &'a mut self,
            input: &str,
        ) -> Result <Vec <WissenOutput>, ErrorInCtx> {
            let syntax_table = SyntaxTable::default ();
            let mexp_vec = syntax_table.parse (input)?;
            let statement_vec = mexp_vec_to_statement_vec (&mexp_vec)?;
            for statement in &statement_vec {
                if let Statement::Prop (
                    name, prop
                ) = statement {
                    self.prop (name, prop);
                }
            }
            let mut output_vec = Vec::new ();
            for statement in &statement_vec {
                if let Statement::Query (
                    counter, query_vec
                ) = statement {
                    let mut proving = self.proving (query_vec);
                    let subst_vec = proving.take_subst (*counter);
                    output_vec.push (WissenOutput::Query {
                        counter: *counter,
                        query_vec: query_vec.clone (),
                        subst_vec,
                    });
                }
            }
            Ok (output_vec)
        }
    }
    #+end_src

*** WissenOutput

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum WissenOutput {
        Query {
            counter: usize,
            query_vec: Vec <Query>,
            subst_vec: Vec <Subst>,
        },
        Prove {},
    }
    #+end_src

*** collect_var_from_query_vec

    #+begin_src rust
    fn collect_var_from_query_vec (
        query_vec: &Vec <Query>
    ) -> HashSet <VarTerm> {
        let mut var_set = HashSet::new ();
        for query in query_vec {
            for var in collect_var_from_term_vec (&query.args) {
                var_set.insert (var);
            }
        }
        var_set
    }
    #+end_src

*** collect_var_from_term

    #+begin_src rust
    fn collect_var_from_term (
        term: &Term
    ) -> HashSet <VarTerm> {
        match term {
            Term::Var (var) => {
                let mut var_set = HashSet::new ();
                var_set.insert (var.clone ());
                var_set
            }
            Term::Tuple (tuple) => {
                collect_var_from_term_vec (&tuple.body)
            }
        }
    }
    #+end_src

*** collect_var_from_term_vec

    #+begin_src rust
    fn collect_var_from_term_vec (
        term_vec: &Vec <Term>
    ) -> HashSet <VarTerm> {
        let mut var_set = HashSet::new ();
        for term in term_vec {
            for var in collect_var_from_term (term) {
                var_set.insert (var);
            }
        }
        var_set
    }
    #+end_src

*** WissenOutput::to_string

    #+begin_src rust
    impl ToString for WissenOutput {
        fn to_string (&self) -> String {
            match self {
                WissenOutput::Query {
                    counter,
                    query_vec,
                    subst_vec,
                } => {
                    let mut s = String::new ();
                    s += "<query-output>\n";
                    s += &vec_to_lines (&query_vec);
                    s += "- expecting ";
                    s += &counter.to_string ();
                    s += " results\n";
                    let var_set = collect_var_from_query_vec (
                        query_vec);
                    for subst in subst_vec {
                        for var in &var_set {
                            s += &var.to_string ();
                            s += " = ";
                            s += &subst.reify_var (var) .to_string ();
                            s += "\n";
                        }
                        s += "\n";
                    }
                    s += "</query-output>";
                    s
                }
                WissenOutput::Prove {} => {
                    format! ("")
                }
            }
        }
    }
    #+end_src

* Statement

*** Statement

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Statement {
        Prop (String, Prop),
        Query (usize, Vec <Query>),
        // Prove (usize, Vec <Query>),
    }
    #+end_src

* Proving

*** Proving

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Proving <'a> {
        proof_queue: VecDeque <Proof <'a>>,
    }
    #+end_src

*** Proving::next_subst

    #+begin_src rust
    impl <'a> Proving <'a> {
        pub fn next_subst (&mut self) -> Option <Subst> {
            while let Some (
                proof
            ) = self.proof_queue.pop_front () {
                // println! (
                //     "- Proving::next_subst = {}",
                //     proof.to_string ());
                match proof.step () {
                    ProofStep::Finished (subst) => {
                        return Some (subst);
                    }
                    ProofStep::MoreTodo (proof_queue) => {
                        for proof in proof_queue {
                            self.proof_queue.push_back (proof);
                        }
                    }
                    ProofStep::Fail => {}
                }
            }
            return None;
        }
    }
    #+end_src

*** Proving::take_subst

    #+begin_src rust
    impl <'a> Proving <'a> {
        pub fn take_subst (&mut self, n: usize) -> Vec <Subst> {
            let mut subst_vec = Vec::new ();
            for _ in 0..n {
                if let Some (subst) = self.next_subst () {
                    subst_vec.push (subst)
                }
            }
            subst_vec
        }
    }
    #+end_src

* Proof

*** Proof

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Proof <'a> {
        wissen: &'a Wissen,
        subst: Subst,
        query_queue: VecDeque <Arc <Query>>,
    }
    #+end_src

*** Proof::step

    #+begin_src rust
    impl <'a> Proof <'a> {
        fn step (mut self) -> ProofStep <'a> {
            if let Some (query) = self.query_queue.pop_front () {
                if let Some (
                    prop
                ) = self.wissen.find_prop (&query.name) {
                    let mut proof_queue = VecDeque::new ();
                    if let Some (
                        (query_matrix, new_subst)
                    ) = prop.apply (&query.args, self.subst.clone ()) {
                        for query_vec in query_matrix {
                            let mut proof = self.clone ();
                            proof.subst = new_subst.clone ();
                            let rev = query_vec.into_iter () .rev ();
                            for query in rev {
                                proof.query_queue.push_front (query);
                            }
                            proof_queue.push_back (proof);
                        }
                        ProofStep::MoreTodo (proof_queue)
                    } else {
                        ProofStep::Fail
                    }
                } else {
                    eprintln! ("- [warning] Proof::step");
                    eprintln! ("  undefined prop : {}", query.name);
                    ProofStep::Fail
                }
            } else {
                ProofStep::Finished (self.subst)
            }
        }
    }
    #+end_src

*** Proof::to_string

    #+begin_src rust
    impl <'a> ToString for Proof <'a> {
        fn to_string (&self) -> String {
            let query_vec: &Vec <Query> = &self.query_queue
                .iter ()
                .map (|x| (**x) .clone ())
                .collect ();
            format! (
                "<proof>\n\
                <query_queue>\n\
                {}</query_queue>\n\
                <subst>\n\
                {}</subst>\n\
                </proof>\n",
                vec_to_lines (query_vec),
                self.subst.to_string ())
        }
    }
    #+end_src

*** ProofStep

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum ProofStep <'a> {
        Finished (Subst),
        MoreTodo (VecDeque <Proof <'a>>),
        Fail,
    }
    #+end_src

* mexp

*** WISSEN_GRAMMAR

    #+begin_src rust
    const WISSEN_GRAMMAR: &'static str = r#"
    Statement::Prop = { prop-name? "=" Prop }
    Statement::Query = { "query" '(' num? ')' '{' list (Query) '}' }
    Statement::Prove = { "prove" '(' num? ')' '{' list (Query) '}' }
    Prop::Disj = { "disj" '(' list (prop-name?) ')' }
    Prop::Conj = { "conj" '(' list (Term) ')' '{' list (Query) '}' }
    Term::Var = { unique-var-name? }
    Term::Tuple = { tuple-name? '(' list (Term) ')' }
    Query::Tuple = { prop-name? '(' list (Term) ')' }
    "#;
    #+end_src

*** note_about_wissen_grammar

    #+begin_src rust
    fn note_about_wissen_grammar () -> ErrorMsg {
        ErrorMsg::new ()
            .head ("wissen grammar :")
            .lines (WISSEN_GRAMMAR)
    }
    #+end_src

*** mexp_to_prop_name

    #+begin_src rust
    fn mexp_to_prop_name <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <String, ErrorInCtx> {
        if let Mexp::Sym {
            symbol,
            ..
        } = mexp {
            if symbol.ends_with ("-t") {
                Ok (symbol.to_string ())
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name")
                    .line ("which must end with `-t`")
                    .line (&format! ("but found : {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_wissen_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .line ("expecting prop name")
                .line (&format! ("but found : {}", mexp.to_string ()))
                .span (mexp.span ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_disj_prop

    #+begin_src rust
    fn mexp_to_disj_prop <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Prop, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Sym {
                symbol: "disj",
                ..
            },
            arg: Arg::Tuple {
                body,
                ..
            },
            ..
        } = mexp {
            Ok (Prop::Disj (mexp_vec_to_prop_name_vec (body)?))
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_wissen_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_query

    #+begin_src rust
    fn mexp_to_query <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Query, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Sym {
                symbol,
                ..
            },
            arg: Arg::Tuple {
                body,
                ..
            },
            ..
        } = mexp {
            if symbol.ends_with ("-t") {
                Ok (Query {
                    name: symbol.to_string (),
                    args: mexp_vec_to_term_vec (body)?,
                })
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name")
                    .line ("which must end with `-t`")
                    .line (&format! ("but found : {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_wissen_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_wissen_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_term

    #+begin_src rust
    fn mexp_to_term <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Term, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Sym {
                symbol,
                ..
            },
            arg: Arg::Tuple {
                body,
                ..
            },
            ..
        } = mexp {
            if symbol.ends_with ("-c") {
                Ok (Term::tuple (
                    symbol,
                    mexp_vec_to_term_vec (body)?))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting tuple name")
                    .line ("which must end with `-c`")
                    .line (&format! ("but found : {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_wissen_grammar ())
                    .wrap_in_err ()
            }
        } else if let Mexp::Sym {
            symbol,
            ..
        } = mexp {
            if symbol.ends_with ("-c") {
                Ok (Term::tuple (symbol, vec! []))
            } else if symbol.ends_with ("-t") {
                ErrorInCtx::new ()
                    .line ("expecting tuple name or var")
                    .line ("but found prop name which end with `-t`")
                    .line (&format! ("prop name : {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_wissen_grammar ())
                    .wrap_in_err ()
            } else {
                Ok (Term::var_no_id (symbol))
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_wissen_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_conj_prop

    #+begin_src rust
    fn mexp_to_conj_prop <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Prop, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Apply {
                head: box Mexp::Sym {
                    symbol: "conj",
                    ..
                },
                arg: Arg::Tuple {
                    body: body1,
                    ..
                },
                ..
            },
            arg: Arg::Block {
                body: body2,
                ..
            },
            ..
        } = mexp {
            Ok (Prop::Conj (mexp_vec_to_term_vec (body1)?,
                            mexp_vec_to_query_vec (body2)?))
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_wissen_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_prop

    #+begin_src rust
    fn mexp_to_prop <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Prop, ErrorInCtx> {
        mexp_to_disj_prop (mexp)
            .or (mexp_to_conj_prop (mexp))
    }
    #+end_src

*** mexp_to_prop_statement

    #+begin_src rust
    fn mexp_to_prop_statement <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Statement, ErrorInCtx> {
        if let Mexp::Infix {
            op: "=",
            lhs: box Mexp::Sym {
                symbol,
                ..
            },
            rhs,
            ..
        } = mexp {
            if symbol.ends_with ("-t") {
                Ok (Statement::Prop (
                    symbol.to_string (),
                    mexp_to_prop (rhs)?))
            } else {
                ErrorInCtx::new ()
                    .line ("expecting prop name")
                    .line ("which must end with `-t`")
                    .line (&format! ("but found : {}", symbol))
                    .span (mexp.span ())
                    .note (note_about_wissen_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_wissen_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** mexp_to_query_statement

    #+begin_src rust
    fn mexp_to_query_statement <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Statement, ErrorInCtx> {
        if let Mexp::Apply {
            head: box Mexp::Apply {
                head: box Mexp::Sym {
                    symbol: "query",
                    ..
                },
                arg: Arg::Tuple {
                    body: body1,
                    ..
                },
                ..
            },
            arg: Arg::Block {
                body: body2,
                ..
            },
            ..
        } = mexp {
            if let [
                Mexp::Sym { symbol, .. }
            ] = &body1 [..] {
                let result = symbol.parse::<usize> ();
                if result.is_err () {
                    return ErrorInCtx::new ()
                        .line ("fail to parse usize num in query")
                        .line (&format! ("symbol : {}", symbol))
                        .span (mexp.span ())
                        .note (note_about_wissen_grammar ())
                        .wrap_in_err ();
                }
                Ok (Statement::Query (
                    result.unwrap (),
                    mexp_vec_to_query_vec (body2)?))
            } else {
                ErrorInCtx::new ()
                    .line ("fail to parse query's first arg")
                    .span (mexp.span ())
                    .note (note_about_wissen_grammar ())
                    .wrap_in_err ()
            }
        } else {
            ErrorInCtx::new ()
                .head ("syntex error")
                .span (mexp.span ())
                .note (note_about_wissen_grammar ())
                .wrap_in_err ()
        }
    }
    #+end_src

*** [todo] mexp_to_prove_statement

*** mexp_to_statement

    #+begin_src rust
    fn mexp_to_statement <'a> (
        mexp: &Mexp <'a>,
    ) -> Result <Statement, ErrorInCtx> {
        mexp_to_prop_statement (mexp)
            .or (mexp_to_query_statement (mexp))
        // .or (mexp_to_prove_statement (mexp))
    }
    #+end_src

*** mexp_vec_to_prop_name_vec

    #+begin_src rust
    fn mexp_vec_to_prop_name_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <String>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_prop_name (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

*** mexp_vec_to_query_vec

    #+begin_src rust
    fn mexp_vec_to_query_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <Query>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_query (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

*** mexp_vec_to_term_vec

    #+begin_src rust
    fn mexp_vec_to_term_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <Term>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_term (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

*** mexp_vec_to_statement_vec

    #+begin_src rust
    fn mexp_vec_to_statement_vec <'a> (
        mexp_vec: &Vec <Mexp <'a>>,
    ) -> Result <Vec <Statement>, ErrorInCtx> {
        let mut vec = Vec::new ();
        for mexp in mexp_vec {
            vec.push (mexp_to_statement (&mexp)?);
        }
        Ok (vec)
    }
    #+end_src

* test

*** test_unify

    #+begin_src rust
    #[test]
    fn test_unify () {
        let u = Term::var ("u");
        let v = Term::var ("v");
        let subst = Subst::new () .unify (
            &Term::tuple ("pair-c", vec! [
                u.clone (),
                v.clone (),
            ]),
            &Term::tuple ("pair-c", vec! [
                v.clone (),
                Term::tuple ("hi-c", vec! []),
            ])) .unwrap ();
        assert_eq! (subst.len (), 2);
    }
    #+end_src

*** test_love

    #+begin_src rust
    #[test]
    fn test_love () {
        let mut wissen = Wissen::new ();
        let prop = Prop::Conj (
            vec! [Term::tuple ("you-c", vec! [])],
            vec! []);
        wissen.prop ("love-t", &prop);
        let query = Query {
            name: "love-t".to_string (),
            args: vec! [Term::var ("u")],
        };
        let mut proving = wissen.proving (&vec! [query]);
        assert_eq! (
            proving.next_subst () .unwrap () .len (),
            1);
        assert_eq! (
            proving.next_subst (),
            None);
    }
    #+end_src

*** test_list_append

    #+begin_src rust
    #[test]
    fn test_list_append () {
        let mut wissen = Wissen::new ();
        let list_append_t = Prop::Disj (
            vec! [
                "zero-append-t".to_string (),
                "succ-append-t".to_string (),
            ]);
        wissen.prop ("list-append-t", &list_append_t);
        let succ = Term::var ("succ");
        let zero_append_t = Prop::Conj (
            vec! [
                Term::tuple ("null-c", vec! []),
                succ.clone (),
                succ
            ],
            vec! []);
        wissen.prop ("zero-append-t", &zero_append_t);
        let car = Term::var ("car");
        let cdr = Term::var ("cdr");
        let succ = Term::var ("succ");
        let o_cdr = Term::var ("o-cdr");
        let succ_append_t = Prop::Conj (
            vec! [
                Term::tuple ("cons-c",
                             vec! [car.clone (),
                                   cdr.clone ()]),
                succ.clone (),
                Term::tuple ("cons-c",
                             vec! [car,
                                   o_cdr.clone ()]),
            ],
            vec! [
                Query {
                    name: "list-append-t".to_string (),
                    args: vec! [
                        cdr,
                        succ,
                        o_cdr,
                    ],
                }
            ]);
        wissen.prop ("succ-append-t", &succ_append_t);
        let query = Query {
            name: "list-append-t".to_string (),
            args: vec! [Term::var ("x"),
                        Term::var ("y"),
                        Term::var ("z")],
        };
        let mut proving = wissen.proving (&vec! [query]);
        let subst_vec = proving.take_subst (100);
        assert_eq! (subst_vec.len (), 100);
        for subst in subst_vec {
            assert! (subst.cons_p ());
        }
    }
    #+end_src

*** LIST_APPEND_EXAMPLE

    #+begin_src rust
    #[cfg (test)]
    const LIST_APPEND_EXAMPLE: &'static str = "
    list-append-t = disj (
        zero-append-t
        succ-append-t
    )
    zero-append-t = conj (null-c succ succ) {}
    succ-append-t = conj (
        cons-c (car cdr)
        succ
        cons-c (car o-cdr)
    ) {
        list-append-t (cdr succ o-cdr)
    }

    query (10) { list-append-t (x y z) }
    ";
    #+end_src

*** test_mexp

    #+begin_src rust
    #[test]
    fn test_mexp () -> Result <(), ErrorInCtx> {
        let mut wissen = Wissen::new ();
        let input = LIST_APPEND_EXAMPLE;
        match wissen.wis (input) {
            Ok (mut output_vec) => {
                assert_eq! (output_vec.len (), 1);
                if let WissenOutput::Query {
                    subst_vec, ..
                } = output_vec.pop () .unwrap () {
                    assert_eq! (subst_vec.len (), 10);
                    for subst in subst_vec {
                        assert! (subst.cons_p ());
                    }
                } else {
                    panic! ()
                }
            }
            Err (error) => {
                let ctx = ErrorCtx::new ()
                    .body (input);
                error.report (ctx);
            }
        }
        Ok (())
    }
    #+end_src
